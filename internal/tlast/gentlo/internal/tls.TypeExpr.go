// Copyright 2022 V Kontakte LLC
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Code generated by vktl/cmd/tlgen2; DO NOT EDIT.
package internal

import (
	"github.com/vkcom/tl/internal/tlast/gentlo/basictl"
)

var _ = basictl.NatWrite

func (item TlsArray) AsUnion() TlsTypeExprUnion {
	var ret TlsTypeExprUnion
	ret.SetArray(item)
	return ret
}

// AsUnion will be here
type TlsArray struct {
	Multiplicity TlsNatExprUnion
	ArgsNum      uint32
	Args         []TlsArg
}

func (TlsArray) TLName() string { return "tls.array" }
func (TlsArray) TLTag() uint32  { return 0xd9fb20de }

func (item *TlsArray) Reset() {
	item.Multiplicity.Reset()
	item.ArgsNum = 0
	item.Args = item.Args[:0]
}

func (item *TlsArray) Read(w []byte) (_ []byte, err error) {
	if w, err = item.Multiplicity.ReadBoxed(w); err != nil {
		return w, err
	}
	if w, err = basictl.NatRead(w, &item.ArgsNum); err != nil {
		return w, err
	}
	return BuiltinTupleTlsArgBoxedRead(w, &item.Args, item.ArgsNum)
}

func (item *TlsArray) Write(w []byte) (_ []byte, err error) {
	if w, err = item.Multiplicity.WriteBoxed(w); err != nil {
		return w, err
	}
	w = basictl.NatWrite(w, item.ArgsNum)
	return BuiltinTupleTlsArgBoxedWrite(w, item.Args, item.ArgsNum)
}

func (item *TlsArray) ReadBoxed(w []byte) (_ []byte, err error) {
	if w, err = basictl.NatReadExactTag(w, 0xd9fb20de); err != nil {
		return w, err
	}
	return item.Read(w)
}

func (item *TlsArray) WriteBoxed(w []byte) ([]byte, error) {
	w = basictl.NatWrite(w, 0xd9fb20de)
	return item.Write(w)
}

func (item TlsArray) String() string {
	w, err := item.WriteJSON(nil)
	if err != nil {
		return err.Error()
	}
	return string(w)
}

func TlsArray__ReadJSON(item *TlsArray, j interface{}) error { return item.readJSON(j) }
func (item *TlsArray) readJSON(j interface{}) error {
	_jm, _ok := j.(map[string]interface{})
	if j != nil && !_ok {
		return ErrorInvalidJSON("tls.array", "expected json object")
	}
	_jMultiplicity := _jm["multiplicity"]
	delete(_jm, "multiplicity")
	_jArgsNum := _jm["args_num"]
	delete(_jm, "args_num")
	if err := JsonReadUint32(_jArgsNum, &item.ArgsNum); err != nil {
		return err
	}
	_jArgs := _jm["args"]
	delete(_jm, "args")
	for k := range _jm {
		return ErrorInvalidJSONExcessElement("tls.array", k)
	}
	if err := TlsNatExprUnion__ReadJSON(&item.Multiplicity, _jMultiplicity); err != nil {
		return err
	}
	if err := BuiltinTupleTlsArgBoxedReadJSON(_jArgs, &item.Args, item.ArgsNum); err != nil {
		return err
	}
	return nil
}

func (item *TlsArray) WriteJSON(w []byte) (_ []byte, err error) {
	return item.WriteJSONOpt(false, w)
}
func (item *TlsArray) WriteJSONOpt(short bool, w []byte) (_ []byte, err error) {
	w = append(w, '{')
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"multiplicity":`...)
	if w, err = item.Multiplicity.WriteJSONOpt(short, w); err != nil {
		return w, err
	}
	if item.ArgsNum != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"args_num":`...)
		w = basictl.JSONWriteUint32(w, item.ArgsNum)
	}
	if len(item.Args) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"args":`...)
		if w, err = BuiltinTupleTlsArgBoxedWriteJSONOpt(short, w, item.Args, item.ArgsNum); err != nil {
			return w, err
		}
	}
	return append(w, '}'), nil
}

func (item *TlsArray) MarshalJSON() ([]byte, error) {
	return item.WriteJSON(nil)
}

func (item *TlsArray) UnmarshalJSON(b []byte) error {
	j, err := JsonBytesToInterface(b)
	if err != nil {
		return ErrorInvalidJSON("tls.array", err.Error())
	}
	if err = item.readJSON(j); err != nil {
		return ErrorInvalidJSON("tls.array", err.Error())
	}
	return nil
}

func (item TlsTypeExpr) AsUnion() TlsTypeExprUnion {
	var ret TlsTypeExprUnion
	ret.SetTypeExpr(item)
	return ret
}

// AsUnion will be here
type TlsTypeExpr struct {
	Name        int32
	Flags       int32
	ChildrenNum uint32
	Children    []TlsExprUnion
}

func (TlsTypeExpr) TLName() string { return "tls.typeExpr" }
func (TlsTypeExpr) TLTag() uint32  { return 0xc1863d08 }

func (item *TlsTypeExpr) Reset() {
	item.Name = 0
	item.Flags = 0
	item.ChildrenNum = 0
	item.Children = item.Children[:0]
}

func (item *TlsTypeExpr) Read(w []byte) (_ []byte, err error) {
	if w, err = basictl.IntRead(w, &item.Name); err != nil {
		return w, err
	}
	if w, err = basictl.IntRead(w, &item.Flags); err != nil {
		return w, err
	}
	if w, err = basictl.NatRead(w, &item.ChildrenNum); err != nil {
		return w, err
	}
	return BuiltinTupleTlsExprBoxedRead(w, &item.Children, item.ChildrenNum)
}

func (item *TlsTypeExpr) Write(w []byte) (_ []byte, err error) {
	w = basictl.IntWrite(w, item.Name)
	w = basictl.IntWrite(w, item.Flags)
	w = basictl.NatWrite(w, item.ChildrenNum)
	return BuiltinTupleTlsExprBoxedWrite(w, item.Children, item.ChildrenNum)
}

func (item *TlsTypeExpr) ReadBoxed(w []byte) (_ []byte, err error) {
	if w, err = basictl.NatReadExactTag(w, 0xc1863d08); err != nil {
		return w, err
	}
	return item.Read(w)
}

func (item *TlsTypeExpr) WriteBoxed(w []byte) ([]byte, error) {
	w = basictl.NatWrite(w, 0xc1863d08)
	return item.Write(w)
}

func (item TlsTypeExpr) String() string {
	w, err := item.WriteJSON(nil)
	if err != nil {
		return err.Error()
	}
	return string(w)
}

func TlsTypeExpr__ReadJSON(item *TlsTypeExpr, j interface{}) error { return item.readJSON(j) }
func (item *TlsTypeExpr) readJSON(j interface{}) error {
	_jm, _ok := j.(map[string]interface{})
	if j != nil && !_ok {
		return ErrorInvalidJSON("tls.typeExpr", "expected json object")
	}
	_jName := _jm["name"]
	delete(_jm, "name")
	if err := JsonReadInt32(_jName, &item.Name); err != nil {
		return err
	}
	_jFlags := _jm["flags"]
	delete(_jm, "flags")
	if err := JsonReadInt32(_jFlags, &item.Flags); err != nil {
		return err
	}
	_jChildrenNum := _jm["children_num"]
	delete(_jm, "children_num")
	if err := JsonReadUint32(_jChildrenNum, &item.ChildrenNum); err != nil {
		return err
	}
	_jChildren := _jm["children"]
	delete(_jm, "children")
	for k := range _jm {
		return ErrorInvalidJSONExcessElement("tls.typeExpr", k)
	}
	if err := BuiltinTupleTlsExprBoxedReadJSON(_jChildren, &item.Children, item.ChildrenNum); err != nil {
		return err
	}
	return nil
}

func (item *TlsTypeExpr) WriteJSON(w []byte) (_ []byte, err error) {
	return item.WriteJSONOpt(false, w)
}
func (item *TlsTypeExpr) WriteJSONOpt(short bool, w []byte) (_ []byte, err error) {
	w = append(w, '{')
	if item.Name != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"name":`...)
		w = basictl.JSONWriteInt32(w, item.Name)
	}
	if item.Flags != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"flags":`...)
		w = basictl.JSONWriteInt32(w, item.Flags)
	}
	if item.ChildrenNum != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"children_num":`...)
		w = basictl.JSONWriteUint32(w, item.ChildrenNum)
	}
	if len(item.Children) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"children":`...)
		if w, err = BuiltinTupleTlsExprBoxedWriteJSONOpt(short, w, item.Children, item.ChildrenNum); err != nil {
			return w, err
		}
	}
	return append(w, '}'), nil
}

func (item *TlsTypeExpr) MarshalJSON() ([]byte, error) {
	return item.WriteJSON(nil)
}

func (item *TlsTypeExpr) UnmarshalJSON(b []byte) error {
	j, err := JsonBytesToInterface(b)
	if err != nil {
		return ErrorInvalidJSON("tls.typeExpr", err.Error())
	}
	if err = item.readJSON(j); err != nil {
		return ErrorInvalidJSON("tls.typeExpr", err.Error())
	}
	return nil
}

var _TlsTypeExprUnion = [3]UnionElement{
	{TLTag: 0x142ceae, TLName: "tls.typeVar", TLString: "tls.typeVar#0142ceae"},
	{TLTag: 0xd9fb20de, TLName: "tls.array", TLString: "tls.array#d9fb20de"},
	{TLTag: 0xc1863d08, TLName: "tls.typeExpr", TLString: "tls.typeExpr#c1863d08"},
}

type TlsTypeExprUnion struct {
	valueTypeVar  TlsTypeVar
	valueArray    TlsArray
	valueTypeExpr TlsTypeExpr
	index         int
}

func (item TlsTypeExprUnion) TLName() string { return _TlsTypeExprUnion[item.index].TLName }
func (item TlsTypeExprUnion) TLTag() uint32  { return _TlsTypeExprUnion[item.index].TLTag }

func (item *TlsTypeExprUnion) Reset() { item.ResetToTypeVar() }

func (item *TlsTypeExprUnion) IsTypeVar() bool { return item.index == 0 }

func (item *TlsTypeExprUnion) AsTypeVar() (*TlsTypeVar, bool) {
	if item.index != 0 {
		return nil, false
	}
	return &item.valueTypeVar, true
}
func (item *TlsTypeExprUnion) ResetToTypeVar() *TlsTypeVar {
	item.index = 0
	item.valueTypeVar.Reset()
	return &item.valueTypeVar
}
func (item *TlsTypeExprUnion) SetTypeVar(value TlsTypeVar) {
	item.index = 0
	item.valueTypeVar = value
}

func (item *TlsTypeExprUnion) IsArray() bool { return item.index == 1 }

func (item *TlsTypeExprUnion) AsArray() (*TlsArray, bool) {
	if item.index != 1 {
		return nil, false
	}
	return &item.valueArray, true
}
func (item *TlsTypeExprUnion) ResetToArray() *TlsArray {
	item.index = 1
	item.valueArray.Reset()
	return &item.valueArray
}
func (item *TlsTypeExprUnion) SetArray(value TlsArray) {
	item.index = 1
	item.valueArray = value
}

func (item *TlsTypeExprUnion) IsTypeExpr() bool { return item.index == 2 }

func (item *TlsTypeExprUnion) AsTypeExpr() (*TlsTypeExpr, bool) {
	if item.index != 2 {
		return nil, false
	}
	return &item.valueTypeExpr, true
}
func (item *TlsTypeExprUnion) ResetToTypeExpr() *TlsTypeExpr {
	item.index = 2
	item.valueTypeExpr.Reset()
	return &item.valueTypeExpr
}
func (item *TlsTypeExprUnion) SetTypeExpr(value TlsTypeExpr) {
	item.index = 2
	item.valueTypeExpr = value
}

func (item *TlsTypeExprUnion) ReadBoxed(w []byte) (_ []byte, err error) {
	var tag uint32
	if w, err = basictl.NatRead(w, &tag); err != nil {
		return w, err
	}
	switch tag {
	case 0x142ceae:
		item.index = 0
		return item.valueTypeVar.Read(w)
	case 0xd9fb20de:
		item.index = 1
		return item.valueArray.Read(w)
	case 0xc1863d08:
		item.index = 2
		return item.valueTypeExpr.Read(w)
	default:
		return w, ErrorInvalidUnionTag("tls.TypeExpr", tag)
	}
}

func (item *TlsTypeExprUnion) WriteBoxed(w []byte) (_ []byte, err error) {
	w = basictl.NatWrite(w, _TlsTypeExprUnion[item.index].TLTag)
	switch item.index {
	case 0:
		return item.valueTypeVar.Write(w)
	case 1:
		return item.valueArray.Write(w)
	case 2:
		return item.valueTypeExpr.Write(w)
	default: // Impossible due to panic above
		return w, nil
	}
}

func TlsTypeExprUnion__ReadJSON(item *TlsTypeExprUnion, j interface{}) error { return item.readJSON(j) }
func (item *TlsTypeExprUnion) readJSON(j interface{}) error {
	_jm, _tag, err := JsonReadUnionType("tls.TypeExpr", j)
	if err != nil {
		return err
	}
	jvalue := _jm["value"]
	switch _tag {
	case "tls.typeVar#0142ceae", "tls.typeVar", "#0142ceae":
		item.index = 0
		if err := TlsTypeVar__ReadJSON(&item.valueTypeVar, jvalue); err != nil {
			return err
		}
		delete(_jm, "value")
	case "tls.array#d9fb20de", "tls.array", "#d9fb20de":
		item.index = 1
		if err := TlsArray__ReadJSON(&item.valueArray, jvalue); err != nil {
			return err
		}
		delete(_jm, "value")
	case "tls.typeExpr#c1863d08", "tls.typeExpr", "#c1863d08":
		item.index = 2
		if err := TlsTypeExpr__ReadJSON(&item.valueTypeExpr, jvalue); err != nil {
			return err
		}
		delete(_jm, "value")
	default:
		return ErrorInvalidUnionTagJSON("tls.TypeExpr", _tag)
	}
	for k := range _jm {
		return ErrorInvalidJSONExcessElement("tls.TypeExpr", k)
	}
	return nil
}

func (item *TlsTypeExprUnion) WriteJSON(w []byte) (_ []byte, err error) {
	return item.WriteJSONOpt(false, w)
}
func (item *TlsTypeExprUnion) WriteJSONOpt(short bool, w []byte) (_ []byte, err error) {
	switch item.index {
	case 0:
		w = append(w, `{"type":"tls.typeVar#0142ceae","value":`...)
		if w, err = item.valueTypeVar.WriteJSONOpt(short, w); err != nil {
			return w, err
		}
		return append(w, '}'), nil
	case 1:
		w = append(w, `{"type":"tls.array#d9fb20de","value":`...)
		if w, err = item.valueArray.WriteJSONOpt(short, w); err != nil {
			return w, err
		}
		return append(w, '}'), nil
	case 2:
		w = append(w, `{"type":"tls.typeExpr#c1863d08","value":`...)
		if w, err = item.valueTypeExpr.WriteJSONOpt(short, w); err != nil {
			return w, err
		}
		return append(w, '}'), nil
	default: // Impossible due to panic above
		return w, nil
	}
}

func (item TlsTypeExprUnion) String() string {
	w, err := item.WriteJSON(nil)
	if err != nil {
		return err.Error()
	}
	return string(w)
}

func (item TlsTypeVar) AsUnion() TlsTypeExprUnion {
	var ret TlsTypeExprUnion
	ret.SetTypeVar(item)
	return ret
}

// AsUnion will be here
type TlsTypeVar struct {
	VarNum int32
	Flags  int32
}

func (TlsTypeVar) TLName() string { return "tls.typeVar" }
func (TlsTypeVar) TLTag() uint32  { return 0x142ceae }

func (item *TlsTypeVar) Reset() {
	item.VarNum = 0
	item.Flags = 0
}

func (item *TlsTypeVar) Read(w []byte) (_ []byte, err error) {
	if w, err = basictl.IntRead(w, &item.VarNum); err != nil {
		return w, err
	}
	return basictl.IntRead(w, &item.Flags)
}

func (item *TlsTypeVar) Write(w []byte) (_ []byte, err error) {
	w = basictl.IntWrite(w, item.VarNum)
	return basictl.IntWrite(w, item.Flags), nil
}

func (item *TlsTypeVar) ReadBoxed(w []byte) (_ []byte, err error) {
	if w, err = basictl.NatReadExactTag(w, 0x142ceae); err != nil {
		return w, err
	}
	return item.Read(w)
}

func (item *TlsTypeVar) WriteBoxed(w []byte) ([]byte, error) {
	w = basictl.NatWrite(w, 0x142ceae)
	return item.Write(w)
}

func (item TlsTypeVar) String() string {
	w, err := item.WriteJSON(nil)
	if err != nil {
		return err.Error()
	}
	return string(w)
}

func TlsTypeVar__ReadJSON(item *TlsTypeVar, j interface{}) error { return item.readJSON(j) }
func (item *TlsTypeVar) readJSON(j interface{}) error {
	_jm, _ok := j.(map[string]interface{})
	if j != nil && !_ok {
		return ErrorInvalidJSON("tls.typeVar", "expected json object")
	}
	_jVarNum := _jm["var_num"]
	delete(_jm, "var_num")
	if err := JsonReadInt32(_jVarNum, &item.VarNum); err != nil {
		return err
	}
	_jFlags := _jm["flags"]
	delete(_jm, "flags")
	if err := JsonReadInt32(_jFlags, &item.Flags); err != nil {
		return err
	}
	for k := range _jm {
		return ErrorInvalidJSONExcessElement("tls.typeVar", k)
	}
	return nil
}

func (item *TlsTypeVar) WriteJSON(w []byte) (_ []byte, err error) {
	return item.WriteJSONOpt(false, w)
}
func (item *TlsTypeVar) WriteJSONOpt(short bool, w []byte) (_ []byte, err error) {
	w = append(w, '{')
	if item.VarNum != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"var_num":`...)
		w = basictl.JSONWriteInt32(w, item.VarNum)
	}
	if item.Flags != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"flags":`...)
		w = basictl.JSONWriteInt32(w, item.Flags)
	}
	return append(w, '}'), nil
}

func (item *TlsTypeVar) MarshalJSON() ([]byte, error) {
	return item.WriteJSON(nil)
}

func (item *TlsTypeVar) UnmarshalJSON(b []byte) error {
	j, err := JsonBytesToInterface(b)
	if err != nil {
		return ErrorInvalidJSON("tls.typeVar", err.Error())
	}
	if err = item.readJSON(j); err != nil {
		return ErrorInvalidJSON("tls.typeVar", err.Error())
	}
	return nil
}
