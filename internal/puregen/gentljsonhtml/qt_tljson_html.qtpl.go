// Code generated by qtc from "qt_tljson_html.qtpl". DO NOT EDIT.
// See https://github.com/valyala/quicktemplate for details.

package gentljsonhtml

import "fmt"

import "time"

import "strings"

import "github.com/vkcom/tl/internal/tlast"

import "github.com/vkcom/tl/internal/pure"

import "github.com/vkcom/tl/internal/puregen"

import (
	qtio422016 "io"

	qt422016 "github.com/valyala/quicktemplate"
)

var (
	_ = qtio422016.Copy
	_ = qt422016.AcquireByteBuffer
)

func streamtlJSON(qw422016 *qt422016.Writer, kernel *pure.Kernel, options *puregen.Options, sortedInstances []pure.TypeInstance, tlgenVersion string) {
	qw422016.N().S(`<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>TL JSON help</title>
  </head>
  <body>
    <h1>Schema</h1>
    <ul>
      <li>tlgen version: `)
	qw422016.E().S(tlgenVersion)
	qw422016.N().S(`</li>
`)
	if options.SchemaURL != "" {
		qw422016.N().S(`      <li><abbr>TL</abbr> schema <a href="`)
		qw422016.E().S(options.SchemaURL)
		qw422016.N().S(`">url</a></li>
`)
	}
	if options.SchemaCommit != "" {
		qw422016.N().S(`      <li><abbr>TL</abbr> schema commit: `)
		qw422016.E().S(options.SchemaCommit)
		qw422016.N().S(`</li>
`)
	}
	if options.SchemaTimestamp != 0 {
		qw422016.N().S(`      <li><abbr>TL</abbr> schema version: `)
		qw422016.E().V(options.SchemaTimestamp)
		qw422016.N().S(` (`)
		qw422016.E().V(time.Unix(int64(options.SchemaTimestamp), 0).UTC())
		qw422016.N().S(`)</li>
`)
	}
	qw422016.N().S(`      <li><abbr>TL</abbr> ⟷ <abbr>JSON</abbr> mapping rules: <a href="https://github.com/VKCOM/tl/blob/master/TLJSON.md">TLJSON.md</a></li>
    </ul>
    <h1>Functions</h1>
    <ul>
`)
	for _, trww := range sortedInstances {
		if trww.KernelType().OriginTL2() {
			continue
		}
		if fun, ok := trww.(*pure.TypeInstanceStruct); ok && fun.ResultType() != nil {
			qw422016.N().S(`      <li>
        <a href="#`)
			qw422016.E().S(trww.CanonicalName())
			qw422016.N().S(`">
        <code>`)
			qw422016.E().S(JSONHelpString(kernel, trww))
			qw422016.N().S(`</code></a>
        → <code>`)
			streamprintJSONHelpType2(qw422016, kernel, fun.ResultType(), false, fun.Fields(), fun.ResultNatArgs())
			qw422016.N().S(`</code>
      </li>
`)
		}
	}
	qw422016.N().S(`    </ul>
    <h1>Types</h1>
<h2 id="#">#</h2>
Builtin type <code>#</code>. Represents <code>uint32</code>. Can be used as field mask or collection size.
`)
	for _, trww := range sortedInstances {
		if trww.KernelType().OriginTL2() {
			continue
		}
		streamprintHTMLHelp(qw422016, kernel, trww)
		qw422016.N().S(`
`)
	}
	qw422016.N().S(`  </body>
</html>
`)
}

func writetlJSON(qq422016 qtio422016.Writer, kernel *pure.Kernel, options *puregen.Options, sortedInstances []pure.TypeInstance, tlgenVersion string) {
	qw422016 := qt422016.AcquireWriter(qq422016)
	streamtlJSON(qw422016, kernel, options, sortedInstances, tlgenVersion)
	qt422016.ReleaseWriter(qw422016)
}

func tlJSON(kernel *pure.Kernel, options *puregen.Options, sortedInstances []pure.TypeInstance, tlgenVersion string) string {
	qb422016 := qt422016.AcquireByteBuffer()
	writetlJSON(qb422016, kernel, options, sortedInstances, tlgenVersion)
	qs422016 := string(qb422016.B)
	qt422016.ReleaseByteBuffer(qb422016)
	return qs422016
}

func streamprintJSONHelpType2(qw422016 *qt422016.Writer, kernel *pure.Kernel, trww pure.TypeInstance, bare bool, fields []pure.Field, natArgs []pure.ActualNatArg) {
	switch trw := trww.(type) {
	case *pure.TypeInstancePrimitive:
		qw422016.E().S("<")
		qw422016.E().S(trw.CanonicalName())
		qw422016.E().S(">")
	case *pure.TypeInstanceStruct:
		if trw.IsTypeDef() {
			streamprintJSONHelpType2(qw422016, kernel, trw.Fields()[0].TypeInstance(), trw.Fields()[0].Bare(), fields, trww.Common().TransformNatArgsToChild(natArgs, trw.Fields()[0].NatArgs()))
		} else if len(trw.Fields()) == 0 {
			qw422016.E().S("{}")
		} else {
			streammakeRef(qw422016, trw.CanonicalName(), JSONHelpFullType(kernel, trww, bare, fields, natArgs))
		}
	case *pure.TypeInstanceUnion:
		streammakeRef(qw422016, trw.CanonicalName(), JSONHelpFullType(kernel, trww, bare, fields, natArgs))
	case *pure.TypeInstanceDict:
		elementNatArgs := trww.Common().TransformNatArgsToChild(natArgs, trw.Field().NatArgs())

		qw422016.E().S("{")
		streamprintJSONHelpType2(qw422016, kernel, trw.FieldType().Fields()[0].TypeInstance(), trw.FieldType().Fields()[0].Bare(), fields, trw.FieldType().Common().TransformNatArgsToChild(elementNatArgs, trw.FieldType().Fields()[0].NatArgs()))
		qw422016.E().S(": ")
		streamprintJSONHelpType2(qw422016, kernel, trw.FieldType().Fields()[1].TypeInstance(), trw.FieldType().Fields()[1].Bare(), fields, trw.FieldType().Common().TransformNatArgsToChild(elementNatArgs, trw.FieldType().Fields()[1].NatArgs()))
		qw422016.E().S("}")
	case *pure.TypeInstanceArray:
		elementNatArgs := trww.Common().TransformNatArgsToChild(natArgs, trw.ElemNatArgs())

		switch {
		case !trw.IsTuple():
			qw422016.E().S("[")
			streamprintJSONHelpType2(qw422016, kernel, trw.ElemType(), trw.ElemBare(), fields, elementNatArgs)
			qw422016.E().S(", ...]")
		case trw.DynamicSize():
			qw422016.E().S("[")
			qw422016.E().S(JSONHelpNatArg(trww, fields, natArgs[len(natArgs)-1]))
			qw422016.E().S(" × ")
			streamprintJSONHelpType2(qw422016, kernel, trw.ElemType(), trw.ElemBare(), fields, elementNatArgs)
			qw422016.E().S("]")
		default:
			qw422016.E().S("[")
			qw422016.E().V(trw.Count())
			qw422016.E().S(" × ")
			streamprintJSONHelpType2(qw422016, kernel, trw.ElemType(), trw.ElemBare(), fields, elementNatArgs)
			qw422016.E().S("]")
		}
	}
}

func writeprintJSONHelpType2(qq422016 qtio422016.Writer, kernel *pure.Kernel, trww pure.TypeInstance, bare bool, fields []pure.Field, natArgs []pure.ActualNatArg) {
	qw422016 := qt422016.AcquireWriter(qq422016)
	streamprintJSONHelpType2(qw422016, kernel, trww, bare, fields, natArgs)
	qt422016.ReleaseWriter(qw422016)
}

func printJSONHelpType2(kernel *pure.Kernel, trww pure.TypeInstance, bare bool, fields []pure.Field, natArgs []pure.ActualNatArg) string {
	qb422016 := qt422016.AcquireByteBuffer()
	writeprintJSONHelpType2(qb422016, kernel, trww, bare, fields, natArgs)
	qs422016 := string(qb422016.B)
	qt422016.ReleaseByteBuffer(qb422016)
	return qs422016
}

func streamprintHTMLHelp(qw422016 *qt422016.Writer, kernel *pure.Kernel, trww pure.TypeInstance) {
	if trw, ok := trww.(*pure.TypeInstanceStruct); ok && ((trw.ResultType() == nil && len(trw.Fields()) == 0) || trw.IsTypeDef()) {
		return
	}
	if _, ok := trww.(*pure.TypeInstanceDict); ok {
		return
	}
	if _, ok := trww.(*pure.TypeInstanceArray); ok {
		return
	}
	if _, ok := trww.(*pure.TypeInstancePrimitive); ok {
		return
	}
	commentsBefore := trww.KernelType().CommentsBefore()
	commentsRight := trww.KernelType().CommentsRight()
	combinatorTexts := trww.KernelType().CombinatorTexts()

	qw422016.N().S(`<h2 id="`)
	qw422016.E().S(trww.CanonicalName())
	qw422016.N().S(`">`)
	qw422016.E().S(JSONHelpString(kernel, trww))
	qw422016.N().S(`</h2>
`)
	if len(commentsBefore) == 1 && commentsBefore[0] != "" {
		for _, line := range tlast.SplitMultilineComment(commentsBefore[0]) {
			qw422016.N().S(`    <code style="color:DarkCyan">`)
			qw422016.E().S(line)
			qw422016.N().S(`</code></br>
`)
		}
	}
	qw422016.N().S(`
`)
	if len(trww.Common().NatParams()) != 0 {
		qw422016.N().S(`External # (nat) arguments: <b>`)
		qw422016.E().S(strings.Join(trww.Common().NatParams(), ", "))
		qw422016.N().S(`</b>
`)
	}
	qw422016.N().S(`<p></p>
`)
	switch trw := trww.(type) {
	case *pure.TypeInstancePrimitive:
		qw422016.N().S(`<dl>
  <dt>JSON</dt>
  <dd>`)
		qw422016.E().S(trw.CanonicalName())
		qw422016.N().S(`</dd>
</dl>
`)
	case *pure.TypeInstanceStruct:
		if trw.ResultType() != nil {
			qw422016.N().S(`  Returns <code>`)
			streamprintJSONHelpType2(qw422016, kernel, trw.ResultType(), false, trw.Fields(), trw.ResultNatArgs())
			qw422016.N().S(`</code>
`)
		}
		qw422016.N().S(`<dl>
  <dt>JSON</dt>
  <dd><code>
`)
		if trw.ResultType() != nil && len(trw.Fields()) == 0 {
			qw422016.N().S(`    {}
`)
		} else {
			qw422016.N().S(`    {
      <table>
`)
			for i, field := range trw.Fields() {
				if field.CommentBefore() != "" {
					for _, line := range tlast.SplitMultilineComment(field.CommentBefore()) {
						qw422016.N().S(`          <tr><td colspan="4">
            <code style="color:DarkCyan">`)
						qw422016.E().S(line)
						qw422016.N().S(`</code>
          </td></tr>
`)
					}
				}
				qw422016.N().S(`        <tr>

`)
				if field.IsBit() {
					qw422016.N().S(`          <td>&nbsp;&nbsp;"`)
					qw422016.E().S(field.Name())
					qw422016.N().S(`"</td><td>: true`)
					if i != len(trw.Fields())-1 {
						qw422016.N().S(`,`)
					}
					qw422016.N().S(`</td>
`)
				} else {
					qw422016.N().S(`          <td>&nbsp;&nbsp;"`)
					qw422016.E().S(field.Name())
					qw422016.N().S(`"</td><td>: `)
					streamprintJSONHelpType2(qw422016, kernel, field.TypeInstance(), field.Bare(), trw.Fields(), field.NatArgs())
					if i != len(trw.Fields())-1 {
						qw422016.N().S(`,`)
					}
					qw422016.N().S(`</td>
`)
				}
				qw422016.N().S(`          <td>`)
				streamjsonCommentFieldMask(qw422016, field.FieldMask(), field.BitNumber(), trw.Fields())
				qw422016.N().S(`</td>
          <td>
`)
				if field.CommentRight() != "" {
					for _, line := range tlast.SplitMultilineComment(field.CommentRight()) {
						qw422016.N().S(`    <code style="color:DarkCyan">`)
						qw422016.E().S(line)
						qw422016.N().S(`</code></td></tr><tr><td colspan="4">
`)
					}
				}
				qw422016.N().S(`          </td>
        </tr>
`)
			}
			qw422016.N().S(`      </table>
    }
`)
		}
		qw422016.N().S(`</code></dd>
  <dt>TL</dt>
  <dd>
    <code>`)
		qw422016.E().S(combinatorTexts[0])
		qw422016.N().S(`</code>
`)
		if commentsRight[0] != "" {
			for _, line := range tlast.SplitMultilineComment(commentsRight[0]) {
				qw422016.N().S(`    <code style="color:DarkCyan">`)
				qw422016.E().S(line)
				qw422016.N().S(`</code></br>
`)
			}
		}
		qw422016.N().S(`  </dd>
</dl>
`)
	case *pure.TypeInstanceUnion:
		if isMaybe, elementField := trw.IsUnionMaybe(); isMaybe {
			qw422016.N().S(`<dl>
  <dt>JSON</dt>
  <dd>
    <ul>
      <li><code>{}</code></li>
      <li><code>`)
			qw422016.E().S(`{"value": `)
			streamprintJSONHelpType2(qw422016, kernel, elementField.TypeInstance(), elementField.Bare(), nil, trw.ElementNatArgs())
			qw422016.E().S("}")
			qw422016.N().S(`</code></li>
    </ul>
  </dd>
  <dt>TL</dt>
  <dd>
    <ul>
    <li><code>`)
			qw422016.E().S(combinatorTexts[0])
			qw422016.N().S(`</code></li>
    <li><code>`)
			qw422016.E().S(combinatorTexts[1])
			qw422016.N().S(`</code></li>
    </ul>
  </dd>
</dl>
`)
		}
		qw422016.N().S(`<dl>
  <dt>JSON</dt>
  <dd><code>
      <table>
`)
		for i, field := range trw.VariantTypes() {
			tag := fmt.Sprintf("%08x", field.TLTag())
			originalName := field.TLName().String()

			qw422016.N().S(`            <tr>
`)
			if trw.IsEnum() {
				qw422016.N().S(`                <td><span title='Can be also specified as "`)
				qw422016.E().S(originalName)
				qw422016.N().S(`" or "#`)
				qw422016.E().S(tag)
				qw422016.N().S(`"' style="color:MediumVioletRed">"`)
				qw422016.E().S(originalName)
				qw422016.N().S(`#`)
				qw422016.E().S(tag)
				qw422016.N().S(`"</span></td><td></td>
`)
			} else {
				qw422016.N().S(`                <td>{"type":<span title='Can be also specified as "`)
				qw422016.E().S(originalName)
				qw422016.N().S(`" or "#`)
				qw422016.E().S(tag)
				qw422016.N().S(`"' style="color:MediumVioletRed">"`)
				qw422016.E().S(originalName)
				qw422016.N().S(`#`)
				qw422016.E().S(tag)
				qw422016.N().S(`"</span>`)
				if !IsEmptyStruct(field) {
					qw422016.N().S(`,</td><td>"value":`)
					streammakeRef(qw422016, field.CanonicalName(), JSONHelpString(kernel, field))
					qw422016.N().S(`}</td>`)
				} else {
					qw422016.N().S(`}</td><td></td>`)
				}
			}
			qw422016.N().S(`          <td>
`)
			if commentsRight[i] != "" {
				for _, line := range tlast.SplitMultilineComment(commentsRight[i]) {
					qw422016.N().S(`    <code style="color:DarkCyan">`)
					qw422016.E().S(line)
					qw422016.N().S(`</code></td></tr><tr><td colspan="3">
`)
				}
			}
			qw422016.N().S(`          </td>
        </tr>
`)
		}
		qw422016.N().S(`      </table>
  </code></dd>
  <dt>TL</dt>
  <dd>
    <ul>
`)
		for _, origTL := range combinatorTexts {
			qw422016.N().S(`    <li>
    <code>`)
			qw422016.E().S(origTL)
			qw422016.N().S(`</code>
    </li>
`)
		}
		qw422016.N().S(`    </ul>
  </dd>
</dl>
`)
		for _, field := range trw.VariantTypes() {
			streamprintHTMLHelp(qw422016, kernel, field)
			qw422016.N().S(`
`)
		}
	}
}

func writeprintHTMLHelp(qq422016 qtio422016.Writer, kernel *pure.Kernel, trww pure.TypeInstance) {
	qw422016 := qt422016.AcquireWriter(qq422016)
	streamprintHTMLHelp(qw422016, kernel, trww)
	qt422016.ReleaseWriter(qw422016)
}

func printHTMLHelp(kernel *pure.Kernel, trww pure.TypeInstance) string {
	qb422016 := qt422016.AcquireByteBuffer()
	writeprintHTMLHelp(qb422016, kernel, trww)
	qs422016 := string(qb422016.B)
	qt422016.ReleaseByteBuffer(qb422016)
	return qs422016
}

func streamjsonCommentFieldMask(qw422016 *qt422016.Writer, fm *pure.ActualNatArg, num uint32, fields []pure.Field) {
	if fm == nil {
		return
	}
	if fm.IsField() {
		qw422016.N().S(`// `)
		qw422016.E().S(fields[fm.FieldIndex()].Name())
		qw422016.N().S(` bit #`)
		qw422016.E().V(num)
		qw422016.N().S(`
`)
	} else if fm.IsNumber() && (fm.Number()&(1<<num)) != 0 {
		qw422016.N().S(`// `)
		qw422016.E().V(fm.Number())
		qw422016.N().S(` bit #`)
		qw422016.E().V(num)
		qw422016.N().S(` = true
`)
	} else if fm.IsNumber() {
		qw422016.N().S(`// `)
		qw422016.E().V(fm.Number())
		qw422016.N().S(` bit #`)
		qw422016.E().V(num)
		qw422016.N().S(` = false
`)
	} else {
		qw422016.N().S(`// `)
		qw422016.E().S(fm.Name())
		qw422016.N().S(` bit #`)
		qw422016.E().V(num)
		qw422016.N().S(`
`)
	}
}

func writejsonCommentFieldMask(qq422016 qtio422016.Writer, fm *pure.ActualNatArg, num uint32, fields []pure.Field) {
	qw422016 := qt422016.AcquireWriter(qq422016)
	streamjsonCommentFieldMask(qw422016, fm, num, fields)
	qt422016.ReleaseWriter(qw422016)
}

func jsonCommentFieldMask(fm *pure.ActualNatArg, num uint32, fields []pure.Field) string {
	qb422016 := qt422016.AcquireByteBuffer()
	writejsonCommentFieldMask(qb422016, fm, num, fields)
	qs422016 := string(qb422016.B)
	qt422016.ReleaseByteBuffer(qb422016)
	return qs422016
}

func streammakeRef(qw422016 *qt422016.Writer, a string, s string) {
	qw422016.N().S(`<a href="#`)
	qw422016.E().S(a)
	qw422016.N().S(`">`)
	qw422016.E().S(s)
	qw422016.N().S(`</a>`)
}

func writemakeRef(qq422016 qtio422016.Writer, a string, s string) {
	qw422016 := qt422016.AcquireWriter(qq422016)
	streammakeRef(qw422016, a, s)
	qt422016.ReleaseWriter(qw422016)
}

func makeRef(a string, s string) string {
	qb422016 := qt422016.AcquireByteBuffer()
	writemakeRef(qb422016, a, s)
	qs422016 := string(qb422016.B)
	qt422016.ReleaseByteBuffer(qb422016)
	return qs422016
}
