// Copyright 2025 V Kontakte LLC
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package gengo

import (
	"fmt"
	"log"
	"path/filepath"
	"slices"
	"strings"

	"github.com/vkcom/tl/internal/pure"
	"github.com/vkcom/tl/internal/puregen"
	"github.com/vkcom/tl/pkg/basictl"
)

const markerFile = "tlgen2_version.txt"

const BasicTLGoPackageName = "basictl" // does not contain tl prefix
const FactoryGoPackageName = "factory" // does not contain tl prefix
const FactoryGoPackageNameBytes = "factory_bytes"
const MetaGoPackageName = "meta" // does not contain tl prefix
const ConstantsPackageName = "constants"
const HeaderComment = "// Code generated by vktl/cmd/tlgen2; DO NOT EDIT."

// const BasicTLCPPNamespaceName = "basictl" // does not contain tl prefix

type genGo struct {
	CopyrightText string

	// TODO - remove, use opts.BasicPackageNameFull
	BasicPackageNameFull     string // basic types are in separate namespace to minimize conflicts
	BasicPackageRelativePath string // if cannot determine relative path, will not be written
	GlobalPackageName        string // we generate all go types in this package, because we need circular dependencies
	FactoryPackageName       string
	MetaPackageName          string
}

func Generate(kernel *pure.Kernel, opts *puregen.Options) (err error) {
	gen := genGo{}
	if gen.CopyrightText, err = opts.CopyrightText(); err != nil {
		return err
	}

	if opts.GenerateRPCCode && opts.Go.BasicRPCPath == "" {
		return fmt.Errorf("--basicRPCPath must be specified if --generateRPCCode is set")
	}
	opts.Go.TLPackageNameFull = strings.TrimSpace(opts.Go.TLPackageNameFull)
	opts.Go.TLPackageNameFull = strings.TrimSuffix(opts.Go.TLPackageNameFull, "/")
	if opts.Go.TLPackageNameFull == "" { // for testing, empty path should be prohibited in main argv parsing
		opts.Go.TLPackageNameFull = "github.com/vkcom/tl/internal/tlcodegen/output/tl"
	}

	elements := strings.Split(opts.Go.TLPackageNameFull, "/")
	if len(elements) < 3 {
		return fmt.Errorf("full go package name must have 2 non-empty rightmost path elements, for example '.../output/tl")
	}
	opts.Go.TLPackageNameFull = strings.Join(elements[:len(elements)-1], "/")
	outdirElements := slices.Clone(elements[:len(elements)-1])
	gen.GlobalPackageName = elements[len(elements)-1]
	// gen.RootPackageName = elements[len(elements)-2] - seems we do not need it anywhere
	gen.FactoryPackageName = strings.Join(append(outdirElements, FactoryGoPackageName), "/")
	gen.MetaPackageName = strings.Join(append(outdirElements, MetaGoPackageName), "/")
	if gen.GlobalPackageName == "" || elements[len(elements)-2] == "" {
		return fmt.Errorf("full go package name must have 2 non-empty rightmost path elements, for example '.../output/tl")
	}
	if opts.Go.BasicPackageNameFull == "" {
		gen.BasicPackageRelativePath = BasicTLGoPackageName
		gen.BasicPackageNameFull = strings.Join(append(outdirElements, BasicTLGoPackageName), "/")
	} else {
		basicElements := strings.Split(opts.Go.BasicPackageNameFull, "/")
		if len(basicElements) < 2 || basicElements[len(basicElements)-1] != BasicTLGoPackageName {
			return fmt.Errorf("basictl go package name must end with '/%s'", BasicTLGoPackageName)
		}
		gen.BasicPackageNameFull = opts.Go.BasicPackageNameFull
		neqInd := 0
		for ; neqInd < len(outdirElements) && neqInd < len(basicElements); neqInd++ {
			if outdirElements[neqInd] != basicElements[neqInd] {
				break
			}
		}
		if neqInd >= 3 {
			// github.com / user / repo
			for i := neqInd; i != len(outdirElements); i++ {
				gen.BasicPackageRelativePath += "../"
			}
			for i := neqInd; i != len(basicElements); i++ {
				gen.BasicPackageRelativePath += basicElements[i] + "/"
			}
			log.Printf("basictl code will be updated in %q", gen.BasicPackageRelativePath)
		} else {
			log.Printf("basictl code will not be updated - in different repository")
		}
	}

	var outdir puregen.OutDir

	{
		filepathName := filepath.Join(ConstantsPackageName, ConstantsPackageName+".go") // TODO if contains GlobalPackgeName as prefix, there could be name collisions
		code := ""                                                                      // gen.generateConstants(HeaderComment, ConstantsPackageName)
		if err := outdir.AddCodeFile(filepathName, gen.CopyrightText+code); err != nil {
			return err
		}
		if gen.BasicPackageRelativePath != "" {
			// TODO if contains GlobalPackgeName as prefix, there could be name collisions
			filepathName := filepath.Join(gen.BasicPackageRelativePath, "basictl.go")
			code = basictl.BasicTLContent(HeaderComment, BasicTLGoPackageName)
			if err := outdir.AddCodeFile(filepathName, gen.CopyrightText+code); err != nil {
				return err
			}
			filepathName = filepath.Join(gen.BasicPackageRelativePath, "basictl2.go")
			code = basictl.BasicTL2Content(HeaderComment, BasicTLGoPackageName)
			if err := outdir.AddCodeFile(filepathName, gen.CopyrightText+code); err != nil {
				return err
			}
		} else if opts.Verbose {
			log.Printf("basictl code not written, expected to be available at %q", opts.Go.BasicPackageNameFull)
		}
		//directImports := &DirectImports{ns: map[*InternalNamespace]struct{}{}}
		//var sortedNames []string
		//_ = gen.generateFactory(sortedNames, directImports)
		//for im := range directImports.ns { // Imports of this file.
		//	sortedNames = append(sortedNames, im.SubPath)
		//}
		//slices.Sort(sortedNames)
		//if err := outdir.AddCodeFile(filepath.Join(FactoryGoPackageName, FactoryGoPackageName+goExt), gen.CopyrightText+gen.generateFactory(sortedNames, directImports)); err != nil {
		//	return err
		//}
		//if err := outdir.AddCodeFile(filepath.Join(FactoryGoPackageNameBytes, FactoryGoPackageNameBytes+goExt), gen.CopyrightText+gen.generateFactoryBytes(sortedNames, directImports)); err != nil {
		//	return err
		//}
		//if err := outdir.AddCodeFile(filepath.Join(MetaGoPackageName, MetaGoPackageName+goExt), gen.CopyrightText+gen.generateMeta(utils.AppVersion())); err != nil {
		//	return err
		//}
		filepathName = filepath.Join("internal", "a_tlgen_helpers_code.go") // TODO decollision
		code = fmt.Sprintf(InternalTLCodeHeader, HeaderComment, "internal") + InternalTLCodeBody
		if err := outdir.AddCodeFile(filepathName, gen.CopyrightText+code); err != nil {
			return err
		}
	}
	if opts.Verbose {
		log.Printf("formating generated code...")
	}
	if err = outdir.Write(opts, markerFile); err != nil {
		return err // Context is already in err
	}
	return nil
}
