{%- import "fmt" -%}

{%- func (gen *genGo) generateMeta(tlgenVersion string) -%}
{%s= HeaderComment %}
package {%s MetaGoPackageName %}

import (
    "fmt"

    {%q= gen.BasicPackageNameFull %}
    "{%s= gen.options.Go.TLPackageNameFull %}/internal"
)

func SchemaGenerator() string { return {%s= fmt.Sprintf("%#v", tlgenVersion) %} }
func SchemaURL() string { return {%s= fmt.Sprintf("%#v", gen.options.SchemaURL) %} }
func SchemaCommit() string { return {%s= fmt.Sprintf("%#v", gen.options.SchemaCommit) %} }
func SchemaTimestamp() uint32 { return {%v gen.options.SchemaTimestamp %} }

// We can create only types which have zero type arguments and zero nat arguments
type Object interface {
	TLName() string // returns type's TL name. For union, returns constructor name depending on actual union value
	TLTag() uint32  // returns type's TL tag. For union, returns constructor tag depending on actual union value
	String() string // returns type's representation for debugging (JSON for now)

	{%- if gen.options.GenerateRandomCode -%}
	FillRandom(rg *basictl.RandGenerator)
	{%- endif -%}
	Read(w []byte) ([]byte, error) // reads type's bare TL representation by consuming bytes from the start of w and returns remaining bytes, plus error
	ReadBoxed(w []byte) ([]byte, error) // same as Read, but reads/checks TLTag first (this method is general version of Write, use it only when you are working with interface)
	WriteGeneral(w []byte) ([]byte, error) // same as Write, but has common signature (with error) for all objects, so can be called through interface
	WriteBoxedGeneral(w []byte) ([]byte, error) // same as WriteBoxed, but has common signature (with error) for all objects, so can be called through interface

	MarshalJSON() ([]byte, error) // returns type's JSON representation, plus error
	UnmarshalJSON([]byte) error // reads type's JSON representation

    ReadJSON(legacyTypeNames bool, in *basictl.JsonLexer) error
    // like MarshalJSON, but appends to w and returns it
    // pass empty basictl.JSONWriteContext{} if you do not know which options you need
	WriteJSONGeneral(tctx *basictl.JSONWriteContext, w []byte) ([]byte, error)
    {%- if gen.options.GenerateTL2() -%}

    ReadTL2(r []byte, ctx *basictl.TL2ReadContext) ([]byte, error)
	WriteTL2(w []byte, ctx *basictl.TL2WriteContext) []byte
	{%- endif -%}
}

type Function interface {
	Object

	{%- if gen.options.GenerateRandomCode -%}
    FillRandomResult(rg *basictl.RandGenerator, w []byte) ([]byte, error)
    {%- endif -%}

    // tctx is for options controlling transcoding short-long version during Long ID and legacyTypeNames->newTypeNames transition
    // pass empty basictl.JSONWriteContext{} if you do not know which options you need
	ReadResultWriteResultJSON(tctx *basictl.JSONWriteContext, r []byte, w []byte) ([]byte, []byte, error) // combination of ReadResult(r) + WriteResultJSON(w). Returns new r, new w, plus error
	ReadResultJSONWriteResult(r []byte, w []byte) ([]byte, []byte, error) // combination of ReadResultJSON(r) + WriteResult(w). Returns new r, new w, plus error

    {%- if gen.options.GenerateTL2() -%}
    ReadResultWriteResultTL2(tctx *basictl.TL2WriteContext, r []byte, w []byte) (_ []byte, _ []byte, err error)
    ReadResultTL2WriteResult(tctx *basictl.TL2ReadContext, r []byte, w []byte) (_ []byte, _ []byte, err error)

    ReadResultTL2WriteResultJSON(tctx *basictl.TL2ReadContext, jctx *basictl.JSONWriteContext, r []byte, w []byte) (_ []byte, _ []byte, err error)
    ReadResultJSONWriteResultTL2(tctx *basictl.TL2WriteContext, r []byte, w []byte) (_ []byte, _ []byte, err error)
    {%- endif -%}
}

func GetAllTLItems() []TLItem {
	var allItems []TLItem
	for _, item := range itemsByName {
		if item != nil {
			allItems = append(allItems, *item)
		}
	}
	return allItems
}

// for quick one-liners
func GetTLName(tag uint32, notFoundName string) string {
	if item := FactoryItemByTLTag(tag); item != nil {
		return item.TLName()
	}
	return notFoundName
}


type TLItem struct {
    tag                uint32
    annotations        uint32
    tlName             string

    hasTL1             bool
    hasTL2             bool

    resultTypeContainsUnionTypes bool
    argumentsTypesContainUnionTypes bool

    // either createObject != nil or createFunction != nil for object/function respectively
    // also, createFunctionLong can be != nil if there is long adapter (legacy to be removed soon)
    // also, createObjectBytes, createFunctionBytes, createFunctionLongBytes
    // can be != nil independently, if factory_bytes is imported
    createFunction     func() Function
    createFunctionLong func() Function
    createObject       func() Object
    createFunctionBytes     func() Function
    createFunctionLongBytes func() Function
    createObjectBytes       func() Object
}

func (item TLItem) TLTag() uint32            { return item.tag }
func (item TLItem) TLName() string           { return item.tlName }
// true for TL1-originated types
func (item TLItem) HasTL1() bool              { return item.hasTL1 }
// true for TL2-originated types and for TL1-originated types if in TL2 generation whitelist
func (item TLItem) HasTL2() bool              { return item.hasTL2 }
func (item TLItem) CreateObject() Object     {
    if item.createFunction != nil {
        return item.createFunction()
    }
    return item.createObject()
}
// used in TL generator tests only, do not use in product code
func (item TLItem) CreateObjectBytes() Object {
    if item.createFunctionBytes != nil {
        return item.createFunctionBytes()
    }
    if item.createFunction != nil {
        return item.createFunction()
    }
    if item.createObjectBytes != nil {
        return item.createObjectBytes()
    }
    return item.createObject()
}

func (item TLItem) IsFunction() bool         { return item.createFunction != nil }
func (item TLItem) CreateFunction() Function { return item.createFunction() }
// used in TL generator tests only, do not use in product code
func (item TLItem) CreateFunctionBytes() Function {
    if item.createFunctionBytes != nil {
        return item.createFunctionBytes()
    }
    return item.createFunction()
}

func (item TLItem) HasUnionTypesInResult() bool { return item.resultTypeContainsUnionTypes }
func (item TLItem) HasUnionTypesInArguments() bool { return item.argumentsTypesContainUnionTypes }

// For transcoding short-long version during Long ID transition
func (item TLItem) HasFunctionLong() bool        { return item.createFunctionLong != nil }
func (item TLItem) CreateFunctionLong() Function { return item.createFunctionLong() }
// we simplify interface by commenting this method no one yet needs.
// hopefully it will be removed together with long adapters code
// func (item TLItem) CreateFunctionLongBytes() Function {
//     if item.createFunctionLongBytes != nil {
//         return item.createFunctionLongBytes()
//     }
//     return item.createFunctionLong()
// }

// Annotations
{%- for bit, name := range gen.kernel.AllAnnotations() -%}
{%- code
 goName := ToUpperFirst(name)
-%}
func (item TLItem) Annotation{%s= goName %}() bool { return item.annotations & {%s= fmt.Sprintf("%#x", 1 << bit) %} != 0 }
{%- endfor -%}

// TLItem serves as a single type for all TL1 enum values
func (item *TLItem) Reset()                         {}
{%- if gen.options.GenerateRandomCode -%}
	func (item *TLItem) FillRandom(rg *basictl.RandGenerator) {}
{%- endif -%}
func (item *TLItem) Read(w []byte) ([]byte, error)  { return w, nil }
func (item *TLItem) WriteGeneral(w []byte) ([]byte, error) { return w, nil }
func (item *TLItem) Write(w []byte) []byte { return w }
func (item *TLItem) ReadBoxed(w []byte) ([]byte, error) { return basictl.NatReadExactTag(w, item.tag) }
func (item *TLItem) WriteBoxedGeneral(w []byte) ([]byte, error) { return basictl.NatWrite(w, item.tag), nil }
func (item *TLItem) WriteBoxed(w []byte) []byte { return basictl.NatWrite(w, item.tag) }
func (item TLItem) String() string {
	return string(item.WriteJSON(nil))
}
func (item *TLItem) ReadJSON(legacyTypeNames bool, in *basictl.JsonLexer) error {
	in.Delim('{')
	if !in.Ok() {
		return in.Error()
	}
	for !in.IsDelim('}') {
		return internal.ErrorInvalidJSONExcessElement(item.tlName, in.UnsafeFieldName(true))
	}
	in.Delim('}')
	if !in.Ok() {
		return in.Error()
	}
	return nil
}

func (item *TLItem) WriteJSONGeneral(tctx *basictl.JSONWriteContext, w []byte) (_ []byte, err error) {
	return item.WriteJSON(w), nil
}
func (item *TLItem) WriteJSON(w []byte) []byte {
	w = append(w, '{')
	return append(w, '}')
}
func (item *TLItem) MarshalJSON() ([]byte, error) {
	return item.WriteJSON(nil), nil
}
func (item *TLItem) UnmarshalJSON(b []byte) error {
	if err := item.ReadJSON(true, &basictl.JsonLexer{Data: b}); err != nil {
		return internal.ErrorInvalidJSON(item.tlName, err.Error())
	}
	return nil
}
{%- if gen.options.GenerateTL2() -%}

func (item *TLItem) ReadTL2(r []byte, ctx *basictl.TL2ReadContext) ([]byte, error) {
    return r, nil
}

func (item *TLItem) WriteTL2(w []byte, ctx *basictl.TL2WriteContext) []byte {
    return w
}
{%- endif -%}
func FactoryItemByTLTag(tag uint32) *TLItem {
    return itemsByTag[tag]
}

func FactoryItemByTLName(name string) *TLItem {
    return itemsByName[name]
}

var itemsByTag = map[uint32]*TLItem {}

var itemsByName = map[string]*TLItem {}

// Do not call directly, called by factory init code
func SetGlobalFactoryCreateForFunction(name string, createFunction func() Function, createFunctionLong func() Function) {
    item := itemsByName[name]
    if item == nil || item.createFunction == nil { // only replace !nil createFunction
        panic(fmt.Sprintf("factory cannot find function %s to set", name))
    }
    item.createFunction = createFunction
    item.createFunctionLong = createFunctionLong
}

// Do not call directly, called by factory init code
func SetGlobalFactoryCreateForObject(name string, createObject func() Object) {
    item := itemsByName[name]
    if item == nil || item.createObject == nil { // only replace !nil createObject
        panic(fmt.Sprintf("factory cannot find object %s to set", name))
    }
    item.createObject = createObject
}

// Do not call directly, called by factory init code
func SetGlobalFactoryCreateForEnumElement(name string) {
    item := itemsByName[name]
    if item == nil || item.createObject == nil { // only replace !nil createObject
        panic(fmt.Sprintf("factory cannot find enum %s to set", name))
    }
    item.createObject = func() Object { return item }
}

// Do not call directly, called by factory init code
func SetGlobalFactoryCreateForFunctionBytes(name string, createFunctionBytes func() Function, createFunctionLongBytes func() Function) {
    item := itemsByName[name]
    if item == nil || item.createFunction == nil { // only replace !nil createFunction
        panic(fmt.Sprintf("factory cannot find function %s to set", name))
    }
    item.createFunctionBytes = createFunctionBytes
    item.createFunctionLongBytes = createFunctionLongBytes
}

// Do not call directly, called by factory init code
func SetGlobalFactoryCreateForObjectBytes(name string, createObjectBytes func() Object) {
    item := itemsByName[name]
    if item == nil || item.createObject == nil { // only replace !nil createObject
        panic(fmt.Sprintf("factory cannot find object %s to set", name))
    }
    item.createObjectBytes = createObjectBytes
}

func pleaseImportFactoryObject() Object {
       panic("factory functions are not linked to reduce code bloat, please import 'gen/factory' instead of 'gen/meta'.")
}

func pleaseImportFactoryFunction() Function {
       panic("factory functions are not linked to reduce code bloat, please import 'gen/factory' instead of 'gen/meta'.")
}

func fillObject(item *TLItem)  {
	itemsByName[item.tlName] = item
	if item.tag != 0 {
	    itemsByTag[item.tag] = item
	}
	item.createObject = pleaseImportFactoryObject
}

func fillFunction(item *TLItem)  {
	itemsByName[item.tlName] = item
	if item.tag != 0 {
	    itemsByTag[item.tag] = item
	}
	item.createFunction = pleaseImportFactoryFunction
}

{%- endfunc -%}

{%- func (gen *genGo) generateMetaInit(addHeader bool, forNamespace func(ns string)bool, hasTypes *bool) -%}
{%- if addHeader -%}
    {%s= HeaderComment %}
    package {%s MetaGoPackageName %}
{%- endif -%}

func init() {
{%- for _, wr := range gen.generatedTypesList -%}
    {%- if !forNamespace(wr.tlName.Namespace) -%}
        {%- continue -%}
    {%- endif -%}
    {%- if !wr.pureType.Common().IsTopLevel() -%}
        {%- continue -%}
    {%- endif -%}
    {%- code
        argumentsTypesContainUnionTypes := wr.DoArgumentsContainUnionTypes()
    -%}
    {%- if fun, ok := wr.trw.(*TypeRWStruct); ok -%}
        {%- code
            if hasTypes != nil { *hasTypes = true }
            resultTypeContainsUnionTypes := false
        -%}
        {%- if fun.ResultType != nil -%}
            {%- code
                resultTypeContainsUnionTypes = fun.wr.DoesReturnTypeContainUnionTypes()
            -%}
        fillFunction({%- else -%}fillObject({%- endif -%}
        &TLItem{tlName: "{%= wr.tlName.String() %}" {%- code -%}
            {%- if wr.tlTag != 0 -%}, tag: {%s= fmt.Sprintf("0x%08x", wr.tlTag) %}{%- endif -%}
            {%- if !wr.originateFromTL2 -%}, hasTL1:true{%- endif -%}
            {%- if wr.wantsTL2 -%}, hasTL2:true{%- endif -%}
            {%- if wr.AnnotationsMask() != 0 -%}, annotations: {%s= fmt.Sprintf("0x%x", wr.AnnotationsMask()) %}{%- endif -%}
            {%- if argumentsTypesContainUnionTypes -%}, argumentsTypesContainUnionTypes:true{%- endif -%}
            {%- if resultTypeContainsUnionTypes -%}, resultTypeContainsUnionTypes:true{%- endif -%}})
    {%- endif -%}
    {%- if union, ok := wr.trw.(*TypeRWUnion); ok && union.wr.wantsTL2 -%}
        {%- code
            if hasTypes != nil { *hasTypes = true }
            // unions are not top level types by TL1 rules, but we make them so by implementing Read/Write as ReadBoxed/WriteBoxed
        -%}
        fillObject(&TLItem{tlName: "{%= wr.tlName.String() %}" {%- code -%}
            {%- if wr.tlTag != 0 -%}, tag: {%s= fmt.Sprintf("0x%08x", wr.tlTag) %}{%- endif -%}
            {%- if !wr.originateFromTL2 -%}, hasTL1:true{%- endif -%}
            {%- if wr.wantsTL2 -%}, hasTL2:true{%- endif -%}
            {%- if wr.AnnotationsMask() != 0 -%}, annotations: {%s= fmt.Sprintf("0x%x", wr.AnnotationsMask()) %}{%- endif -%}
            {%- if argumentsTypesContainUnionTypes -%}, argumentsTypesContainUnionTypes:true{%- endif -%}})
    {%- endif -%}
{%- endfor -%}
}
{%- endfunc -%}
