{%- import "fmt" -%}
{%- import "strings" -%}

{%- func (maybe *TypeRWMaybe) GenerateCode(bytesVersion bool, directImports *DirectImports) -%}
    {%- code
        goName := addBytes(maybe.wr.goGlobalName, bytesVersion)
        tlName := maybe.wr.tlName.String()
        elementTypeString := maybe.element.t.TypeString2(bytesVersion, directImports, maybe.wr.ins, false, false)
        natArgsDecl := formatNatArgsDecl(maybe.wr.NatParams)
        natArgsCall := formatNatArgsDeclCall(maybe.wr.NatParams)
        emptyTag := fmt.Sprintf("%#x", maybe.emptyTag)
        okTag := fmt.Sprintf("%#x", maybe.okTag)
        writeElementNeedsError := maybe.element.t.hasErrorInWriteMethods
    -%}
type {%s= goName %} struct {
    Value {%s= elementTypeString %} // not deterministic if !Ok
    Ok    bool
}

func (item *{%s= goName %}) Reset() {
    item.Ok = false
}
    {%- if maybe.wr.gen.options.GenerateRandomCode -%}
func (item *{%s= goName %}) FillRandom(rg *basictl.RandGenerator{%s= natArgsDecl %}) {
    if basictl.RandomUint(rg) & 1 == 1 {
        item.Ok = true
        {%s= maybe.element.t.TypeRandomCode(bytesVersion, directImports, maybe.wr.ins, "item.Value", formatNatArgs(nil, maybe.element.natArgs), false) %}
    } else {
        item.Ok = false
    }
}
    {%- endif -%}
        {%- if maybe.wr.hasRepairMasks -%}
func (item {%s= goName %}) RepairMasksValue({%s= strings.TrimPrefix(natArgsDecl, ",") %}) {%s= goName %} {
    item.RepairMasks({%s= strings.TrimPrefix(natArgsCall, ",") %})
    return item
}
func (item *{%s= goName %}) RepairMasks({%s= strings.TrimPrefix(natArgsDecl, ",") %}) {
    {%s= maybe.element.t.TypeRepairMasksCode(bytesVersion, directImports, maybe.wr.ins, "item.Value", formatNatArgs(nil, maybe.element.natArgs), false) %}
}
        {%- endif -%}

func (item *{%s= goName %}) ReadBoxed(w []byte{%s= natArgsDecl %}) (_ []byte, err error) {
    {%- if maybe.wr.originateFromTL2 -%}
    return w, basictl.TL2Error("not implemented for tl2 type")
    {%- else -%}
    if w, err = basictl.ReadBool(w, &item.Ok, {%s= emptyTag %}, {%s= okTag %}); err != nil {
        return w, err
    }
    if item.Ok {
        {%s= maybe.element.t.TypeReadingCode(bytesVersion, directImports, maybe.wr.ins, "item.Value", maybe.element.Bare(), formatNatArgs(nil, maybe.element.natArgs), false, true) %}
    }
    return w, nil
    {%- endif -%}
}

func (item *{%s= goName %}) WriteBoxedGeneral(w []byte{%s= natArgsDecl %}) (_ []byte, err error) {
    {%- if maybe.wr.originateFromTL2 -%}
    return w, basictl.TL2Error("not implemented for tl2 type")
    {%- else -%}
    {%- if writeElementNeedsError -%}
    return item.WriteBoxed(w{%s= natArgsCall %})
    {%- else -%}
    return item.WriteBoxed(w{%s= natArgsCall %}), nil
    {%- endif -%}
    {%- endif -%}
}

{%- if !maybe.wr.originateFromTL2 -%}
func (item *{%s= goName %}) WriteBoxed(w []byte{%s= natArgsDecl %}) {%s= wrapWithError(writeElementNeedsError, "[]byte") %} {
    if item.Ok {
        w = basictl.NatWrite(w, {%s= okTag %})
        {%s= maybe.element.t.TypeWritingCode(bytesVersion, directImports, maybe.wr.ins, "item.Value", maybe.element.Bare(), formatNatArgs(nil, maybe.element.natArgs), false, true, writeElementNeedsError) %}
    }
    {%- if writeElementNeedsError -%}
    return basictl.NatWrite(w, {%s= emptyTag %}), nil
    {%- else -%}
    return basictl.NatWrite(w, {%s= emptyTag %})
    {%- endif -%}
}
{%- endif -%}

{%- if maybe.wr.gen.options.GenerateTL2 -%}
{%- if maybe.wr.wantsTL2 -%}
func (item *{%s= goName %}) CalculateLayout(sizes []int, optimizeEmpty bool) ([]int, int) {
    if !item.Ok {
        if optimizeEmpty {
            return sizes, 0
        }
        return sizes, 1
    }
    sizePosition := len(sizes)
    sizes = append(sizes, 0)

    currentSize := 1
    lastUsedByte := 0
    var sz int

    currentSize += basictl.TL2CalculateSize(1)
    lastUsedByte = currentSize

    {%s= maybe.element.t.CalculateLayoutCall(directImports, bytesVersion, "sizes", "item.Value", true, maybe.wr.ins, maybe.element.recursive) %}
        lastUsedByte = currentSize
    }

    if lastUsedByte < currentSize {
        currentSize = lastUsedByte
    }
    sizes[sizePosition] = currentSize
    currentSize += basictl.TL2CalculateSize(currentSize)
    {%s= maybe.wr.gen.InternalPrefix()%}Unused(sz)
    return sizes, currentSize
}

func (item *{%s= goName %}) InternalWriteTL2(w []byte, sizes []int, optimizeEmpty bool) ([]byte, []int, int) {
    if !item.Ok {
        if optimizeEmpty {
            return w, sizes, 0
        }
        w = append(w, 0)
        return w, sizes, 1
    }
    currentSize := sizes[0]
    sizes = sizes[1:]
    w = basictl.TL2WriteSize(w, currentSize)
    oldLen := len(w)
    var sz int
    var currentBlock byte
    currentBlockPosition := len(w)
    w = append(w, 0)

    w = basictl.TL2WriteSize(w, 1)
    currentBlock |= 1
    {%s= maybe.element.t.WriteTL2Call(directImports, bytesVersion, "sizes", "w", "item.Value", true, maybe.wr.ins, maybe.element.recursive) %}
        currentBlock |= 2
    }
    w[currentBlockPosition] = currentBlock
    if len(w) - oldLen != currentSize {
        panic("tl2: mismatch between calculate and write")
    }
    {%s= maybe.wr.gen.InternalPrefix()%}Unused(sz)
    return w, sizes, currentSize
}
{%- endif -%}

func (item *{%s= goName %}) InternalReadTL2(r []byte) (_ []byte, err error) {
{%- if !maybe.wr.wantsTL2 -%}
    return r, {%s= maybe.wr.gen.InternalPrefix()%}ErrorTL2SerializersNotGenerated({%q= tlName %})
{%- else -%}
    currentSize := 0
    if r, currentSize, err = basictl.TL2ParseSize(r); err != nil { return r, err }
    if currentSize == 0 {
        item.Reset()
        return r, nil
    }
   	if len(r) < currentSize {
		return r, basictl.TL2Error("not enough data: expected %d, got %d", currentSize, len(r))
	}
    currentR := r[:currentSize]
    r = r[currentSize:]

    var block byte
    if currentR, err = basictl.ByteReadTL2(currentR, &block); err != nil { return r, err }
    var index int
    if (block & 1) != 0 {
        if currentR, index, err = basictl.TL2ParseSize(currentR); err != nil { return r, err }
    }
    switch index {
    case 0:
        item.Ok = false
        return r, nil
    case 1:
        item.Ok = true
    default:
        return r, {%s= maybe.wr.gen.InternalPrefix()%}ErrorInvalidUnionIndex({%q= tlName %}, index)
    }

    if block & 2 != 0 {
        {%- if maybe.element.recursive -%}
        if item.Value == nil {
            var newValue {%s= maybe.element.t.TypeString2(bytesVersion, directImports, maybe.wr.ins, false, false) %}
            item.Value = &newValue
        }
        {%- endif -%}
        {%s= maybe.element.t.ReadTL2Call(directImports, bytesVersion, "currentR", "item.Value", false, maybe.wr.ins, maybe.element.recursive) %}
    } else {
        {%s= maybe.element.t.TypeResettingCode(bytesVersion, directImports, maybe.wr.ins, "item.Value", maybe.element.recursive) %}
    }
    return r, nil
{%- endif -%}
}

{%- endif -%}
{%- if maybe.wr.gen.options.GenerateLegacyJsonRead -%}
func (item *{%s= goName %}) ReadJSONLegacy(legacyTypeNames bool, j interface{}{%s= natArgsDecl %}) error {
  _ok, _jvalue, err := {%s= maybe.wr.gen.InternalPrefix()%}JsonReadMaybe({%q= tlName %}, j)
  if err != nil {
    return err
  }
  item.Ok = _ok
  if _ok {
    {%s= maybe.element.t.TypeJSONReadingCode(bytesVersion, directImports, maybe.wr.ins, "_jvalue", "item.Value", formatNatArgs(nil, maybe.element.natArgs), false, ) %}
  }
  return nil
}

{%- endif -%}
func (item *{%s= goName %}) ReadJSONGeneral(tctx *basictl.JSONReadContext, in *basictl.JsonLexer{%s= natArgsDecl %}) error {
  _ok, _jvalue, err := {%s= maybe.wr.gen.InternalPrefix()%}Json2ReadMaybe({%q= tlName %}, in)
  if err != nil {
    return err
  }
  item.Ok = _ok
  if _ok {
    var in2Pointer *basictl.JsonLexer
    if _jvalue != nil {
        in2 := basictl.JsonLexer{Data: _jvalue}
        in2Pointer = &in2
    }
    {%s= maybe.element.t.TypeJSON2ReadingCode(bytesVersion, directImports, maybe.wr.ins, "in2Pointer", "item.Value", formatNatArgs(nil, maybe.element.natArgs), false, ) %}
  }
  return nil
}

// This method is general version of WriteJSON, use it instead!
func (item *{%s= goName %}) WriteJSONGeneral(tctx *basictl.JSONWriteContext, w []byte{%s= natArgsDecl %}) (_ []byte, err error) {
    {%- if writeElementNeedsError -%}
    return item.WriteJSONOpt(tctx, w{%s= natArgsCall %})
    {%- else -%}
    return item.WriteJSONOpt(tctx, w{%s= natArgsCall %}), nil
    {%- endif -%}
}

func (item *{%s= goName %}) WriteJSON(w []byte{%s= natArgsDecl %}) {%s= wrapWithError(writeElementNeedsError, "[]byte") %} {
    tctx := basictl.JSONWriteContext{}
    return item.WriteJSONOpt(&tctx, w{%s= natArgsCall %})
}
func (item *{%s= goName %}) WriteJSONOpt(tctx *basictl.JSONWriteContext, w []byte{%s= natArgsDecl %}) {%s= wrapWithError(writeElementNeedsError, "[]byte") %} {
    if !item.Ok {
    {%- if writeElementNeedsError -%}
        return append(w, "{}"...), nil
    {%- else -%}
        return append(w, "{}"...)
    {%- endif -%}
    }
    w = append(w, `{"ok":true`...)
    {%- code
        emptyCondition := maybe.element.t.TypeJSONEmptyCondition(bytesVersion, "item.Value", false, )
    -%}
    {%- if emptyCondition != "" -%}
    if {%s= emptyCondition %} {
    {%- endif -%}
    w = append(w, `,"value":`...)
    {%s= maybe.element.t.TypeJSONWritingCode(bytesVersion, directImports, maybe.wr.ins, "item.Value", formatNatArgs(nil, maybe.element.natArgs), false, writeElementNeedsError) %}
    {%- if emptyCondition != "" -%}
    }
    {%- endif -%}
    {%- if writeElementNeedsError -%}
    return append(w, '}'), nil
    {%- else -%}
    return append(w, '}')
    {%- endif -%}
}
    {%- if len(maybe.wr.NatParams) == 0 -%}

func (item {%s= goName %}) String({%s= formatNatArgsDeclNoComma(maybe.wr.NatParams) %}) string {
    {%- if writeElementNeedsError -%}
    w, err := item.WriteJSON(nil{%s= natArgsCall %})
    if err != nil {
        return err.Error()
    }
    return string(w)
    {%- else -%}
    return string(item.WriteJSON(nil{%s= natArgsCall %}))
    {%- endif -%}
}

    {%- endif -%}

{%- endfunc -%}
