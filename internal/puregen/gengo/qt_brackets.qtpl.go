// Code generated by qtc from "qt_brackets.qtpl". DO NOT EDIT.
// See https://github.com/valyala/quicktemplate for details.

package gengo

import (
	qtio422016 "io"

	qt422016 "github.com/valyala/quicktemplate"
)

var (
	_ = qtio422016.Copy
	_ = qt422016.AcquireByteBuffer
)

func (tuple *TypeRWBrackets) StreamGenerateCode(qw422016 *qt422016.Writer, bytesVersion bool, directImports *DirectImports) {
	goName := addBytes(tuple.wr.goGlobalName, bytesVersion)
	natDecl := formatNatArgsDecl(tuple.wr.NatParams)
	natCall := formatNatArgsDeclCall(tuple.wr.NatParams)
	typeString := tuple.wr.TypeString2(bytesVersion, directImports, tuple.wr.ins, false, false)
	elementTypeString := tuple.element.t.TypeString2(bytesVersion, directImports, tuple.wr.ins, false, false)
	writeElementNeedsError := tuple.element.t.hasErrorInWriteMethods

	switch {
	case tuple.vectorLike:
		if tuple.wr.gen.options.GenerateRandomCode {
			qw422016.N().S(`func `)
			qw422016.N().S(goName)
			qw422016.N().S(`FillRandom(rg *basictl.RandGenerator, vec *`)
			qw422016.N().S(typeString)
			qw422016.N().S(` `)
			qw422016.N().S(natDecl)
			qw422016.N().S(`) {
    rg.IncreaseDepth()
    l := basictl.RandomSize(rg)
    *vec = make([]`)
			qw422016.N().S(elementTypeString)
			qw422016.N().S(`, l)
    for i := range *vec {
        `)
			qw422016.N().S(tuple.element.t.TypeRandomCode(bytesVersion, directImports, tuple.wr.ins, "(*vec)[i]", formatNatArgs(nil, tuple.element.natArgs), false))
			qw422016.N().S(`
    }
    rg.DecreaseDepth()
}
`)
		}
		qw422016.N().S(`func `)
		qw422016.N().S(goName)
		qw422016.N().S(`Read(w []byte, vec *`)
		qw422016.N().S(typeString)
		qw422016.N().S(` `)
		qw422016.N().S(natDecl)
		qw422016.N().S(`) (_ []byte, err error) {
`)
		if tuple.wr.originateFromTL2 {
			qw422016.N().S(`    return w, basictl.TL2Error("not implemented for tl2 type")
`)
		} else {
			qw422016.N().S(`    var l uint32
    if w, err = basictl.NatRead(w, &l); err != nil {
        return w, err
    }
`)
			if tuple.wr.gen.options.Go.UseCheckLengthSanity {
				qw422016.N().S(`    if err = basictl.CheckLengthSanity(w, l, 4); err != nil {
        return w, err
    }
`)
			}
			qw422016.N().S(`    if uint32(cap(*vec)) < l {
        *vec = make([]`)
			qw422016.N().S(elementTypeString)
			qw422016.N().S(`, l)
    } else {
        *vec = (*vec)[:l]
    }
    for i := range *vec {
        `)
			qw422016.N().S(tuple.element.t.TypeReadingCode(bytesVersion, directImports, tuple.wr.ins, "(*vec)[i]", tuple.element.Bare(), formatNatArgs(nil, tuple.element.natArgs), false, false))
			qw422016.N().S(`
    }
    return w, nil
`)
		}
		qw422016.N().S(`}

func `)
		qw422016.N().S(goName)
		qw422016.N().S(`Write(w []byte, vec `)
		qw422016.N().S(typeString)
		qw422016.N().S(` `)
		qw422016.N().S(natDecl)
		qw422016.N().S(`) `)
		qw422016.N().S(wrapWithError(writeElementNeedsError, "[]byte"))
		qw422016.N().S(` {
`)
		if tuple.wr.originateFromTL2 {
			if writeElementNeedsError {
				qw422016.N().S(`    return w, basictl.TL2Error("not implemented for tl2 type")
`)
			} else {
				qw422016.N().S(`    return w
`)
			}
		} else {
			qw422016.N().S(`    w = basictl.NatWrite(w, uint32(len(vec)))
    for _, elem := range vec {
        `)
			qw422016.N().S(tuple.element.t.TypeWritingCode(bytesVersion, directImports, tuple.wr.ins, "elem", tuple.element.Bare(), formatNatArgs(nil, tuple.element.natArgs), false, false, writeElementNeedsError))
			qw422016.N().S(`
    }
`)
			if writeElementNeedsError {
				qw422016.N().S(`    return w, nil
`)
			} else {
				qw422016.N().S(`    return w
`)
			}
		}
		qw422016.N().S(`}
`)
		if tuple.wr.gen.options.GenerateTL2 {
			qw422016.N().S(`
`)
			if tuple.wr.wantsTL2 {
				qw422016.N().S(`func `)
				qw422016.N().S(goName)
				qw422016.N().S(`CalculateLayout(sizes []int, optimizeEmpty bool, vec *`)
				qw422016.N().S(typeString)
				qw422016.N().S(`) ([]int, int) {
    if len(*vec) == 0 {
        if optimizeEmpty {
            return sizes, 0
        }
        return sizes, 1
    }
    sizePosition := len(sizes)
    sizes = append(sizes, 0)

    currentSize := 0
    var sz int

    currentSize += basictl.TL2CalculateSize(len(*vec))
`)
				if bb, ok := tuple.element.t.trw.(*TypeRWBool); ok && bb.isBit {
					qw422016.N().S(`        // special case for bool
        currentSize += (len(*vec) + 7) / 8
`)
				} else {
					qw422016.N().S(`        for i := 0; i < len(*vec); i++ {
            `)
					qw422016.N().S(tuple.element.t.CalculateLayoutCall(directImports, bytesVersion, "sizes", "(*vec)[i]", false, tuple.wr.ins, false))
					qw422016.N().S(`
        }
`)
				}
				qw422016.N().S(`    sizes[sizePosition] = currentSize
    currentSize += basictl.TL2CalculateSize(currentSize)
    `)
				qw422016.N().S(tuple.wr.gen.InternalPrefix())
				qw422016.N().S(`Unused(sz)
    return sizes, currentSize
}

func `)
				qw422016.N().S(goName)
				qw422016.N().S(`InternalWriteTL2(w []byte, sizes []int, optimizeEmpty bool, vec *`)
				qw422016.N().S(typeString)
				qw422016.N().S(`) ([]byte, []int, int) {
    if len(*vec) == 0 {
        if optimizeEmpty {
            return w, sizes, 0
        }
        w = append(w, 0)
        return w, sizes, 1
    }
    currentSize := sizes[0]
    sizes = sizes[1:]
    w = basictl.TL2WriteSize(w, currentSize)
    if currentSize == 0 {
        return w, sizes, 1
    }
    oldLen := len(w)
    w = basictl.TL2WriteSize(w, len(*vec))

`)
				if bb, ok := tuple.element.t.trw.(*TypeRWBool); ok && bb.isBit {
					qw422016.N().S(`        w = basictl.VectorBitContentWriteTL2(w, *vec)
`)
				} else {
					qw422016.N().S(`    var sz int
    for i := 0; i < len(*vec); i++ {
        `)
					qw422016.N().S(tuple.element.t.WriteTL2Call(directImports, bytesVersion, "sizes", "w", "(*vec)[i]", false, tuple.wr.ins, false))
					qw422016.N().S(`
    }
    `)
					qw422016.N().S(tuple.wr.gen.InternalPrefix())
					qw422016.N().S(`Unused(sz)
`)
				}
				qw422016.N().S(`    if len(w) - oldLen != currentSize {
        panic("tl2: mismatch between calculate and write")
    }
    return w, sizes, currentSize
}
`)
			}
			qw422016.N().S(`
func `)
			qw422016.N().S(goName)
			qw422016.N().S(`InternalReadTL2(r []byte, vec *`)
			qw422016.N().S(typeString)
			qw422016.N().S(`) (_ []byte, err error) {
`)
			if !tuple.wr.wantsTL2 {
				qw422016.N().S(`    return r, `)
				qw422016.N().S(tuple.wr.gen.InternalPrefix())
				qw422016.N().S(`ErrorTL2SerializersNotGenerated(`)
				qw422016.N().Q(typeString)
				qw422016.N().S(`)
`)
			} else {
				qw422016.N().S(`    currentSize := 0
    if r, currentSize, err = basictl.TL2ParseSize(r); err != nil { return r, err }
    if len(r) < currentSize {
        return r, basictl.TL2Error("not enough data: expected %d, got %d", currentSize, len(r))
    }

    currentR := r[:currentSize]
    r = r[currentSize:]

    elementCount := 0
    if currentSize != 0 {
        if currentR, elementCount, err = basictl.TL2ParseSize(currentR); err != nil { return r, err }
`)
				/* this check is slightly relaxed, because we cannot +7 without overflow check */

				qw422016.N().S(`        if elementCount`)
				if bb, ok := tuple.element.t.trw.(*TypeRWBool); ok && bb.isBit {
					qw422016.N().S(`/8`)
				}
				qw422016.N().S(`> len(currentR) {
            return r, basictl.TL2ElementCountError(elementCount, currentR)
        }
    }

    if cap(*vec) < elementCount {
        *vec = make([]`)
				qw422016.N().S(elementTypeString)
				qw422016.N().S(`, elementCount)
    }
    *vec = (*vec)[:elementCount]
`)
				if bb, ok := tuple.element.t.trw.(*TypeRWBool); ok && bb.isBit {
					qw422016.N().S(`        if currentR, err = basictl.VectorBitContentReadTL2(currentR, *vec); err != nil { return currentR, err }
`)
				} else {
					qw422016.N().S(`    for i := 0; i < elementCount; i++ {
        `)
					qw422016.N().S(tuple.element.t.ReadTL2Call(directImports, bytesVersion, "currentR", "(*vec)[i]", false, tuple.wr.ins, false))
					qw422016.N().S(`
    }
`)
				}
				qw422016.N().S(`    return r, nil
`)
			}
			qw422016.N().S(`}
`)
		}
		qw422016.N().S(`
`)
		if tuple.wr.gen.options.GenerateLegacyJsonRead {
			qw422016.N().S(`func `)
			qw422016.N().S(goName)
			qw422016.N().S(`ReadJSONLegacy(legacyTypeNames bool, j interface{}, vec *`)
			qw422016.N().S(typeString)
			qw422016.N().S(` `)
			qw422016.N().S(natDecl)
			qw422016.N().S(`) error {
    l, _arr, err := `)
			qw422016.N().S(tuple.wr.gen.InternalPrefix())
			qw422016.N().S(`JsonReadArray(`)
			qw422016.N().Q(typeString)
			qw422016.N().S(`, j)
    if err != nil {
        return err
    }
    if cap(*vec) < l {
        *vec = make([]`)
			qw422016.N().S(elementTypeString)
			qw422016.N().S(`, l)
    } else {
        *vec = (*vec)[:l]
    }
    for i := range *vec {
        `)
			qw422016.N().S(tuple.element.t.TypeJSONReadingCode(bytesVersion, directImports, tuple.wr.ins, "_arr[i]", "(*vec)[i]", formatNatArgs(nil, tuple.element.natArgs), false))
			qw422016.N().S(`
    }
    return nil
}

`)
		}
		qw422016.N().S(`func `)
		qw422016.N().S(goName)
		qw422016.N().S(`ReadJSONGeneral(tctx *basictl.JSONReadContext, in *basictl.JsonLexer, vec *`)
		qw422016.N().S(typeString)
		qw422016.N().S(` `)
		qw422016.N().S(natDecl)
		qw422016.N().S(`) error {
    *vec = (*vec)[:cap(*vec)]
    index := 0
    if in != nil {
        in.Delim('[')
        if !in.Ok() {
            return `)
		qw422016.N().S(tuple.wr.gen.InternalPrefix())
		qw422016.N().S(`ErrorInvalidJSON(`)
		qw422016.N().Q(typeString)
		qw422016.N().S(`, "expected json array")
        }
        for ;!in.IsDelim(']'); index++ {
            if len(*vec) <= index {
                var newValue `)
		qw422016.N().S(elementTypeString)
		qw422016.N().S(`
                *vec = append(*vec, newValue)
                *vec = (*vec)[:cap(*vec)]
            }
            `)
		qw422016.N().S(tuple.element.t.TypeJSON2ReadingCode(bytesVersion, directImports, tuple.wr.ins, "in", "(*vec)[index]", formatNatArgs(nil, tuple.element.natArgs), false))
		qw422016.N().S(`
             in.WantComma()
        }
        in.Delim(']')
        if !in.Ok() {
            return `)
		qw422016.N().S(tuple.wr.gen.InternalPrefix())
		qw422016.N().S(`ErrorInvalidJSON(`)
		qw422016.N().Q(typeString)
		qw422016.N().S(`, "expected json array's end")
        }
    }
    *vec = (*vec)[:index]
    return nil
}

func `)
		qw422016.N().S(goName)
		qw422016.N().S(`WriteJSON(w []byte, vec `)
		qw422016.N().S(typeString)
		qw422016.N().S(` `)
		qw422016.N().S(natDecl)
		qw422016.N().S(`) `)
		qw422016.N().S(wrapWithError(writeElementNeedsError, "[]byte"))
		qw422016.N().S(` {
    tctx := basictl.JSONWriteContext{}
    return `)
		qw422016.N().S(goName)
		qw422016.N().S(`WriteJSONOpt(&tctx, w, vec`)
		qw422016.N().S(natCall)
		qw422016.N().S(`)
}
func `)
		qw422016.N().S(goName)
		qw422016.N().S(`WriteJSONOpt(tctx *basictl.JSONWriteContext, w []byte, vec `)
		qw422016.N().S(typeString)
		qw422016.N().S(` `)
		qw422016.N().S(natDecl)
		qw422016.N().S(`) `)
		qw422016.N().S(wrapWithError(writeElementNeedsError, "[]byte"))
		qw422016.N().S(` {
    w = append(w, '[')
    for _, elem := range vec {
        w = basictl.JSONAddCommaIfNeeded(w)
        `)
		qw422016.N().S(tuple.element.t.TypeJSONWritingCode(bytesVersion, directImports, tuple.wr.ins, "elem", formatNatArgs(nil, tuple.element.natArgs), false, writeElementNeedsError))
		qw422016.N().S(`
    }
`)
		if writeElementNeedsError {
			qw422016.N().S(`    return append(w, ']'), nil
`)
		} else {
			qw422016.N().S(`    return append(w, ']')
`)
		}
		qw422016.N().S(`}

`)
	case tuple.dynamicSize:
		if tuple.wr.gen.options.GenerateRandomCode {
			qw422016.N().S(`func `)
			qw422016.N().S(goName)
			qw422016.N().S(`FillRandom(rg *basictl.RandGenerator, vec *`)
			qw422016.N().S(typeString)
			qw422016.N().S(` `)
			qw422016.N().S(natDecl)
			qw422016.N().S(`) {
    rg.IncreaseDepth()
    *vec = make([]`)
			qw422016.N().S(elementTypeString)
			qw422016.N().S(`, nat_n)
    for i := range *vec {
        `)
			qw422016.N().S(tuple.element.t.TypeRandomCode(bytesVersion, directImports, tuple.wr.ins, "(*vec)[i]", formatNatArgs(nil, tuple.element.natArgs), false))
			qw422016.N().S(`
    }
    rg.DecreaseDepth()
}
`)
		}
		qw422016.N().S(`
func `)
		qw422016.N().S(goName)
		qw422016.N().S(`Read(w []byte, vec *`)
		qw422016.N().S(typeString)
		qw422016.N().S(` `)
		qw422016.N().S(natDecl)
		qw422016.N().S(`) (_ []byte, err error) {
`)
		if tuple.wr.originateFromTL2 {
			qw422016.N().S(`    return w, basictl.TL2Error("not implemented for tl2 type")
`)
		} else {
			if tuple.wr.gen.options.Go.UseCheckLengthSanity {
				qw422016.N().S(`    if err = basictl.CheckLengthSanity(w, nat_n, 4); err != nil {
        return w, err
    }
`)
			}
			qw422016.N().S(`    if uint32(cap(*vec)) < nat_n {
        *vec = make([]`)
			qw422016.N().S(elementTypeString)
			qw422016.N().S(`, nat_n)
    } else {
        *vec = (*vec)[:nat_n]
    }
    for i := range *vec {
        `)
			qw422016.N().S(tuple.element.t.TypeReadingCode(bytesVersion, directImports, tuple.wr.ins, "(*vec)[i]", tuple.element.Bare(), formatNatArgs(nil, tuple.element.natArgs), false, false))
			qw422016.N().S(`
    }
    return w, nil
`)
		}
		qw422016.N().S(`}

func `)
		qw422016.N().S(goName)
		qw422016.N().S(`Write(w []byte, vec `)
		qw422016.N().S(typeString)
		qw422016.N().S(` `)
		qw422016.N().S(natDecl)
		qw422016.N().S(`) (_ []byte, err error) {
`)
		if tuple.wr.originateFromTL2 {
			if writeElementNeedsError {
				qw422016.N().S(`    return w, basictl.TL2Error("not implemented for tl2 type")
`)
			} else {
				qw422016.N().S(`    return w
`)
			}
		} else {
			qw422016.N().S(`    if uint32(len(vec)) != nat_n {
        return w, `)
			qw422016.N().S(tuple.wr.gen.InternalPrefix())
			qw422016.N().S(`ErrorWrongSequenceLength(`)
			qw422016.N().Q(typeString)
			qw422016.N().S(`, len(vec), nat_n)
    }
    for _, elem := range vec {
        `)
			qw422016.N().S(tuple.element.t.TypeWritingCode(bytesVersion, directImports, tuple.wr.ins, "elem", tuple.element.Bare(), formatNatArgs(nil, tuple.element.natArgs), false, false, writeElementNeedsError))
			qw422016.N().S(`
    }
    return w, nil
`)
		}
		qw422016.N().S(`}
`)
		if tuple.wr.gen.options.GenerateTL2 {
			qw422016.N().S(`
`)
			if tuple.wr.wantsTL2 {
				qw422016.N().S(`func `)
				qw422016.N().S(goName)
				qw422016.N().S(`CalculateLayout(sizes []int, optimizeEmpty bool, vec *`)
				qw422016.N().S(typeString)
				qw422016.N().S(`) ([]int, int) {
    if len(*vec) == 0 {
        if optimizeEmpty {
            return sizes, 0
        }
        return sizes, 1
    }
    sizePosition := len(sizes)
    sizes = append(sizes, 0)

    currentSize := 0
    var sz int

    currentSize += basictl.TL2CalculateSize(len(*vec))
`)
				if bb, ok := tuple.element.t.trw.(*TypeRWBool); ok && bb.isBit {
					qw422016.N().S(`        // special case for bool
        currentSize += (len(*vec) + 7) / 8
`)
				} else {
					qw422016.N().S(`        for i := 0; i < len(*vec); i++ {
            `)
					qw422016.N().S(tuple.element.t.CalculateLayoutCall(directImports, bytesVersion, "sizes", "(*vec)[i]", false, tuple.wr.ins, false))
					qw422016.N().S(`
        }
`)
				}
				qw422016.N().S(`    sizes[sizePosition] = currentSize
    currentSize += basictl.TL2CalculateSize(currentSize)
    `)
				qw422016.N().S(tuple.wr.gen.InternalPrefix())
				qw422016.N().S(`Unused(sz)
    return sizes, currentSize
}

func `)
				qw422016.N().S(goName)
				qw422016.N().S(`InternalWriteTL2(w []byte, sizes []int, optimizeEmpty bool, vec *`)
				qw422016.N().S(typeString)
				qw422016.N().S(`) ([]byte, []int, int) {
    if len(*vec) == 0 {
        if optimizeEmpty {
            return w, sizes, 0
        }
        w = append(w, 0)
        return w, sizes, 1
    }
    currentSize := sizes[0]
    sizes = sizes[1:]
    w = basictl.TL2WriteSize(w, currentSize)
    if currentSize == 0 {
        return w, sizes, 1
    }
    oldLen := len(w)
    w = basictl.TL2WriteSize(w, len(*vec))

`)
				if bb, ok := tuple.element.t.trw.(*TypeRWBool); ok && bb.isBit {
					qw422016.N().S(`        w = basictl.VectorBitContentWriteTL2(w, *vec)
`)
				} else {
					qw422016.N().S(`    var sz int
    for i := 0; i < len(*vec); i++ {
        `)
					qw422016.N().S(tuple.element.t.WriteTL2Call(directImports, bytesVersion, "sizes", "w", "(*vec)[i]", false, tuple.wr.ins, false))
					qw422016.N().S(`
    }
    `)
					qw422016.N().S(tuple.wr.gen.InternalPrefix())
					qw422016.N().S(`Unused(sz)
`)
				}
				qw422016.N().S(`    if len(w) - oldLen != currentSize {
        panic("tl2: mismatch between calculate and write")
    }
    return w, sizes, currentSize
}
`)
			}
			qw422016.N().S(`
func `)
			qw422016.N().S(goName)
			qw422016.N().S(`InternalReadTL2(r []byte, vec *`)
			qw422016.N().S(typeString)
			qw422016.N().S(`) (_ []byte, err error) {
`)
			if !tuple.wr.wantsTL2 {
				qw422016.N().S(`    return r, `)
				qw422016.N().S(tuple.wr.gen.InternalPrefix())
				qw422016.N().S(`ErrorTL2SerializersNotGenerated(`)
				qw422016.N().Q(typeString)
				qw422016.N().S(`)
`)
			} else {
				qw422016.N().S(`    currentSize := 0
    if r, currentSize, err = basictl.TL2ParseSize(r); err != nil { return r, err }
    if len(r) < currentSize {
        return r, basictl.TL2Error("not enough data: expected %d, got %d", currentSize, len(r))
    }

    currentR := r[:currentSize]
    r = r[currentSize:]

    elementCount := 0
    if currentSize != 0 {
        if currentR, elementCount, err = basictl.TL2ParseSize(currentR); err != nil { return r, err }
`)
				/* this check is slightly relaxed, because we cannot +7 without overflow check */

				qw422016.N().S(`        if elementCount`)
				if bb, ok := tuple.element.t.trw.(*TypeRWBool); ok && bb.isBit {
					qw422016.N().S(`/8`)
				}
				qw422016.N().S(`> len(currentR) {
            return r, basictl.TL2ElementCountError(elementCount, currentR)
        }
    }

    if cap(*vec) < elementCount {
        *vec = make([]`)
				qw422016.N().S(elementTypeString)
				qw422016.N().S(`, elementCount)
    }
    *vec = (*vec)[:elementCount]
`)
				if bb, ok := tuple.element.t.trw.(*TypeRWBool); ok && bb.isBit {
					qw422016.N().S(`        if currentR, err = basictl.VectorBitContentReadTL2(currentR, *vec); err != nil { return currentR, err }
`)
				} else {
					qw422016.N().S(`    for i := 0; i < elementCount; i++ {
        `)
					qw422016.N().S(tuple.element.t.ReadTL2Call(directImports, bytesVersion, "currentR", "(*vec)[i]", false, tuple.wr.ins, false))
					qw422016.N().S(`
    }
`)
				}
				qw422016.N().S(`    return r, nil
`)
			}
			qw422016.N().S(`}
`)
		}
		if tuple.wr.gen.options.GenerateLegacyJsonRead {
			qw422016.N().S(`func `)
			qw422016.N().S(goName)
			qw422016.N().S(`ReadJSONLegacy(legacyTypeNames bool, j interface{}, vec *`)
			qw422016.N().S(typeString)
			qw422016.N().S(` `)
			qw422016.N().S(natDecl)
			qw422016.N().S(`) error {
    _, _arr, err := `)
			qw422016.N().S(tuple.wr.gen.InternalPrefix())
			qw422016.N().S(`JsonReadArrayFixedSize(`)
			qw422016.N().Q(typeString)
			qw422016.N().S(`, j, nat_n)
    if err != nil {
        return err
    }
    if uint32(cap(*vec)) < nat_n {
        *vec = make([]`)
			qw422016.N().S(elementTypeString)
			qw422016.N().S(`, nat_n)
    } else {
        *vec = (*vec)[:nat_n]
    }
    for i := range *vec {
        `)
			qw422016.N().S(tuple.element.t.TypeJSONReadingCode(bytesVersion, directImports, tuple.wr.ins, "_arr[i]", "(*vec)[i]", formatNatArgs(nil, tuple.element.natArgs), false))
			qw422016.N().S(`
    }
    return nil
}

`)
		}
		qw422016.N().S(`func `)
		qw422016.N().S(goName)
		qw422016.N().S(`ReadJSONGeneral(tctx *basictl.JSONReadContext, in *basictl.JsonLexer, vec *`)
		qw422016.N().S(typeString)
		qw422016.N().S(` `)
		qw422016.N().S(natDecl)
		qw422016.N().S(`) error {
    isTL2 := tctx != nil && tctx.IsTL2
    if isTL2 {
        nat_n = uint32(len(*vec))
    }
    if uint32(cap(*vec)) < nat_n {
        *vec = make([]`)
		qw422016.N().S(elementTypeString)
		qw422016.N().S(`, nat_n)
    } else {
        *vec = (*vec)[:nat_n]
    }
    index := 0
    if in != nil {
        in.Delim('[')
        if !in.Ok() {
            return `)
		qw422016.N().S(tuple.wr.gen.InternalPrefix())
		qw422016.N().S(`ErrorInvalidJSON(`)
		qw422016.N().Q(typeString)
		qw422016.N().S(`, "expected json array")
        }
        for ;!in.IsDelim(']'); index++ {
            if nat_n <= uint32(index) {
                if isTL2 {
                    var newValue `)
		qw422016.N().S(elementTypeString)
		qw422016.N().S(`
                    *vec = append(*vec, newValue)
                    *vec = (*vec)[:cap(*vec)]
                    nat_n = uint32(len(*vec))
                } else {
                    return `)
		qw422016.N().S(tuple.wr.gen.InternalPrefix())
		qw422016.N().S(`ErrorInvalidJSON(`)
		qw422016.N().Q(typeString)
		qw422016.N().S(`, "array is longer than expected")
                }
            }
            `)
		qw422016.N().S(tuple.element.t.TypeJSON2ReadingCode(bytesVersion, directImports, tuple.wr.ins, "in", "(*vec)[index]", formatNatArgs(nil, tuple.element.natArgs), false))
		qw422016.N().S(`
            in.WantComma()
        }
        in.Delim(']')
        if !in.Ok() {
            return `)
		qw422016.N().S(tuple.wr.gen.InternalPrefix())
		qw422016.N().S(`ErrorInvalidJSON(`)
		qw422016.N().Q(typeString)
		qw422016.N().S(`, "expected json array's end")
        }
    }
    if isTL2 {
        *vec = (*vec)[:index]
    } else {
        if uint32(index) != nat_n {
            return `)
		qw422016.N().S(tuple.wr.gen.InternalPrefix())
		qw422016.N().S(`ErrorWrongSequenceLength(`)
		qw422016.N().Q(typeString)
		qw422016.N().S(`, index, nat_n)
        }
    }
    return nil
}

func `)
		qw422016.N().S(goName)
		qw422016.N().S(`WriteJSON(w []byte, vec `)
		qw422016.N().S(typeString)
		qw422016.N().S(` `)
		qw422016.N().S(natDecl)
		qw422016.N().S(`) (_ []byte, err error) {
    tctx := basictl.JSONWriteContext{}
    return `)
		qw422016.N().S(goName)
		qw422016.N().S(`WriteJSONOpt(&tctx, w, vec`)
		qw422016.N().S(natCall)
		qw422016.N().S(`)
}
func `)
		qw422016.N().S(goName)
		qw422016.N().S(`WriteJSONOpt(tctx *basictl.JSONWriteContext, w []byte, vec `)
		qw422016.N().S(typeString)
		qw422016.N().S(` `)
		qw422016.N().S(natDecl)
		qw422016.N().S(`) (_ []byte, err error) {
    if tctx != nil && tctx.IsTL2 {
        nat_n = uint32(len(vec))
    }
    if uint32(len(vec)) != nat_n {
        return w, `)
		qw422016.N().S(tuple.wr.gen.InternalPrefix())
		qw422016.N().S(`ErrorWrongSequenceLength(`)
		qw422016.N().Q(typeString)
		qw422016.N().S(`, len(vec), nat_n)
    }
    w = append(w, '[')
    for _, elem := range vec {
        w = basictl.JSONAddCommaIfNeeded(w)
        `)
		qw422016.N().S(tuple.element.t.TypeJSONWritingCode(bytesVersion, directImports, tuple.wr.ins, "elem", formatNatArgs(nil, tuple.element.natArgs), false, writeElementNeedsError))
		qw422016.N().S(`
    }
    return append(w, ']'), nil
}

`)
	default:
		qw422016.N().S(`func `)
		qw422016.N().S(goName)
		qw422016.N().S(`Reset(vec *`)
		qw422016.N().S(typeString)
		qw422016.N().S(`) {
    for i := range *vec {
            `)
		qw422016.N().S(tuple.element.t.TypeResettingCode(bytesVersion, directImports, tuple.wr.ins, "(*vec)[i]", false))
		qw422016.N().S(`
    }
}

`)
		if tuple.wr.gen.options.GenerateRandomCode {
			qw422016.N().S(`func `)
			qw422016.N().S(goName)
			qw422016.N().S(`FillRandom(rg *basictl.RandGenerator, vec *`)
			qw422016.N().S(typeString)
			qw422016.N().S(` `)
			qw422016.N().S(natDecl)
			qw422016.N().S(`) {
    rg.IncreaseDepth()
    for i := range *vec {
        `)
			qw422016.N().S(tuple.element.t.TypeRandomCode(bytesVersion, directImports, tuple.wr.ins, "(*vec)[i]", formatNatArgs(nil, tuple.element.natArgs), false))
			qw422016.N().S(`
    }
    rg.DecreaseDepth()
}
`)
		}
		qw422016.N().S(`
func `)
		qw422016.N().S(goName)
		qw422016.N().S(`Read(w []byte, vec *`)
		qw422016.N().S(typeString)
		qw422016.N().S(` `)
		qw422016.N().S(natDecl)
		qw422016.N().S(`) (_ []byte, err error) {
`)
		if tuple.wr.originateFromTL2 {
			qw422016.N().S(`    return w, basictl.TL2Error("not implemented for tl2 type")
`)
		} else {
			qw422016.N().S(`    for i := range *vec {
        `)
			qw422016.N().S(tuple.element.t.TypeReadingCode(bytesVersion, directImports, tuple.wr.ins, "(*vec)[i]", tuple.element.Bare(), formatNatArgs(nil, tuple.element.natArgs), false, false))
			qw422016.N().S(`
    }
    return w, nil
`)
		}
		qw422016.N().S(`}

func `)
		qw422016.N().S(goName)
		qw422016.N().S(`Write(w []byte, vec *`)
		qw422016.N().S(typeString)
		qw422016.N().S(` `)
		qw422016.N().S(natDecl)
		qw422016.N().S(`) `)
		qw422016.N().S(wrapWithError(writeElementNeedsError, "[]byte"))
		qw422016.N().S(` {
`)
		if tuple.wr.originateFromTL2 {
			if writeElementNeedsError {
				qw422016.N().S(`    return w, basictl.TL2Error("not implemented for tl2 type")
`)
			} else {
				qw422016.N().S(`    return w
`)
			}
		} else {
			qw422016.N().S(`    for _, elem := range *vec {
        `)
			qw422016.N().S(tuple.element.t.TypeWritingCode(bytesVersion, directImports, tuple.wr.ins, "elem", tuple.element.Bare(), formatNatArgs(nil, tuple.element.natArgs), false, false, writeElementNeedsError))
			qw422016.N().S(`
    }
`)
			if writeElementNeedsError {
				qw422016.N().S(`    return w, nil
`)
			} else {
				qw422016.N().S(`    return w
`)
			}
		}
		qw422016.N().S(`}
`)
		if tuple.wr.gen.options.GenerateTL2 {
			qw422016.N().S(`
`)
			if tuple.wr.wantsTL2 {
				qw422016.N().S(`func `)
				qw422016.N().S(goName)
				qw422016.N().S(`CalculateLayout(sizes []int, optimizeEmpty bool, vec *`)
				qw422016.N().S(typeString)
				qw422016.N().S(`) ([]int, int) {
    if `)
				qw422016.N().V(tuple.size)
				qw422016.N().S(` == 0 {
        if optimizeEmpty {
            return sizes, 0
        }
        return sizes, 1
    }
    sizePosition := len(sizes)
    sizes = append(sizes, 0)

    currentSize := 0
    var sz int

    currentSize += basictl.TL2CalculateSize(len(*vec))

`)
				if bb, ok := tuple.element.t.trw.(*TypeRWBool); ok && bb.isBit {
					qw422016.N().S(`        // special case for bool
        currentSize += (`)
					qw422016.N().V(tuple.size)
					qw422016.N().S(` + 7) / 8
`)
				} else {
					qw422016.N().S(`        for i := 0; i < `)
					qw422016.N().V(tuple.size)
					qw422016.N().S(`; i++ {
            `)
					qw422016.N().S(tuple.element.t.CalculateLayoutCall(directImports, bytesVersion, "sizes", "(*vec)[i]", false, tuple.wr.ins, false))
					qw422016.N().S(`
        }
`)
				}
				qw422016.N().S(`    sizes[sizePosition] = currentSize
    currentSize += basictl.TL2CalculateSize(currentSize)
    `)
				qw422016.N().S(tuple.wr.gen.InternalPrefix())
				qw422016.N().S(`Unused(sz)
    return sizes, currentSize
}

func `)
				qw422016.N().S(goName)
				qw422016.N().S(`InternalWriteTL2(w []byte, sizes []int, optimizeEmpty bool, vec *`)
				qw422016.N().S(typeString)
				qw422016.N().S(`) ([]byte, []int, int) {
    if `)
				qw422016.N().V(tuple.size)
				qw422016.N().S(` == 0 {
        if optimizeEmpty {
            return w, sizes, 0
        }
        w = append(w, 0)
        return w, sizes, 1
    }
    currentSize := sizes[0]
    sizes = sizes[1:]
    w = basictl.TL2WriteSize(w, currentSize)
    if currentSize == 0 {
        return w, sizes, 1
    }
    oldLen := len(w)
    w = basictl.TL2WriteSize(w, len(*vec))

`)
				if bb, ok := tuple.element.t.trw.(*TypeRWBool); ok && bb.isBit {
					qw422016.N().S(`        w = basictl.VectorBitContentWriteTL2(w, (*vec)[:])
`)
				} else {
					qw422016.N().S(`    var sz int
    for i := 0; i < `)
					qw422016.N().V(tuple.size)
					qw422016.N().S(`; i++ {
        `)
					qw422016.N().S(tuple.element.t.WriteTL2Call(directImports, bytesVersion, "sizes", "w", "(*vec)[i]", false, tuple.wr.ins, false))
					qw422016.N().S(`
    }
    `)
					qw422016.N().S(tuple.wr.gen.InternalPrefix())
					qw422016.N().S(`Unused(sz)
`)
				}
				qw422016.N().S(`    if len(w) - oldLen != currentSize {
        panic("tl2: mismatch between calculate and write")
    }
    return w, sizes, currentSize
}
`)
			}
			qw422016.N().S(`
func `)
			qw422016.N().S(goName)
			qw422016.N().S(`InternalReadTL2(r []byte, vec *`)
			qw422016.N().S(typeString)
			qw422016.N().S(`) (_ []byte, err error) {
`)
			if !tuple.wr.wantsTL2 {
				qw422016.N().S(`    return r, `)
				qw422016.N().S(tuple.wr.gen.InternalPrefix())
				qw422016.N().S(`ErrorTL2SerializersNotGenerated(`)
				qw422016.N().Q(typeString)
				qw422016.N().S(`)
`)
			} else {
				qw422016.N().S(`    currentSize := 0
    if r, currentSize, err = basictl.TL2ParseSize(r); err != nil { return r, err }
    if len(r) < currentSize {
        return r, basictl.TL2Error("not enough data: expected %d, got %d", currentSize, len(r))
    }

    currentR := r[:currentSize]
    r = r[currentSize:]

    elementCount := 0
    if currentSize != 0 {
        if currentR, elementCount, err = basictl.TL2ParseSize(currentR); err != nil { return r, err }
`)
				/* we have no easy defense against amplification attack here (multiply by tuple.size)  */

				qw422016.N().S(`    }

    lastIndex := min(elementCount, `)
				qw422016.N().V(tuple.size)
				qw422016.N().S(`)
`)
				if bb, ok := tuple.element.t.trw.(*TypeRWBool); ok && bb.isBit {
					qw422016.N().S(`        if currentR, err = basictl.VectorBitContentReadTL2(currentR, (*vec)[:lastIndex]); err != nil { return currentR, err }
`)
					/* reset elements if received less elements */

					qw422016.N().S(`        clear((*vec)[lastIndex:])
`)
				} else {
					qw422016.N().S(`        for i := 0; i < lastIndex; i++ {
            `)
					qw422016.N().S(tuple.element.t.ReadTL2Call(directImports, bytesVersion, "currentR", "(*vec)[i]", false, tuple.wr.ins, false))
					qw422016.N().S(`
        }
`)
					/* reset elements if received less elements */

					qw422016.N().S(`        for i := lastIndex; i < `)
					qw422016.N().V(tuple.size)
					qw422016.N().S(`; i++ {
            `)
					qw422016.N().S(tuple.element.t.TypeResettingCode(bytesVersion, directImports, tuple.wr.ins, "(*vec)[i]", false))
					qw422016.N().S(`
        }
`)
				}
				qw422016.N().S(`
    return r, nil
`)
			}
			qw422016.N().S(`}
`)
		}
		qw422016.N().S(`
`)
		if tuple.wr.gen.options.GenerateLegacyJsonRead {
			qw422016.N().S(`func `)
			qw422016.N().S(goName)
			qw422016.N().S(`ReadJSONLegacy(legacyTypeNames bool, j interface{}, vec *`)
			qw422016.N().S(typeString)
			qw422016.N().S(` `)
			qw422016.N().S(natDecl)
			qw422016.N().S(`) error {
    _, _arr, err := `)
			qw422016.N().S(tuple.wr.gen.InternalPrefix())
			qw422016.N().S(`JsonReadArrayFixedSize(`)
			qw422016.N().Q(typeString)
			qw422016.N().S(`, j, `)
			qw422016.E().V(tuple.size)
			qw422016.N().S(`)
    if err != nil {
        return err
    }
    for i := range *vec {
        `)
			qw422016.N().S(tuple.element.t.TypeJSONReadingCode(bytesVersion, directImports, tuple.wr.ins, "_arr[i]", "(*vec)[i]", formatNatArgs(nil, tuple.element.natArgs), false))
			qw422016.N().S(`
    }
    return nil
}

`)
		}
		qw422016.N().S(`func `)
		qw422016.N().S(goName)
		qw422016.N().S(`ReadJSONGeneral(tctx *basictl.JSONReadContext, in *basictl.JsonLexer, vec *`)
		qw422016.N().S(typeString)
		qw422016.N().S(` `)
		qw422016.N().S(natDecl)
		qw422016.N().S(`) error {
    index := 0
    if in != nil {
        in.Delim('[')
        if !in.Ok() {
            return `)
		qw422016.N().S(tuple.wr.gen.InternalPrefix())
		qw422016.N().S(`ErrorInvalidJSON(`)
		qw422016.N().Q(typeString)
		qw422016.N().S(`, "expected json array")
        }
        for ;!in.IsDelim(']'); index++ {
            if index == `)
		qw422016.E().V(tuple.size)
		qw422016.N().S(` {
                return `)
		qw422016.N().S(tuple.wr.gen.InternalPrefix())
		qw422016.N().S(`ErrorWrongSequenceLength(`)
		qw422016.N().Q(typeString)
		qw422016.N().S(`, index + 1, `)
		qw422016.E().V(tuple.size)
		qw422016.N().S(`)
            }
            `)
		qw422016.N().S(tuple.element.t.TypeJSON2ReadingCode(bytesVersion, directImports, tuple.wr.ins, "in", "(*vec)[index]", formatNatArgs(nil, tuple.element.natArgs), false))
		qw422016.N().S(`
            in.WantComma()
        }
        in.Delim(']')
        if !in.Ok() {
            return `)
		qw422016.N().S(tuple.wr.gen.InternalPrefix())
		qw422016.N().S(`ErrorInvalidJSON(`)
		qw422016.N().Q(typeString)
		qw422016.N().S(`, "expected json array's end")
        }
    }
    if index != `)
		qw422016.E().V(tuple.size)
		qw422016.N().S(` {
        return `)
		qw422016.N().S(tuple.wr.gen.InternalPrefix())
		qw422016.N().S(`ErrorWrongSequenceLength(`)
		qw422016.N().Q(typeString)
		qw422016.N().S(`, index + 1, `)
		qw422016.E().V(tuple.size)
		qw422016.N().S(`)
    }
    return nil
}

func `)
		qw422016.N().S(goName)
		qw422016.N().S(`WriteJSON(w []byte, vec *`)
		qw422016.N().S(typeString)
		qw422016.N().S(` `)
		qw422016.N().S(natDecl)
		qw422016.N().S(`) `)
		qw422016.N().S(wrapWithError(writeElementNeedsError, "[]byte"))
		qw422016.N().S(` {
    tctx := basictl.JSONWriteContext{}
    return `)
		qw422016.N().S(goName)
		qw422016.N().S(`WriteJSONOpt(&tctx, w, vec`)
		qw422016.N().S(natCall)
		qw422016.N().S(`)
}
func `)
		qw422016.N().S(goName)
		qw422016.N().S(`WriteJSONOpt(tctx *basictl.JSONWriteContext, w []byte, vec *`)
		qw422016.N().S(typeString)
		qw422016.N().S(` `)
		qw422016.N().S(natDecl)
		qw422016.N().S(`) `)
		qw422016.N().S(wrapWithError(writeElementNeedsError, "[]byte"))
		qw422016.N().S(` {
    w = append(w, '[')
    for _, elem := range *vec {
        w = basictl.JSONAddCommaIfNeeded(w)
        `)
		qw422016.N().S(tuple.element.t.TypeJSONWritingCode(bytesVersion, directImports, tuple.wr.ins, "elem", formatNatArgs(nil, tuple.element.natArgs), false, writeElementNeedsError))
		qw422016.N().S(`
    }
`)
		if writeElementNeedsError {
			qw422016.N().S(`    return append(w, ']'), nil
`)
		} else {
			qw422016.N().S(`    return append(w, ']')
`)
		}
		qw422016.N().S(`}
`)
	}
}

func (tuple *TypeRWBrackets) WriteGenerateCode(qq422016 qtio422016.Writer, bytesVersion bool, directImports *DirectImports) {
	qw422016 := qt422016.AcquireWriter(qq422016)
	tuple.StreamGenerateCode(qw422016, bytesVersion, directImports)
	qt422016.ReleaseWriter(qw422016)
}

func (tuple *TypeRWBrackets) GenerateCode(bytesVersion bool, directImports *DirectImports) string {
	qb422016 := qt422016.AcquireByteBuffer()
	tuple.WriteGenerateCode(qb422016, bytesVersion, directImports)
	qs422016 := string(qb422016.B)
	qt422016.ReleaseByteBuffer(qb422016)
	return qs422016
}
