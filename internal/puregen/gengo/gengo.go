// Copyright 2025 V Kontakte LLC
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package gengo

import (
	"crypto/sha1"
	"encoding/hex"
	"fmt"
	"log"
	"path/filepath"
	"slices"
	"strings"

	"github.com/vkcom/tl/internal/pure"
	"github.com/vkcom/tl/internal/puregen"
	"github.com/vkcom/tl/internal/utils"
	"github.com/vkcom/tl/pkg/basictl"
)

const markerFile = "tlgen2_version.txt"

const BasicTLGoPackageName = "basictl" // does not contain tl prefix
const FactoryGoPackageName = "factory" // does not contain tl prefix
const MetaGoPackageName = "meta"       // does not contain tl prefix
const ConstantsPackageName = "constants"
const HeaderComment = "// Code generated by vktl/cmd/tlgen2; DO NOT EDIT."

type genGo struct {
	kernel  *pure.Kernel
	options *puregen.Options

	rawHandlerWhileList pure.Whitelist

	BasicPackageNameFull     string // basic types are in separate namespace to minimize conflicts
	BasicPackageRelativePath string // if we cannot determine relative path, will not be written
	GlobalPackageName        string // we generate all go types in this package, because we need circular dependencies
	FactoryPackageName       string
	MetaPackageName          string

	generatedTypes     map[string]*TypeRWWrapper
	generatedTypesList []*TypeRWWrapper // we need more deterministic order than sort predicate can establish

	globalDec  Deconflicter
	Namespaces map[string]*Namespace // Handlers Code is inside
}

func Generate(kernel *pure.Kernel, options *puregen.Options) error {
	gen := genGo{
		kernel:         kernel,
		options:        options,
		Namespaces:     map[string]*Namespace{},
		generatedTypes: map[string]*TypeRWWrapper{},
	}
	if err := gen.prepareOptions(); err != nil {
		return err
	}
	if err := gen.compile(); err != nil {
		return err
	}
	if err := gen.generateCodeGolang(); err != nil {
		return err
	}
	return nil
}

func (gen *genGo) prepareOptions() (err error) {
	opts := gen.options

	if opts.GenerateRPCCode && opts.Go.BasicRPCPath == "" {
		return fmt.Errorf("--basicRPCPath must be specified if --generateRPCCode is set")
	}
	opts.Go.TLPackageNameFull = strings.TrimSpace(opts.Go.TLPackageNameFull)
	opts.Go.TLPackageNameFull = strings.TrimSuffix(opts.Go.TLPackageNameFull, "/")
	if opts.Go.TLPackageNameFull == "" { // for testing, empty path should be prohibited in main argv parsing
		opts.Go.TLPackageNameFull = "github.com/vkcom/tl/internal/tlcodegen/output/tl"
	}

	elements := strings.Split(opts.Go.TLPackageNameFull, "/")
	if len(elements) < 3 {
		return fmt.Errorf("full go package name must have 2 non-empty rightmost path elements, for example '.../output/tl")
	}
	opts.Go.TLPackageNameFull = strings.Join(elements[:len(elements)-1], "/")
	outdirElements := slices.Clone(elements[:len(elements)-1])
	gen.GlobalPackageName = elements[len(elements)-1]
	// gen.RootPackageName = elements[len(elements)-2] - seems we do not need it anywhere
	gen.FactoryPackageName = strings.Join(append(outdirElements, FactoryGoPackageName), "/")
	gen.MetaPackageName = strings.Join(append(outdirElements, MetaGoPackageName), "/")
	if gen.GlobalPackageName == "" || elements[len(elements)-2] == "" {
		return fmt.Errorf("full go package name must have 2 non-empty rightmost path elements, for example '.../output/tl")
	}
	if opts.Go.BasicPackageNameFull == "" {
		gen.BasicPackageRelativePath = BasicTLGoPackageName
		gen.BasicPackageNameFull = strings.Join(append(outdirElements, BasicTLGoPackageName), "/")
	} else {
		basicElements := strings.Split(opts.Go.BasicPackageNameFull, "/")
		if len(basicElements) < 2 || basicElements[len(basicElements)-1] != BasicTLGoPackageName {
			return fmt.Errorf("basictl go package name must end with '/%s'", BasicTLGoPackageName)
		}
		gen.BasicPackageNameFull = opts.Go.BasicPackageNameFull
		neqInd := 0
		for ; neqInd < len(outdirElements) && neqInd < len(basicElements); neqInd++ {
			if outdirElements[neqInd] != basicElements[neqInd] {
				break
			}
		}
		if neqInd >= 3 {
			// github.com / user / repo
			for i := neqInd; i != len(outdirElements); i++ {
				gen.BasicPackageRelativePath += "../"
			}
			for i := neqInd; i != len(basicElements); i++ {
				gen.BasicPackageRelativePath += basicElements[i] + "/"
			}
			log.Printf("basictl code will be updated in %q", gen.BasicPackageRelativePath)
		} else {
			log.Printf("basictl code will not be updated - in different repository")
		}
	}
	return nil
}

func (gen *genGo) generateCodeGolang() error {
	sortedTypes := gen.generatedTypesList
	if !gen.options.Go.SplitInternal {
		globalIns := &InternalNamespace{DebugID: 1, Name: "internal", SubPath: "internal", Namespaces: map[string]struct{}{}, DirectImports: &DirectImports{ns: map[*InternalNamespace]struct{}{}}}
		for _, v := range sortedTypes { // start with each type in its own internal namespace
			if _, ok := v.trw.(*TypeRWPrimitive); ok {
				continue // leave namespace nil
			}
			globalIns.Types = append(globalIns.Types, v)
			globalIns.Namespaces[v.Namespace()] = struct{}{}
			v.ins = globalIns
		}
	} else {
		var internalNamespaces []*InternalNamespace
		printSortedNamespaces := func() {
			// fmt.Printf("----sortedTypes----\n")
			// for _, ins := range internalNamespaces {
			//	fmt.Printf("recursive import namespace %s", ins)
			// }
		}
		nextDebugID := 0
		for _, v := range sortedTypes { // start with each type in its own internal namespace
			if _, ok := v.trw.(*TypeRWPrimitive); ok {
				continue // leave namespace nil
			}
			nextDebugID++
			e := &InternalNamespace{DebugID: nextDebugID, Types: []*TypeRWWrapper{v}, Namespaces: map[string]struct{}{}, DirectImports: &DirectImports{ns: map[*InternalNamespace]struct{}{}}}
			e.Namespaces[v.Namespace()] = struct{}{}
			v.ins = e
			internalNamespaces = append(internalNamespaces, e)
		}
		// we start with each type in its own internal namespace
		// we then generate code to assemble information on which is imported by which
		for _, v := range sortedTypes {
			if v.ins == nil {
				continue
			}
			_ = v.trw.GenerateCode(false, v.ins.DirectImports)
			if v.wantsBytesVersion && v.hasBytesVersion {
				_ = v.trw.GenerateCode(true, v.ins.DirectImports)
			}
		}
		printSortedNamespaces()
		// now := time.Now()
		recursiveImports := map[*InternalNamespace][]*InternalNamespace{}
		for i := 0; i < len(internalNamespaces); {
			from := internalNamespaces[i]
			from.FindRecursiveImports(recursiveImports, nil)
			if importMe, ok := recursiveImports[from]; ok && len(importMe) != 0 {
				into := importMe[0]
				// if options.Verbose {
				// log.Printf("----merging cycle namespace %sinto  %s (total %d)", from, into, len(internalNamespaces))
				// }
				into.mergeFrom(from, internalNamespaces)
				copy(internalNamespaces[i:], internalNamespaces[i+1:])
				internalNamespaces = internalNamespaces[:len(internalNamespaces)-1]
				// if options.Verbose {
				// log.Printf("result %s", into)
				// }
				continue
			}
			i++
		}
		for _, ins := range internalNamespaces {
			if len(ins.Types) == 1 {
				t := ins.Types[0]
				ins.Name = "tl" + t.goGlobalName
				ins.SubPath = "internal/tl" + t.Namespace() + "/" + ins.Name
				continue
			}
			var typesWithoutUnionElements []*TypeRWWrapper
			for _, t := range ins.Types {
				if t.unionParent == nil {
					typesWithoutUnionElements = append(typesWithoutUnionElements, t)
				}
			}
			if len(typesWithoutUnionElements) == 1 {
				t := typesWithoutUnionElements[0]
				ins.Name = "tl" + t.goGlobalName
				ins.SubPath = "internal/tl" + t.Namespace() + "/" + ins.Name
				continue
			}
			sha := sha1.Sum([]byte(strings.Join(ins.sortedElements(), ":")))
			ins.Name = "cycle_" + hex.EncodeToString(sha[:16])
			ins.SubPath = "internal/" + ins.Name
		}
	}
	typesCounter := 0
	typesCounterBytes := 0

	var outdir puregen.OutDir

	internalFiles := map[InsFile][]*TypeRWWrapper{}
	for _, typeRw := range gen.generatedTypesList {
		if typeRw.ins == nil {
			continue
		}
		ff := InsFile{ins: typeRw.ins, fileName: typeRw.FileName()}
		internalFiles[ff] = append(internalFiles[ff], typeRw)
	}
	var s strings.Builder
	for ff, types := range internalFiles {
		directImports := &DirectImports{ns: map[*InternalNamespace]struct{}{}}
		for _, typeRw := range types {
			_ = typeRw.trw.GenerateCode(false, directImports)
			if typeRw.wantsBytesVersion && typeRw.hasBytesVersion {
				_ = typeRw.trw.GenerateCode(true, directImports)
			}
		}
		s.WriteString(fmt.Sprintf(`%s
package %s 
import (
`,
			HeaderComment, ff.ins.Name))
		if directImports.importSort {
			s.WriteString("\"sort\"\n\n")
		}
		s.WriteString(fmt.Sprintf("\"%s\"\n", gen.BasicPackageNameFull))
		if gen.options.Go.SplitInternal {
			s.WriteString(fmt.Sprintf("    \"%s/%s\"\n", gen.options.Go.TLPackageNameFull, "internal"))
		}
		var sortedNames []string
		for im := range directImports.ns { // Imports of this file.
			if im != ff.ins {
				sortedNames = append(sortedNames, im.SubPath)
			}
		}
		slices.Sort(sortedNames)
		for _, n := range sortedNames {
			s.WriteString(fmt.Sprintf("    \"%s/%s\"\n", gen.options.Go.TLPackageNameFull, n))
		}
		s.WriteString(`)

var _ = basictl.NatWrite
`)
		if gen.options.Go.SplitInternal {
			s.WriteString("var _ = internal.ErrorInvalidEnumTag\n")
		}
		for _, typeRw := range types {
			typesCounter++
			s.WriteString("\n")
			s.WriteString(typeRw.trw.GenerateCode(false, directImports))
			if typeRw.wantsBytesVersion && typeRw.hasBytesVersion {
				typesCounterBytes++
				s.WriteString("\n")
				s.WriteString(typeRw.trw.GenerateCode(true, directImports))
			}
		}
		filepathName := filepath.Join(ff.ins.SubPath, ff.fileName+".go")
		if err := outdir.AddCodeFile(filepathName, gen.options.CopyrightText+s.String()); err != nil {
			return err
		}
		s.Reset()
	}
	if gen.options.Verbose {
		log.Printf("generation of serialization code finished, %d types generated", typesCounter)
		if typesCounterBytes != 0 {
			log.Printf("    also generated byte-optimized versions of %d types", typesCounterBytes)
		}
	}
	for name, namespace := range gen.Namespaces {
		slices.SortFunc(namespace.types, func(a, b *TypeRWWrapper) int {
			return TypeRWWrapperLessLocal(a, b)
		})
		anyTypeAlias := false
		anyEnumElementAlias := false
		anyFunction := false
		for _, wr := range namespace.types {
			if wr.ShouldWriteTypeAlias() {
				anyTypeAlias = true
			}
			if wr.ShouldWriteEnumElementAlias() {
				anyEnumElementAlias = true
			}
			if fun, ok := wr.trw.(*TypeRWStruct); ok && fun.ResultType != nil {
				anyFunction = true
			}
		}
		if !anyTypeAlias && !anyEnumElementAlias && !anyFunction {
			continue
		}
		directImports := &DirectImports{ns: map[*InternalNamespace]struct{}{}}
		var sortedNames []string
		_ = gen.generateNamespacesCode(anyTypeAlias, anyFunction, name, namespace, sortedNames, directImports)
		for im := range directImports.ns { // Imports of this file.
			sortedNames = append(sortedNames, im.SubPath)
		}
		slices.Sort(sortedNames)
		filepathName := filepath.Join(gen.GlobalPackageName+name, gen.GlobalPackageName+name+".go")
		code := gen.generateNamespacesCode(anyTypeAlias, anyFunction, name, namespace, sortedNames, directImports)
		if code == "" {
			continue
		}
		if err := outdir.AddCodeFile(filepathName, gen.options.CopyrightText+code); err != nil {
			return err
		}
	}
	if gen.options.Verbose {
		log.Printf("generation of RPC code finished, %d namespaces generated", len(gen.Namespaces))
	}
	{
		filepathName := filepath.Join(ConstantsPackageName, ConstantsPackageName+".go") // TODO if contains GlobalPackgeName as prefix, there could be name collisions
		code := gen.generateConstants(HeaderComment, ConstantsPackageName)
		if err := outdir.AddCodeFile(filepathName, gen.options.CopyrightText+code); err != nil {
			return err
		}
		if gen.BasicPackageRelativePath != "" {
			// TODO if contains GlobalPackgeName as prefix, there could be name collisions
			filepathName := filepath.Join(gen.BasicPackageRelativePath, "basictl"+".go")
			code = basictl.BasicTLContent(HeaderComment, BasicTLGoPackageName)
			if err := outdir.AddCodeFile(filepathName, gen.options.CopyrightText+code); err != nil {
				return err
			}
			filepathName = filepath.Join(gen.BasicPackageRelativePath, "basictl2"+".go")
			code = basictl.BasicTL2Content(HeaderComment, BasicTLGoPackageName)
			if err := outdir.AddCodeFile(filepathName, gen.options.CopyrightText+code); err != nil {
				return err
			}
		} else if gen.options.Verbose {
			log.Printf("basictl code not written, expected to be available at %q", gen.options.Go.BasicPackageNameFull)
		}
		startsWithAnyLetter := func(ns string) bool {
			for letter := byte('a'); letter <= 'z'; letter++ {
				if len(ns) != 0 && ns[0] == letter {
					return true
				}
			}
			return false
		}
		for _, bytesVersion := range []bool{false, true} {
			genFac := func(fileName string, addHeader bool, forNamespace func(ns string) bool) error {
				hasCode := false
				directImports := &DirectImports{ns: map[*InternalNamespace]struct{}{}}
				var sortedNames []string
				_ = gen.generateFactory(sortedNames, directImports, bytesVersion,
					addHeader, forNamespace, &hasCode)
				if !hasCode {
					return nil
				}
				for im := range directImports.ns { // Imports of this file.
					sortedNames = append(sortedNames, im.SubPath)
				}
				slices.Sort(sortedNames)
				factoryCode := gen.generateFactory(sortedNames, directImports, bytesVersion,
					addHeader, forNamespace, &hasCode)
				return outdir.AddCodeFile(filepath.Join(addBytesLower(FactoryGoPackageName, bytesVersion), fileName), gen.options.CopyrightText+factoryCode)
			}
			if err := genFac(FactoryGoPackageName+".go", true, func(ns string) bool {
				return !gen.options.Go.SplitInternal || !startsWithAnyLetter(ns)
			}); err != nil {
				return err
			}
			for letter := byte('a'); letter <= 'z'; letter++ {
				if err := genFac(string(letter)+".go", false, func(ns string) bool {
					return gen.options.Go.SplitInternal && len(ns) != 0 && ns[0] == letter
				}); err != nil {
					return err
				}
			}
		}
		metaCode := gen.generateMeta(utils.AppVersion())
		metaCode += gen.generateMetaInit(false, func(ns string) bool {
			return !gen.options.Go.SplitInternal || !startsWithAnyLetter(ns)
		}, nil)

		if err := outdir.AddCodeFile(filepath.Join(MetaGoPackageName, MetaGoPackageName+".go"), gen.options.CopyrightText+metaCode); err != nil {
			return err
		}
		for letter := byte('a'); letter <= 'z'; letter++ {
			hasTypes := false
			metaCode := gen.generateMetaInit(true, func(ns string) bool {
				return gen.options.Go.SplitInternal && len(ns) != 0 && ns[0] == letter
			}, &hasTypes)
			if hasTypes {
				if err := outdir.AddCodeFile(filepath.Join(MetaGoPackageName, string(letter)+".go"), gen.options.CopyrightText+metaCode); err != nil {
					return err
				}
			}
		}
		filepathName = filepath.Join("internal", "a_tlgen_helpers_code.go") // TODO decollision
		code = fmt.Sprintf(InternalTLCodeHeader, HeaderComment, "internal") + InternalTLCodeBody
		if err := outdir.AddCodeFile(filepathName, gen.options.CopyrightText+code); err != nil {
			return err
		}
	}
	if gen.options.Verbose {
		log.Printf("formating generated code...")
	}
	if err := outdir.Write(gen.options, markerFile); err != nil {
		return err // Context is already in err
	}
	return nil
}

func (gen *genGo) InternalPrefix() string {
	if gen.options.Go.SplitInternal {
		return "internal."
	}
	return ""
}

func (gen *genGo) getNamespace(n string) *Namespace {
	na, ok := gen.Namespaces[n]
	if !ok {
		na = &Namespace{}
		gen.Namespaces[n] = na
		// TODO - ALL golang-specific names
		na.decGo.deconflictName("Handler")
		na.decGo.deconflictName("Handle")
		na.decGo.deconflictName("Client")
	}
	return na
}

func (gen *genGo) getType(t pure.TypeInstance) (*TypeRWWrapper, error) {
	result, ok := gen.generatedTypes[t.CanonicalName()]
	if !ok {
		return nil, fmt.Errorf("internal error: type %q not found", t.CanonicalName())
	}
	return result, nil
}
