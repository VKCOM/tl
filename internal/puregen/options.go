// Copyright 2025 V Kontakte LLC
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package puregen

import (
	"flag"
	"fmt"
	"io"
	"io/fs"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/vkcom/tl/internal/pure"
)

type Options struct {
	Language          string
	Outdir            string
	Outfile           string
	CopyrightFilePath string
	CopyrightText     string // set to content of CopyrightFilePath

	Verbose     bool
	ErrorWriter io.Writer // all Errors and warnings should be redirected to this io.Writer, by default it is os.Stderr

	SchemaURL       string
	SchemaTimestamp uint // for TLO version/date
	SchemaCommit    string

	// common options for many languages
	GenerateRPCCode    bool
	GenerateRandomCode bool
	BytesWhiteList     string

	GenerateTL2            bool // TODO - change into method
	GenerateLegacyJsonRead bool // always false, TODO - remove after kernel refactor

	Kernel pure.OptionsKernel
	Go     OptionsGo

	// sometimes we need to replace lots of names in vkgo repository, when we change generation.
	// so it turned out, the fastest solution is simply use generator itself
	ReplaceDir string
	// this is not an option, but any generator can add names here to be replaced by common code
	replaceStrings []replaceStringsItem
}

type replaceStringsItem struct {
	FileSuffix string
	Before     string
	After      string
}

func (opt *Options) Bind(f *flag.FlagSet, languagesString string) {
	f.StringVar(&opt.Language, "language", "lint",
		fmt.Sprintf(`generation target language, must be %s`, languagesString))
	f.StringVar(&opt.Outdir, "outdir", "",
		`where to write generated files`)
	f.StringVar(&opt.Outfile, "outfile", "",
		`where to write generated file`)
	f.StringVar(&opt.CopyrightFilePath, "copyrightPath", "",
		"path to file with copyright text")
	f.BoolVar(&opt.Verbose, "v", false,
		"verbose mode that prints debug info")

	f.StringVar(&opt.SchemaURL, "schemaURL", "",
		"url of schema (for documentation)")
	f.UintVar(&opt.SchemaTimestamp, "schemaTimestamp", 0,
		"timestamp of schema (for documentation, TLO version)")
	f.StringVar(&opt.SchemaCommit, "schemaCommit", "",
		"commit of schema (for documentation)")

	f.BoolVar(&opt.GenerateRPCCode, "generateRPCCode", false,
		"whether to generate *_server.go files")
	f.BoolVar(&opt.GenerateRandomCode, "generateRandomCode", false,
		"whether to generate methods for random filling structs")
	f.StringVar(&opt.BytesWhiteList, "generateByteVersions", "",
		"comma-separated list of fully-qualified top-level types or namespaces (if have trailing '.'), to generate byte versions for. Empty means none, '*' means all.")

	f.StringVar(&opt.ReplaceDir, "replaceDir", "",
		"path to main repository so generator can make replacement of legacy names")

	opt.Kernel.Bind(f)
	opt.Go.Bind(f)
}

func (opt *Options) Validate() error {
	opt.Kernel.ErrorWriter = opt.ErrorWriter
	opt.GenerateTL2 = opt.Kernel.TL2WhiteList != ""

	// historically, there were some defaults for different languages, we keep them for now
	switch opt.Language {
	case "cpp":
		opt.CopyrightText = "// Code generated by vktl/cmd/tlgen2; DO NOT EDIT.\n"
	case "php":
		opt.CopyrightText = `/**
 * AUTOGENERATED, DO NOT EDIT! If you want to modify it, check tl schema.
 *
 * This autogenerated code represents tl class for typed RPC API.
 */

`
	}
	if opt.CopyrightFilePath != "" {
		buf, err := os.ReadFile(opt.CopyrightFilePath)
		if err != nil {
			return fmt.Errorf("failed to open copyright text file %q: %w", opt.CopyrightFilePath, err)
		}
		opt.CopyrightText = string(buf)
	}
	return nil
}

// Any generator can request replacing client code in main repository by calling this function.
// User should run generator with --replaceDir=XXX for each repository to replace names in.
func (opt *Options) ReplaceStrings(fileSuffix string, before string, after string) {
	fmt.Printf("Replace name requested in %s: %s -> %s\n", fileSuffix, before, after)
	opt.replaceStrings = append(opt.replaceStrings,
		replaceStringsItem{FileSuffix: fileSuffix, Before: before, After: after})
}

func (opt *Options) ReplaceStringInDir() error {
	if opt.ReplaceDir == "" || len(opt.replaceStrings) == 0 {
		return nil
	}
	fmt.Printf("Replacing %d strings in %s\n", len(opt.replaceStrings), opt.ReplaceDir)
	suffixes := map[string]struct{}{}
	for _, r := range opt.replaceStrings {
		suffixes[r.FileSuffix] = struct{}{}
	}
	total := 0
	// sometimes replacing takes very long time, we need some progressbar
	err := filepath.Walk(opt.ReplaceDir, func(path string, info fs.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if !info.Mode().IsRegular() {
			return nil
		}
		canonical := strings.ReplaceAll(path, string(os.PathSeparator), "/")
		if strings.Contains(canonical, "/.") { // .git and similar
			return nil
		}
		total++
		return nil
	})
	if err != nil {
		return err
	}
	current := 0
	now := time.Now()
	err = filepath.Walk(opt.ReplaceDir, func(path string, info fs.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if !info.Mode().IsRegular() {
			return nil
		}
		canonical := strings.ReplaceAll(path, string(os.PathSeparator), "/")
		if strings.Contains(canonical, "/.") { // .git and similar
			return nil
		}
		current++
		if time.Since(now) > 10*time.Second {
			now = time.Now()
			fmt.Printf("replacement progress: %d/%d\n", current, total)
		}
		var originalContent string
		var replacedContent string
		for _, r := range opt.replaceStrings {
			if !strings.HasSuffix(canonical, r.FileSuffix) {
				continue
			}
			if originalContent == "" {
				was, err := os.ReadFile(path)
				if err != nil {
					fmt.Printf("error reading file %s: %v\n", path, err)
					return nil
				}
				if len(was) == 0 {
					return nil
				}
				originalContent = string(was)
				replacedContent = originalContent
			}
			replacedContent = strings.ReplaceAll(replacedContent, r.Before, r.After)
		}
		if replacedContent != originalContent {
			if err := os.WriteFile(path, []byte(replacedContent), info.Mode()); err != nil {
				fmt.Printf("error writing file %s: %v\n", path, err)
			} else {
				fmt.Printf("replaced strings in file %s\n", path)
			}
		}
		return nil
	})
	return err
}
