{%- func (tuple *TypeRWBrackets) GenerateCode(bytesVersion bool, directImports *DirectImports) -%}
    {%- code
        goName := addBytes(tuple.wr.goGlobalName, bytesVersion)
        natDecl := formatNatArgsDecl(tuple.wr.NatParams)
        natCall := formatNatArgsDeclCall(tuple.wr.NatParams)
        typeString := tuple.wr.TypeString2(bytesVersion, directImports, tuple.wr.ins, false, false)
        elementTypeString := tuple.element.t.TypeString2(bytesVersion, directImports, tuple.wr.ins, false, false)
        writeElementNeedsError := tuple.element.t.hasErrorInWriteMethods
    -%}
    {%- switch -%}
        {%- case tuple.dictLike -%}
            {%- code
                keyTypeString := tuple.dictKeyField.t.TypeString2(bytesVersion, directImports, tuple.wr.ins, false, false)
                valueTypeString := tuple.dictValueField.t.TypeString2(bytesVersion, directImports, tuple.wr.ins, false, false)
                valueNatArgsDecl := formatNatArgsDecl(tuple.element.t.NatParams)
                valueNatArgsCall := formatNatArgsDeclCall(tuple.element.t.NatParams)
                keyFieldName := tuple.dictKeyField.goName
                valueFieldName := tuple.dictValueField.goName
            -%}
            {%- if bytesVersion -%}
                {%- if tuple.wr.gen.options.GenerateRandomCode -%}
func {%s= goName %}FillRandom(rg *basictl.RandGenerator, vec *{%s= typeString %} {%s= natDecl %}) {
    rg.IncreaseDepth()
    l := rg.LimitValue(basictl.RandomUint(rg))
    *vec = make([]{%s= elementTypeString %}, l)
    for i := range *vec {
        {%s= tuple.element.t.TypeRandomCode(bytesVersion, directImports, tuple.wr.ins, "(*vec)[i]", formatNatArgs(nil, tuple.element.natArgs), false) %}
    }
    rg.DecreaseDepth()
}
                {%- endif -%}

func {%s= goName %}Read(w []byte, vec *{%s= typeString %} {%s= natDecl %}) (_ []byte, err error) {
    var l uint32
    if w, err = basictl.NatRead(w, &l); err != nil {
        return w, err
    }
    {%- if tuple.wr.gen.options.UseCheckLengthSanity -%}
    if err = basictl.CheckLengthSanity(w, l, 4); err != nil {
        return w, err
    }
    {%- endif -%}
    if uint32(cap(*vec)) < l {
        *vec = make([]{%s= elementTypeString %}, l)
    } else {
        *vec = (*vec)[:l]
    }
    for i := range *vec {
        {%s= tuple.element.t.TypeReadingCode(bytesVersion, directImports, tuple.wr.ins, "(*vec)[i]", tuple.element.Bare(), formatNatArgs(nil, tuple.element.natArgs), false, false ) %}
    }
    return w, nil
}

func {%s= goName %}Write(w []byte, vec {%s= typeString %} {%s= natDecl %}) {%s= wrapWithError(writeElementNeedsError, "[]byte") %} {
    w = basictl.NatWrite(w, uint32(len(vec)))
    for _, elem := range vec {
        {%s= tuple.element.t.TypeWritingCode(bytesVersion, directImports, tuple.wr.ins, "elem", tuple.element.Bare(), formatNatArgs(nil, tuple.element.natArgs), false, false, writeElementNeedsError) %}
    }
    {%- if writeElementNeedsError -%}
    return w, nil
    {%- else -%}
    return w
    {%- endif -%}
}
{%- if tuple.wr.gen.options.GenerateTL2 -%}

func {%s= goName %}CalculateLayout(sizes []int,vec *{%s= typeString %}{%s= valueNatArgsDecl %}) []int {
    sizePosition := len(sizes)
    sizes = append(sizes, 0)
    for i := 0; i < len(*vec); i++ {
        {%- if tuple.dictKeyField.t.trw.doesCalculateLayoutUseObject() || tuple.dictValueField.t.trw.doesCalculateLayoutUseObject() -%}
        elem := (*vec)[i]
        {%- endif -%}
        currentPosition := len(sizes)
        {%s= tuple.dictKeyField.t.CalculateLayout(bytesVersion, "sizes", "elem.Key", false, tuple.wr.ins, false, formatNatArgs(nil, tuple.element.natArgs)) %}
        sizes[sizePosition] += sizes[currentPosition]
        {%- if tuple.dictKeyField.t.trw.isSizeWrittenInData() -%}
        sizes[sizePosition] += basictl.TL2CalculateSize(sizes[currentPosition])
        {%- endif -%}
        currentPosition = len(sizes)
        {%s= tuple.dictValueField.t.CalculateLayout(bytesVersion, "sizes", "elem.Value", false, tuple.wr.ins, false, formatNatArgs(nil, tuple.element.natArgs)) %}
        sizes[sizePosition] += sizes[currentPosition]
        {%- if tuple.dictValueField.t.trw.isSizeWrittenInData() -%}
        sizes[sizePosition] += basictl.TL2CalculateSize(sizes[currentPosition])
        {%- endif -%}
    }
    return sizes
}

func {%s= goName %}InternalWriteTL2(w []byte, sizes []int,vec *{%s= typeString %}{%s= valueNatArgsDecl %}) ([]byte, []int) {
    currentSize := sizes[0]
    sizes = sizes[1:]

    w = basictl.TL2WriteSize(w, currentSize)
    if currentSize == 0 {
        return w, sizes
    }

    for i := 0; i < len(*vec); i++ {
        {%- if tuple.dictKeyField.t.trw.doesWriteTL2UseObject(false) || tuple.dictValueField.t.trw.doesWriteTL2UseObject(false) -%}
        elem := (*vec)[i]
        {%- endif -%}
        {%s= tuple.dictKeyField.t.WriteTL2Call(bytesVersion, "sizes", "w", "elem.Key", false, tuple.wr.ins, false, formatNatArgs(nil, tuple.element.natArgs)) %}
        {%s= tuple.dictValueField.t.WriteTL2Call(bytesVersion, "sizes", "w", "elem.Value", false, tuple.wr.ins, false, formatNatArgs(nil, tuple.element.natArgs)) %}
    }
    return w, sizes
}

{%- endif -%}

                {%- if tuple.dictKeyString -%}
{%- if tuple.wr.gen.options.GenerateLegacyJsonRead -%}
func {%s= goName %}ReadJSONLegacy(legacyTypeNames bool, j interface{}, vec *{%s= typeString %} {%s= valueNatArgsDecl %}) error {
    var _map map[string]interface{}
    var _mapok bool
    if j != nil {
        _map, _mapok = j.(map[string]interface{})
        if !_mapok {
            return {%s= tuple.wr.gen.InternalPrefix()%}ErrorInvalidJSON({%q= typeString %}, "expected json object")
        }
    }
      l := len(_map)
    if cap(*vec) < l {
        *vec = make([]{%s= elementTypeString %}, l)
    } else {
        *vec = (*vec)[:l]
    }
    i := 0
    arr := *vec
    for key, _jvalue := range _map {
        arr[i].{%s= tuple.dictKeyField.goName %} = append(arr[i].{%s= tuple.dictKeyField.goName %}[:0], key...)
        {%s= tuple.dictValueField.t.TypeJSONReadingCode(bytesVersion, directImports, tuple.wr.ins, "_jvalue", "arr[i]."+valueFieldName, formatNatArgs(nil, tuple.dictValueField.natArgs), false, ) %}
        i++
    }
    return nil
}

{%- endif -%}
func {%s= goName %}ReadJSON(legacyTypeNames bool, in *basictl.JsonLexer, vec *{%s= typeString %} {%s= valueNatArgsDecl %}) error {
	*vec = (*vec)[:cap(*vec)]
	index := 0
	if in != nil {
        in.Delim('{')
        if !in.Ok() {
            return {%s= tuple.wr.gen.InternalPrefix()%}ErrorInvalidJSON({%q= typeString %}, "expected json object")
        }
        for ;!in.IsDelim('}'); index++ {
            if len(*vec) <= index {
                var newValue {%s= elementTypeString %}
                *vec = append(*vec, newValue)
                *vec = (*vec)[:cap(*vec)]
            }
            (*vec)[index].Key = append((*vec)[index].Key[:0], in.UnsafeFieldName(true)...)
            in.WantColon()
            {%s= tuple.dictValueField.t.TypeJSON2ReadingCode(bytesVersion, directImports, tuple.wr.ins, "in", "(*vec)[index]."+valueFieldName, formatNatArgs(nil, tuple.dictValueField.natArgs), false ) %}
            in.WantComma()
        }
        in.Delim('}')
        if !in.Ok() {
            return {%s= tuple.wr.gen.InternalPrefix()%}ErrorInvalidJSON({%q= typeString %}, "expected json object's end")
        }
    }
	*vec = (*vec)[:index]
	return nil
}

func {%s= goName %}WriteJSON(w []byte, vec {%s= typeString %} {%s= valueNatArgsDecl %}) {%s= wrapWithError(writeElementNeedsError, "[]byte") %} {
    return {%s= goName %}WriteJSONOpt(true, false, w, vec{%s= valueNatArgsCall %})
}
func {%s= goName %}WriteJSONOpt(newTypeNames bool, short bool, w []byte, vec {%s= typeString %} {%s= valueNatArgsDecl %}) {%s= wrapWithError(writeElementNeedsError, "[]byte") %} {
    w = append(w, '{')
    for _, elem := range vec {
        w = basictl.JSONAddCommaIfNeeded(w)
        w = basictl.JSONWriteStringBytes(w, elem.{%s= tuple.dictKeyField.goName %})
        w = append(w, ':')
        {%s= tuple.dictValueField.t.TypeJSONWritingCode(bytesVersion, directImports, tuple.wr.ins, "elem."+valueFieldName, formatNatArgs(nil, tuple.dictValueField.natArgs), false, writeElementNeedsError) %}
    }
    {%- if writeElementNeedsError -%}
    return append(w, '}'), nil
    {%- else -%}
    return append(w, '}')
    {%- endif -%}
}
                {%- else -%}
{%- if tuple.wr.gen.options.GenerateLegacyJsonRead -%}
func {%s= goName %}ReadJSONLegacy(legacyTypeNames bool, j interface{}, vec *{%s= typeString %} {%s= valueNatArgsDecl %}) error {
    var _map map[string]interface{}
    var _mapok bool
    if j != nil {
        _map, _mapok = j.(map[string]interface{})
        if !_mapok {
            return {%s= tuple.wr.gen.InternalPrefix()%}ErrorInvalidJSON({%q= typeString %}, "expected json object")
        }
    }
      l := len(_map)
    if cap(*vec) < l {
        *vec = make([]{%s= elementTypeString %}, l)
    } else {
        *vec = (*vec)[:l]
    }
    i := 0
    arr := *vec
    for _jkey, _jvalue := range _map {
        {%s= tuple.dictKeyField.t.TypeJSONReadingCode(bytesVersion, directImports, tuple.wr.ins, "_jkey", "arr[i]."+keyFieldName, formatNatArgs(nil, tuple.dictKeyField.natArgs), false ) %}
        {%s= tuple.dictValueField.t.TypeJSONReadingCode(bytesVersion, directImports, tuple.wr.ins, "_jvalue", "arr[i]."+valueFieldName, formatNatArgs(nil, tuple.dictValueField.natArgs), false ) %}
        i++
    }
    return nil
}

{%- endif -%}
func {%s= goName %}ReadJSON(legacyTypeNames bool, in *basictl.JsonLexer, vec *{%s= typeString %} {%s= valueNatArgsDecl %}) error {
	*vec = (*vec)[:cap(*vec)]
	index := 0
	if in != nil {
        in.Delim('{')
        if !in.Ok() {
            return {%s= tuple.wr.gen.InternalPrefix()%}ErrorInvalidJSON({%q= typeString %}, "expected json object")
        }
        for ;!in.IsDelim('}'); index++ {
            if len(*vec) <= index {
                var newValue {%s= elementTypeString %}
                *vec = append(*vec, newValue)
                *vec = (*vec)[:cap(*vec)]
            }
            keyBytes := []byte(in.UnsafeFieldName(false))
            if !in.Ok() {
                return {%s= tuple.wr.gen.InternalPrefix()%}ErrorInvalidJSON({%q= typeString %}, "expected correct json value in key")
            }
            in2 := basictl.JsonLexer{Data: keyBytes}
            {%s= tuple.dictKeyField.t.TypeJSON2ReadingCode(bytesVersion, directImports, tuple.wr.ins, "&in2", "(*vec)[index]."+keyFieldName, formatNatArgs(nil, tuple.dictKeyField.natArgs), false ) %}
            in.WantColon()
            {%s= tuple.dictValueField.t.TypeJSON2ReadingCode(bytesVersion, directImports, tuple.wr.ins, "in", "(*vec)[index]."+valueFieldName, formatNatArgs(nil, tuple.dictValueField.natArgs), false ) %}
            in.WantComma()
        }
        in.Delim('}')
        if !in.Ok() {
            return {%s= tuple.wr.gen.InternalPrefix()%}ErrorInvalidJSON({%q= typeString %}, "expected json object's end")
        }
    }
	*vec = (*vec)[:index]
	return nil
}

func {%s= goName %}WriteJSON(w []byte, vec {%s= typeString %} {%s= valueNatArgsDecl %}) {%s= wrapWithError(writeElementNeedsError, "[]byte") %} {
    return {%s= goName %}WriteJSONOpt(true, false, w, vec{%s= valueNatArgsCall %})
}
func {%s= goName %}WriteJSONOpt(newTypeNames bool, short bool, w []byte, vec {%s= typeString %} {%s= valueNatArgsDecl %}) {%s= wrapWithError(writeElementNeedsError, "[]byte") %} {
    w = append(w, '{')
    for _, elem := range vec {
        key := elem.{%s= keyFieldName %}
        w = basictl.JSONAddCommaIfNeeded(w)
        w = append(w, `"`...)
        {%s= tuple.dictKeyField.t.TypeJSONWritingCode(bytesVersion, directImports, tuple.wr.ins, "key", formatNatArgs(nil, tuple.dictKeyField.natArgs), false, tuple.dictKeyField.t.hasErrorInWriteMethods) %}
        w = append(w, `":`...)
        {%s= tuple.dictValueField.t.TypeJSONWritingCode(bytesVersion, directImports, tuple.wr.ins, "elem."+valueFieldName, formatNatArgs(nil, tuple.dictValueField.natArgs), false, tuple.dictValueField.t.hasErrorInWriteMethods) %}
    }
    {%- if writeElementNeedsError -%}
    return append(w, '}'), nil
    {%- else -%}
    return append(w, '}')
    {%- endif -%}
}
                {%- endif -%}
            {%- else -%}
func {%s= goName %}Reset(m map[{%s= keyTypeString %}]{%s= valueTypeString %}) {
    for k := range m {
        delete(m, k)
    }
}

            {%- if tuple.wr.gen.options.GenerateRandomCode -%}
func {%s= goName %}FillRandom(rg *basictl.RandGenerator, m *map[{%s= keyTypeString %}]{%s= valueTypeString %} {%s= natDecl %}) {
    rg.IncreaseDepth()
    l := rg.LimitValue(basictl.RandomUint(rg))
    *m = make(map[{%s= keyTypeString %}]{%s= valueTypeString %}, l)
    for i := 0; i < int(l); i++ {
        var elem {%s= elementTypeString %}
        {%s= tuple.element.t.TypeRandomCode(bytesVersion, directImports, tuple.wr.ins, "elem", formatNatArgs(nil, tuple.element.natArgs), false) %}
        (*m)[elem.{%s= keyFieldName %}] = elem.{%s= valueFieldName %}
    }
    rg.DecreaseDepth()
}
            {%- endif -%}
func {%s= goName %}Read(w []byte, m *map[{%s= keyTypeString %}]{%s= valueTypeString %} {%s= natDecl %}) (_ []byte, err error) {
    var l uint32
    if w, err = basictl.NatRead(w, &l); err != nil {
        return w, err
    }
    {%- if tuple.wr.gen.options.UseCheckLengthSanity -%}
    if err = basictl.CheckLengthSanity(w, l, 4); err != nil {
        return w, err
    }
    {%- endif -%}
    var data map[{%s= keyTypeString %}]{%s= valueTypeString %}
    if *m == nil {
        if l == 0 {
            return w, nil
        }
        data = make(map[{%s= keyTypeString %}]{%s= valueTypeString %}, l)
        *m = data
    } else {
        data = *m
        for k := range data {
            delete(data, k)
        }
    }
    for i := 0; i < int(l); i++ {
        var elem {%s= elementTypeString %}
        {%s= tuple.element.t.TypeReadingCode(bytesVersion, directImports, tuple.wr.ins, "elem", tuple.element.Bare(), formatNatArgs(nil, tuple.element.natArgs), false, false ) %}
         data[elem.{%s= keyFieldName %}] = elem.{%s= valueFieldName %}
    }
    return w, nil
}

func {%s= goName %}Write(w []byte, m map[{%s= keyTypeString %}]{%s= valueTypeString %} {%s= natDecl %}) {%s= wrapWithError(writeElementNeedsError, "[]byte") %} {
    w = basictl.NatWrite(w, uint32(len(m)))
    if len(m) == 0 {
    {%- if writeElementNeedsError -%}
        return w, nil
    {%- else -%}
        return w
    {%- endif -%}
    }
    keys := make([]{%s= keyTypeString %}, 0, len(m))
    for k := range m {
        keys = append(keys, k)
    }
    {%- code
        directImports.importSort = true
    -%}
{%- if tuple.dictKeyString -%}
    sort.Strings(keys)
{%- else -%}
    sort.Slice(keys, func(i, j int) bool {
        return keys[i] < keys[j]
    })
{%- endif -%}
    for _, key := range keys {
        val := m[key]
        elem := {%s= elementTypeString %}{{%s= keyFieldName %}:key, {%s= valueFieldName %}:val}
        {%s= tuple.element.t.TypeWritingCode(bytesVersion, directImports, tuple.wr.ins, "elem", tuple.element.Bare(), formatNatArgs(nil, tuple.element.natArgs), false, false, writeElementNeedsError) %}
    }
    {%- if writeElementNeedsError -%}
    return w, nil
    {%- else -%}
    return w
    {%- endif -%}
}
{%- if tuple.wr.gen.options.GenerateTL2 -%}

func {%s= goName %}CalculateLayout(sizes []int, m *map[{%s= keyTypeString %}]{%s= valueTypeString %}{%s= natDecl %}) []int {
    sizePosition := len(sizes)
    sizes = append(sizes, 0)

    keys := make([]{%s= keyTypeString %}, 0, len(*m))
    for k := range *m {
        keys = append(keys, k)
    }
{%- if tuple.dictKeyString -%}
    sort.Strings(keys)
{%- else -%}
    sort.Slice(keys, func(i, j int) bool {
        return keys[i] < keys[j]
    })
{%- endif -%}

    for i := 0; i < len(keys); i++ {
        {%- if tuple.dictKeyField.t.trw.doesCalculateLayoutUseObject() || tuple.dictValueField.t.trw.doesCalculateLayoutUseObject() -%}
        key := keys[i]
        {%- endif -%}
        currentPosition := len(sizes)
        {%s= tuple.dictKeyField.t.CalculateLayout(bytesVersion, "sizes", "key", false, tuple.wr.ins, false, formatNatArgs(nil, tuple.element.natArgs)) %}
        sizes[sizePosition] += sizes[currentPosition]
        {%- if tuple.dictKeyField.t.trw.isSizeWrittenInData() -%}
        sizes[sizePosition] += basictl.TL2CalculateSize(sizes[currentPosition])
        {%- endif -%}
        currentPosition = len(sizes)
        {%s= tuple.dictValueField.t.CalculateLayout(bytesVersion, "sizes", "(*m)[key]", false, tuple.wr.ins, false, formatNatArgs(nil, tuple.element.natArgs)) %}
        sizes[sizePosition] += sizes[currentPosition]
        {%- if tuple.dictValueField.t.trw.isSizeWrittenInData() -%}
        sizes[sizePosition] += basictl.TL2CalculateSize(sizes[currentPosition])
        {%- endif -%}
    }
    return sizes
}

func {%s= goName %}InternalWriteTL2(w []byte, sizes []int, m *map[{%s= keyTypeString %}]{%s= valueTypeString %}{%s= natDecl %}) ([]byte, []int) {
    currentSize := sizes[0]
    sizes = sizes[1:]

    w = basictl.TL2WriteSize(w, currentSize)
    if currentSize == 0 {
        return w, sizes
    }

    keys := make([]{%s= keyTypeString %}, 0, len(*m))
    for k := range *m {
        keys = append(keys, k)
    }
{%- if tuple.dictKeyString -%}
    sort.Strings(keys)
{%- else -%}
    sort.Slice(keys, func(i, j int) bool {
        return keys[i] < keys[j]
    })
{%- endif -%}

    for i := 0; i < len(keys); i++ {
        {%- if tuple.dictKeyField.t.trw.doesWriteTL2UseObject(false) || tuple.dictValueField.t.trw.doesWriteTL2UseObject(false) -%}
        key := keys[i]
        {%- endif -%}
        {%s= tuple.dictKeyField.t.WriteTL2Call(bytesVersion, "sizes", "w", "key", false, tuple.wr.ins, false, formatNatArgs(nil, tuple.element.natArgs)) %}
        {%s= tuple.dictValueField.t.WriteTL2Call(bytesVersion, "sizes", "w", "(*m)[key]", false, tuple.wr.ins, false, formatNatArgs(nil, tuple.element.natArgs)) %}
    }

    return w, sizes
}
{%- endif -%}

{%- if tuple.wr.gen.options.GenerateLegacyJsonRead -%}
func {%s= goName %}ReadJSONLegacy(legacyTypeNames bool, j interface{}, m *{%s= typeString %} {%s= valueNatArgsDecl %}) error {
    var _map map[string]interface{}
    var _mapok bool
    if j != nil {
        _map, _mapok = j.(map[string]interface{})
        if !_mapok {
            return {%s= tuple.wr.gen.InternalPrefix()%}ErrorInvalidJSON({%q= typeString %}, "expected json object")
        }
    }
    l := len(_map)
    var data map[{%s= keyTypeString %}]{%s= valueTypeString %}
    if *m == nil {
        if l == 0 {
            return nil
        }
        data = make(map[{%s= keyTypeString %}]{%s= valueTypeString %}, l)
        *m = data
    } else {
        data = *m
        for k := range data {
            delete(data, k)
        }
    }
    for _jkey, _jvalue := range _map {
                {%- if tuple.dictKeyString -%}
                {%- else -%}
        var key {%s= keyTypeString %}
        {%s= tuple.dictKeyField.t.TypeJSONReadingCode(bytesVersion, directImports, tuple.wr.ins, "_jkey", "key", formatNatArgs(nil, tuple.dictKeyField.natArgs), false ) %}
                {%- endif -%}
        var value {%s= valueTypeString %}
        {%s= tuple.dictValueField.t.TypeJSONReadingCode(bytesVersion, directImports, tuple.wr.ins, "_jvalue", "value", formatNatArgs(nil, tuple.dictValueField.natArgs), false ) %}
                {%- if tuple.dictKeyString -%}
        data[_jkey] = value
                {%- else -%}
        data[key] = value
                {%- endif -%}
    }
    return nil
}

{%- endif -%}
func {%s= goName %}ReadJSON(legacyTypeNames bool, in *basictl.JsonLexer, m *{%s= typeString %} {%s= valueNatArgsDecl %}) error {
	var data map[{%s= keyTypeString %}]{%s= valueTypeString %}
	if *m == nil {
	    *m = make(map[{%s= keyTypeString %}]{%s= valueTypeString %}, 0)
	    data = *m
	} else {
        data = *m
        for k := range data {
            delete(data, k)
        }
    }
    if in != nil {
        in.Delim('{')
        if !in.Ok() {
            return {%s= tuple.wr.gen.InternalPrefix()%}ErrorInvalidJSON({%q= typeString %}, "expected json object")
        }
        for !in.IsDelim('}') {
        {%- if tuple.dictKeyString -%}
            key := in.UnsafeFieldName(true)
            in.WantColon()
            var value {%s= valueTypeString %}
            {%s= tuple.dictValueField.t.TypeJSON2ReadingCode(bytesVersion, directImports, tuple.wr.ins, "in", "value", formatNatArgs(nil, tuple.dictValueField.natArgs), false ) %}
            data[key] = value
        {%- else -%}
            keyBytes := []byte(in.UnsafeFieldName(false))
            in.WantColon()
            if !in.Ok() {
                return {%s= tuple.wr.gen.InternalPrefix()%}ErrorInvalidJSON({%q= typeString %}, "expected correct json value in key")
            }
            in2 := basictl.JsonLexer{Data: keyBytes}
            var key {%s= keyTypeString %}
            {%s= tuple.dictKeyField.t.TypeJSON2ReadingCode(bytesVersion, directImports, tuple.wr.ins, "&in2", "key", formatNatArgs(nil, tuple.dictKeyField.natArgs), false ) %}
            var value {%s= valueTypeString %}
            {%s= tuple.dictValueField.t.TypeJSON2ReadingCode(bytesVersion, directImports, tuple.wr.ins, "in", "value", formatNatArgs(nil, tuple.dictValueField.natArgs), false ) %}
            data[key] = value
        {%- endif -%}
            in.WantComma()
        }
        in.Delim('}')
        if !in.Ok() {
            return {%s= tuple.wr.gen.InternalPrefix()%}ErrorInvalidJSON({%q= typeString %}, "expected json object's end")
        }
    }
    return nil
}

func {%s= goName %}WriteJSON(w []byte, m {%s= typeString %} {%s= valueNatArgsDecl %}) {%s= wrapWithError(writeElementNeedsError, "[]byte") %} {
    return {%s= goName %}WriteJSONOpt(true, false, w, m{%s= valueNatArgsCall %})
}
                {%- if tuple.dictKeyString -%}
func {%s= goName %}WriteJSONOpt(newTypeNames bool, short bool, w []byte, m {%s= typeString %} {%s= valueNatArgsDecl %}) {%s= wrapWithError(writeElementNeedsError, "[]byte") %} {
    keys := make([]{%s= keyTypeString %}, 0, len(m))
    for k := range m {
        keys = append(keys, k)
    }
    {%- code
        directImports.importSort = true
    -%}
    sort.Strings(keys)
    w = append(w, '{')
    for _, key := range keys {
        value := m[key]
        w = basictl.JSONAddCommaIfNeeded(w)
        w = basictl.JSONWriteString(w, key)
        w = append(w, ':')
        {%s= tuple.dictValueField.t.TypeJSONWritingCode(bytesVersion, directImports, tuple.wr.ins, "value", formatNatArgs(nil, tuple.dictValueField.natArgs), false, tuple.dictValueField.t.hasErrorInWriteMethods) %}
    }
    {%- if writeElementNeedsError -%}
    return append(w, '}'), nil
    {%- else -%}
    return append(w, '}')
    {%- endif -%}
}
                {%- else -%}
func {%s= goName %}WriteJSONOpt(newTypeNames bool, short bool, w []byte, m {%s= typeString %} {%s= natDecl %}) {%s= wrapWithError(writeElementNeedsError, "[]byte") %} {
    keys := make([]{%s= keyTypeString %}, 0, len(m))
    for k := range m {
        keys = append(keys, k)
    }
    {%- code
        directImports.importSort = true
    -%}
    sort.Slice(keys, func(i, j int) bool {
        return keys[i] < keys[j]
    })
    w = append(w, '{')
    for _, key := range keys {
        value := m[key]
        w = basictl.JSONAddCommaIfNeeded(w)
        w = append(w, `"`...)
        {%s= tuple.dictKeyField.t.TypeJSONWritingCode(bytesVersion, directImports, tuple.wr.ins, "key", formatNatArgs(nil, tuple.dictKeyField.natArgs), false, tuple.dictKeyField.t.hasErrorInWriteMethods) %}
        w = append(w, `":`...)
        {%s= tuple.dictValueField.t.TypeJSONWritingCode(bytesVersion, directImports, tuple.wr.ins, "value", formatNatArgs(nil, tuple.dictValueField.natArgs), false, tuple.dictValueField.t.hasErrorInWriteMethods) %}
    }
    {%- if writeElementNeedsError -%}
    return append(w, '}'), nil
    {%- else -%}
    return append(w, '}')
    {%- endif -%}
}
                {%- endif -%}
            {%- endif -%}
        {%- case tuple.vectorLike -%}
            {%- if tuple.wr.gen.options.GenerateRandomCode -%}
func {%s= goName %}FillRandom(rg *basictl.RandGenerator, vec *{%s= typeString %} {%s= natDecl %}) {
    rg.IncreaseDepth()
    l := rg.LimitValue(basictl.RandomUint(rg))
    *vec = make([]{%s= elementTypeString %}, l)
    for i := range *vec {
        {%s= tuple.element.t.TypeRandomCode(bytesVersion, directImports, tuple.wr.ins, "(*vec)[i]", formatNatArgs(nil, tuple.element.natArgs), false) %}
    }
    rg.DecreaseDepth()
}
            {%- endif -%}
func {%s= goName %}Read(w []byte, vec *{%s= typeString %} {%s= natDecl %}) (_ []byte, err error) {
    var l uint32
    if w, err = basictl.NatRead(w, &l); err != nil {
        return w, err
    }
    {%- if tuple.wr.gen.options.UseCheckLengthSanity -%}
    if err = basictl.CheckLengthSanity(w, l, 4); err != nil {
        return w, err
    }
    {%- endif -%}
    if uint32(cap(*vec)) < l {
        *vec = make([]{%s= elementTypeString %}, l)
    } else {
        *vec = (*vec)[:l]
    }
    for i := range *vec {
        {%s= tuple.element.t.TypeReadingCode(bytesVersion, directImports, tuple.wr.ins, "(*vec)[i]", tuple.element.Bare(), formatNatArgs(nil, tuple.element.natArgs), false, false ) %}
    }
    return w, nil
}

func {%s= goName %}Write(w []byte, vec {%s= typeString %} {%s= natDecl %}) {%s= wrapWithError(writeElementNeedsError, "[]byte") %} {
    w = basictl.NatWrite(w, uint32(len(vec)))
    for _, elem := range vec {
        {%s= tuple.element.t.TypeWritingCode(bytesVersion, directImports, tuple.wr.ins, "elem", tuple.element.Bare(), formatNatArgs(nil, tuple.element.natArgs), false, false, writeElementNeedsError) %}
    }
    {%- if writeElementNeedsError -%}
    return w, nil
    {%- else -%}
    return w
    {%- endif -%}
}
{%- if tuple.wr.gen.options.GenerateTL2 -%}

func {%s= goName %}CalculateLayout(sizes []int, vec *{%s= typeString %} {%s= natDecl %}) []int {
    sizePosition := len(sizes)
    sizes = append(sizes, 0)

    for i := 0; i < len(*vec); i++ {
        {%- if tuple.element.t.trw.doesCalculateLayoutUseObject() -%}
        elem := (*vec)[i]
        {%- endif -%}
        currentPosition := len(sizes)
        {%s= tuple.element.t.CalculateLayout(bytesVersion, "sizes", "elem", false, tuple.wr.ins, false, formatNatArgs(nil, tuple.element.natArgs)) %}
        sizes[sizePosition] += sizes[currentPosition]
        {%- if tuple.element.t.trw.isSizeWrittenInData() -%}
        sizes[sizePosition] += basictl.TL2CalculateSize(sizes[currentPosition])
        {%- endif -%}
    }
    return sizes
}

func {%s= goName %}InternalWriteTL2(w []byte, sizes []int, vec *{%s= typeString %} {%s= natDecl %}) ([]byte, []int) {
    currentSize := sizes[0]
    sizes = sizes[1:]

    w = basictl.TL2WriteSize(w, currentSize)
    if currentSize == 0 {
        return w, sizes
    }

    for i := 0; i < len(*vec); i++ {
        {%- if tuple.element.t.trw.doesWriteTL2UseObject(false) -%}
        elem := (*vec)[i]
        {%- endif -%}
        {%s= tuple.element.t.WriteTL2Call(bytesVersion, "sizes", "w", "elem", false, tuple.wr.ins, false, formatNatArgs(nil, tuple.element.natArgs)) %}
    }
    return w, sizes
}

{%- endif -%}

{%- if tuple.wr.gen.options.GenerateLegacyJsonRead -%}
func {%s= goName %}ReadJSONLegacy(legacyTypeNames bool, j interface{}, vec *{%s= typeString %} {%s= natDecl %}) error {
    l, _arr, err := {%s= tuple.wr.gen.InternalPrefix()%}JsonReadArray({%q= typeString %}, j)
    if err != nil {
        return err
    }
    if cap(*vec) < l {
        *vec = make([]{%s= elementTypeString %}, l)
    } else {
        *vec = (*vec)[:l]
    }
    for i := range *vec {
        {%s= tuple.element.t.TypeJSONReadingCode(bytesVersion, directImports, tuple.wr.ins, "_arr[i]", "(*vec)[i]", formatNatArgs(nil, tuple.element.natArgs), false ) %}
    }
    return nil
}

{%- endif -%}
func {%s= goName %}ReadJSON(legacyTypeNames bool, in *basictl.JsonLexer, vec *{%s= typeString %} {%s= natDecl %}) error {
    *vec = (*vec)[:cap(*vec)]
    index := 0
    if in != nil {
        in.Delim('[')
        if !in.Ok() {
            return {%s= tuple.wr.gen.InternalPrefix()%}ErrorInvalidJSON({%q= typeString %}, "expected json array")
        }
        for ;!in.IsDelim(']'); index++ {
            if len(*vec) <= index {
                var newValue {%s= elementTypeString %}
                *vec = append(*vec, newValue)
                *vec = (*vec)[:cap(*vec)]
            }
            {%s= tuple.element.t.TypeJSON2ReadingCode(bytesVersion, directImports, tuple.wr.ins, "in", "(*vec)[index]", formatNatArgs(nil, tuple.element.natArgs), false) %}
             in.WantComma()
        }
        in.Delim(']')
        if !in.Ok() {
            return {%s= tuple.wr.gen.InternalPrefix()%}ErrorInvalidJSON({%q= typeString %}, "expected json array's end")
        }
    }
    *vec = (*vec)[:index]
    return nil
}

func {%s= goName %}WriteJSON(w []byte, vec {%s= typeString %} {%s= natDecl %}) {%s= wrapWithError(writeElementNeedsError, "[]byte") %} {
    return {%s= goName %}WriteJSONOpt(true, false, w, vec{%s= natCall %})
}
func {%s= goName %}WriteJSONOpt(newTypeNames bool, short bool, w []byte, vec {%s= typeString %} {%s= natDecl %}) {%s= wrapWithError(writeElementNeedsError, "[]byte") %} {
    w = append(w, '[')
    for _, elem := range vec {
        w = basictl.JSONAddCommaIfNeeded(w)
        {%s= tuple.element.t.TypeJSONWritingCode(bytesVersion, directImports, tuple.wr.ins, "elem", formatNatArgs(nil, tuple.element.natArgs), false, writeElementNeedsError) %}
    }
    {%- if writeElementNeedsError -%}
    return append(w, ']'), nil
    {%- else -%}
    return append(w, ']')
    {%- endif -%}
}

        {%- case tuple.dynamicSize -%}
            {%- if tuple.wr.gen.options.GenerateRandomCode -%}
func {%s= goName %}FillRandom(rg *basictl.RandGenerator, vec *{%s= typeString %} {%s= natDecl %}) {
    rg.IncreaseDepth()
    *vec = make([]{%s= elementTypeString %}, nat_n)
    for i := range *vec {
        {%s= tuple.element.t.TypeRandomCode(bytesVersion, directImports, tuple.wr.ins, "(*vec)[i]", formatNatArgs(nil, tuple.element.natArgs), false) %}
    }
    rg.DecreaseDepth()
}
            {%- endif -%}

func {%s= goName %}Read(w []byte, vec *{%s= typeString %} {%s= natDecl %}) (_ []byte, err error) {
    {%- if tuple.wr.gen.options.UseCheckLengthSanity -%}
    if err = basictl.CheckLengthSanity(w, nat_n, 4); err != nil {
        return w, err
    }
    {%- endif -%}
    if uint32(cap(*vec)) < nat_n {
        *vec = make([]{%s= elementTypeString %}, nat_n)
    } else {
        *vec = (*vec)[:nat_n]
    }
    for i := range *vec {
        {%s= tuple.element.t.TypeReadingCode(bytesVersion, directImports, tuple.wr.ins, "(*vec)[i]", tuple.element.Bare(), formatNatArgs(nil, tuple.element.natArgs), false, false) %}
    }
    return w, nil
}

func {%s= goName %}Write(w []byte, vec {%s= typeString %} {%s= natDecl %}) (_ []byte, err error) {
    if uint32(len(vec)) != nat_n {
        return w, {%s= tuple.wr.gen.InternalPrefix()%}ErrorWrongSequenceLength({%q= typeString %}, len(vec), nat_n)
    }
    for _, elem := range vec {
        {%s= tuple.element.t.TypeWritingCode(bytesVersion, directImports, tuple.wr.ins, "elem", tuple.element.Bare(), formatNatArgs(nil, tuple.element.natArgs), false, false, writeElementNeedsError) %}
    }
    return w, nil
}
{%- if tuple.wr.gen.options.GenerateTL2 -%}

func {%s= goName %}CalculateLayout(sizes []int, vec *{%s= typeString %} {%s= natDecl %}) []int {
    sizePosition := len(sizes)
    sizes = append(sizes, 0)

    for i := 0; i < len(*vec); i++ {
        {%- if tuple.element.t.trw.doesCalculateLayoutUseObject() -%}
        elem := (*vec)[i]
        {%- endif -%}
        currentPosition := len(sizes)
        {%s= tuple.element.t.CalculateLayout(bytesVersion, "sizes", "elem", false, tuple.wr.ins, false, formatNatArgs(nil, tuple.element.natArgs)) %}
        sizes[sizePosition] += sizes[currentPosition]
        {%- if tuple.element.t.trw.isSizeWrittenInData() -%}
        sizes[sizePosition] += basictl.TL2CalculateSize(sizes[currentPosition])
        {%- endif -%}
    }
    return sizes
}

func {%s= goName %}InternalWriteTL2(w []byte, sizes []int, vec *{%s= typeString %} {%s= natDecl %}) ([]byte, []int) {
    currentSize := sizes[0]
    sizes = sizes[1:]

    w = basictl.TL2WriteSize(w, currentSize)
    if currentSize == 0 {
        return w, sizes
    }

    for i := 0; i < len(*vec); i++ {
        {%- if tuple.element.t.trw.doesWriteTL2UseObject(false) -%}
        elem := (*vec)[i]
        {%- endif -%}
        {%s= tuple.element.t.WriteTL2Call(bytesVersion, "sizes", "w", "elem", false, tuple.wr.ins, false, formatNatArgs(nil, tuple.element.natArgs)) %}
    }
    return w, sizes
}

{%- endif -%}
{%- if tuple.wr.gen.options.GenerateLegacyJsonRead -%}
func {%s= goName %}ReadJSONLegacy(legacyTypeNames bool, j interface{}, vec *{%s= typeString %} {%s= natDecl %}) error {
    _, _arr, err := {%s= tuple.wr.gen.InternalPrefix()%}JsonReadArrayFixedSize({%q= typeString %}, j, nat_n)
    if err != nil {
        return err
    }
    if uint32(cap(*vec)) < nat_n {
        *vec = make([]{%s= elementTypeString %}, nat_n)
    } else {
        *vec = (*vec)[:nat_n]
    }
    for i := range *vec {
        {%s= tuple.element.t.TypeJSONReadingCode(bytesVersion, directImports, tuple.wr.ins, "_arr[i]", "(*vec)[i]", formatNatArgs(nil, tuple.element.natArgs), false) %}
    }
    return nil
}

{%- endif -%}
func {%s= goName %}ReadJSON(legacyTypeNames bool, in *basictl.JsonLexer, vec *{%s= typeString %} {%s= natDecl %}) error {
    if uint32(cap(*vec)) < nat_n {
        *vec = make([]{%s= elementTypeString %}, nat_n)
    } else {
        *vec = (*vec)[:nat_n]
    }
    index := 0
    if in != nil {
        in.Delim('[')
        if !in.Ok() {
            return {%s= tuple.wr.gen.InternalPrefix()%}ErrorInvalidJSON({%q= typeString %}, "expected json array")
        }
        for ;!in.IsDelim(']'); index++ {
            if nat_n <= uint32(index) {
                return {%s= tuple.wr.gen.InternalPrefix()%}ErrorInvalidJSON({%q= typeString %}, "array is longer than expected")
            }
            {%s= tuple.element.t.TypeJSON2ReadingCode(bytesVersion, directImports, tuple.wr.ins, "in", "(*vec)[index]", formatNatArgs(nil, tuple.element.natArgs), false) %}
             in.WantComma()
        }
        in.Delim(']')
        if !in.Ok() {
            return {%s= tuple.wr.gen.InternalPrefix()%}ErrorInvalidJSON({%q= typeString %}, "expected json array's end")
        }
    }
    if uint32(index) != nat_n {
        return {%s= tuple.wr.gen.InternalPrefix()%}ErrorWrongSequenceLength({%q= typeString %}, index, nat_n)
    }
    return nil
}

func {%s= goName %}WriteJSON(w []byte, vec {%s= typeString %} {%s= natDecl %}) (_ []byte, err error) {
    return {%s= goName %}WriteJSONOpt(true, false, w, vec{%s= natCall %})
}
func {%s= goName %}WriteJSONOpt(newTypeNames bool, short bool, w []byte, vec {%s= typeString %} {%s= natDecl %}) (_ []byte, err error) {
    if uint32(len(vec)) != nat_n {
        return w, {%s= tuple.wr.gen.InternalPrefix()%}ErrorWrongSequenceLength({%q= typeString %}, len(vec), nat_n)
    }
    w = append(w, '[')
    for _, elem := range vec {
        w = basictl.JSONAddCommaIfNeeded(w)
        {%s= tuple.element.t.TypeJSONWritingCode(bytesVersion, directImports, tuple.wr.ins, "elem", formatNatArgs(nil, tuple.element.natArgs), false, writeElementNeedsError) %}
    }
    return append(w, ']'), nil
}

        {%- default -%}
func {%s= goName %}Reset(vec *{%s= typeString %}) {
    for i := range *vec {
            {%s= tuple.element.t.TypeResettingCode(bytesVersion, directImports, tuple.wr.ins, "(*vec)[i]", false) %}
    }
}

            {%- if tuple.wr.gen.options.GenerateRandomCode -%}
func {%s= goName %}FillRandom(rg *basictl.RandGenerator, vec *{%s= typeString %} {%s= natDecl %}) {
    rg.IncreaseDepth()
    for i := range *vec {
        {%s= tuple.element.t.TypeRandomCode(bytesVersion, directImports, tuple.wr.ins, "(*vec)[i]", formatNatArgs(nil, tuple.element.natArgs), false) %}
    }
    rg.DecreaseDepth()
}
            {%- endif -%}

func {%s= goName %}Read(w []byte, vec *{%s= typeString %} {%s= natDecl %}) (_ []byte, err error) {
    for i := range *vec {
        {%s= tuple.element.t.TypeReadingCode(bytesVersion, directImports, tuple.wr.ins, "(*vec)[i]", tuple.element.Bare(), formatNatArgs(nil, tuple.element.natArgs), false, false) %}
    }
    return w, nil
}

func {%s= goName %}Write(w []byte, vec *{%s= typeString %} {%s= natDecl %}) {%s= wrapWithError(writeElementNeedsError, "[]byte") %} {
    for _, elem := range *vec {
        {%s= tuple.element.t.TypeWritingCode(bytesVersion, directImports, tuple.wr.ins, "elem", tuple.element.Bare(), formatNatArgs(nil, tuple.element.natArgs), false, false, writeElementNeedsError) %}
    }
    {%- if writeElementNeedsError -%}
    return w, nil
    {%- else -%}
    return w
    {%- endif -%}
}
{%- if tuple.wr.gen.options.GenerateTL2 -%}

func {%s= goName %}CalculateLayout(sizes []int, vec *{%s= typeString %} {%s= natDecl %}) []int {
    sizePosition := len(sizes)
    sizes = append(sizes, 0)

    for i := 0; i < len(*vec); i++ {
        {%- if tuple.element.t.trw.doesCalculateLayoutUseObject() -%}
        elem := (*vec)[i]
        {%- endif -%}
        currentPosition := len(sizes)
        {%s= tuple.element.t.CalculateLayout(bytesVersion, "sizes", "elem", false, tuple.wr.ins, false, formatNatArgs(nil, tuple.element.natArgs)) %}
        sizes[sizePosition] += sizes[currentPosition]
        {%- if tuple.element.t.trw.isSizeWrittenInData() -%}
        sizes[sizePosition] += basictl.TL2CalculateSize(sizes[currentPosition])
        {%- endif -%}
    }
    return sizes
}

func {%s= goName %}InternalWriteTL2(w []byte, sizes []int, vec *{%s= typeString %} {%s= natDecl %}) ([]byte, []int) {
    currentSize := sizes[0]
    sizes = sizes[1:]

    w = basictl.TL2WriteSize(w, currentSize)
    if currentSize == 0 {
        return w, sizes
    }

    for i := 0; i < len(*vec); i++ {
        {%- if tuple.element.t.trw.doesWriteTL2UseObject(false) -%}
        elem := (*vec)[i]
        {%- endif -%}
        {%s= tuple.element.t.WriteTL2Call(bytesVersion, "sizes", "w", "elem", false, tuple.wr.ins, false, formatNatArgs(nil, tuple.element.natArgs)) %}
    }
    return w, sizes
}
{%- endif -%}

{%- if tuple.wr.gen.options.GenerateLegacyJsonRead -%}
func {%s= goName %}ReadJSONLegacy(legacyTypeNames bool, j interface{}, vec *{%s= typeString %} {%s= natDecl %}) error {
    _, _arr, err := {%s= tuple.wr.gen.InternalPrefix()%}JsonReadArrayFixedSize({%q= typeString %}, j, {%v tuple.size %})
    if err != nil {
        return err
    }
    for i := range *vec {
        {%s= tuple.element.t.TypeJSONReadingCode(bytesVersion, directImports, tuple.wr.ins, "_arr[i]", "(*vec)[i]", formatNatArgs(nil, tuple.element.natArgs), false) %}
    }
    return nil
}

{%- endif -%}
func {%s= goName %}ReadJSON(legacyTypeNames bool, in *basictl.JsonLexer, vec *{%s= typeString %} {%s= natDecl %}) error {
    index := 0
    if in != nil {
        in.Delim('[')
        if !in.Ok() {
            return {%s= tuple.wr.gen.InternalPrefix()%}ErrorInvalidJSON({%q= typeString %}, "expected json array")
        }
        for ;!in.IsDelim(']'); index++ {
            if index == {%v tuple.size %} {
                return {%s= tuple.wr.gen.InternalPrefix()%}ErrorWrongSequenceLength({%q= typeString %}, index + 1, {%v tuple.size %})
            }
            {%s= tuple.element.t.TypeJSON2ReadingCode(bytesVersion, directImports, tuple.wr.ins, "in", "(*vec)[index]", formatNatArgs(nil, tuple.element.natArgs), false) %}
            in.WantComma()
        }
        in.Delim(']')
        if !in.Ok() {
            return {%s= tuple.wr.gen.InternalPrefix()%}ErrorInvalidJSON({%q= typeString %}, "expected json array's end")
        }
    }
    if index != {%v tuple.size %} {
        return {%s= tuple.wr.gen.InternalPrefix()%}ErrorWrongSequenceLength({%q= typeString %}, index + 1, {%v tuple.size %})
    }
    return nil
}

func {%s= goName %}WriteJSON(w []byte, vec *{%s= typeString %} {%s= natDecl %}) {%s= wrapWithError(writeElementNeedsError, "[]byte") %} {
    return {%s= goName %}WriteJSONOpt(true, false, w, vec{%s= natCall %})
}
func {%s= goName %}WriteJSONOpt(newTypeNames bool, short bool, w []byte, vec *{%s= typeString %} {%s= natDecl %}) {%s= wrapWithError(writeElementNeedsError, "[]byte") %} {
    w = append(w, '[')
    for _, elem := range *vec {
        w = basictl.JSONAddCommaIfNeeded(w)
        {%s= tuple.element.t.TypeJSONWritingCode(bytesVersion, directImports, tuple.wr.ins, "elem", formatNatArgs(nil, tuple.element.natArgs), false, writeElementNeedsError) %}
    }
    {%- if writeElementNeedsError -%}
    return append(w, ']'), nil
    {%- else -%}
    return append(w, ']')
    {%- endif -%}
}
    {%- endswitch -%}
{%- endfunc -%}
