/////
//
// Common Types
//
/////

// Builtin types
int ? = Int;
long ? = Long;
double ? = Double;
float ? = Float;
string ? = String;

// Boolean emulation
boolFalse = Bool;
boolTrue = Bool;

// Boolean for diagonal queries
boolStat statTrue:int statFalse:int statUnknown:int = BoolStat;

// Vector
vector {t:Type} # [t] = Vector t;
tuple {t:Type} {n:#} [t] = Tuple t n;
vectorTotal {t:Type} total_count:int vector:%(Vector t) = VectorTotal t;

statOne key:string value:string = StatOne;

left {X:Type} {Y:Type} value:X = Either X Y;
right {X:Type} {Y:Type} value:Y = Either X Y;

/////
//
// Result- (Maybe-) types
//
/////

resultFalse {t:Type} = Maybe t;
resultTrue {t:Type} result:t = Maybe t;

dictionaryField {t:Type} key:string value:t = DictionaryField t;
dictionary {t:Type} %(Vector %(DictionaryField t)) = Dictionary t;

pair {X:Type} {Y:Type} a:X b:Y = Pair X Y;

map {X:Type} {Y:Type} key:X value:Y = Map X Y;

true = True; // this can be used as void type and serialized to empty array in PHP

nonOptNat n:# xs:(Tuple int n) = NonOptNat;

rpcInvokeReqExtra#f3ef81a9
  fields_mask:            #
  query:                  fields_mask.0?%True
  sort:                   fields_mask.1?%True
  sort_reverse:           fields_mask.2?%True
  wait_binlog_pos:        fields_mask.16?long
  string_forward_keys:    fields_mask.18?%(Vector string)
  = RpcInvokeReqExtra;

service4.modifiedNewsEntry#da19832a
  object:%service4.Object
  creation_date:int
  fields_mask:# // type = (fields_mask & 3) (0 - not modified, 1 - restored, 2 - deleted)
  restoration_date:fields_mask.0?int
  deletion_date:fields_mask.1?int
  hidden_by_privacy:fields_mask.16?Bool
  = service4.ModifiedNewsEntry;

service4.object
  type:int
  joint_id:%(Vector int)
  object_id:%(Vector int)
  = service4.Object;

tasks.queueTypeSettings#561fbc09
    fields_mask:#
    is_enabled:fields_mask.0?Bool // default is false
    is_persistent:fields_mask.1?Bool // default is false
    // default priority is 10, should be in range [1..100], task with priority 100 has bigger probability to be executed than task with priority 1
    priority:fields_mask.2?int
    default_retry_time:fields_mask.3?int
    default_retry_num:fields_mask.3?int
    move_to_queue_type_on_error:fields_mask.4?string // empty string for doing nothing
    is_blocking:fields_mask.5?Bool  // default is true, you can't get task from queue_id before previous is done
    // if engine doesn't receive responseTask{Done/Retry/Failed} in timelimit, it automatically do responseTaskRetry
    timelimit:fields_mask.6?int // default is 60
    max_queue_size:fields_mask.7?int // maximum number of tasks in one queue_id, older tasks will be removed
    // limits for queues?
    // something else here
= tasks.QueueTypeSettings;

// flags is just extra int
// for example something like "data is gzip-compressed" can be stored here
// id - generated by engine, unique in engine
// scheduled_time - first timestamp when task should be done
// deadline - timestamp when task is removed, even if it's not done
// if TIME is < 3600 * 24 * 31 it is considered as relative, otherwise - absolute
tasks.task#7c23bc2c
    fields_mask:#
    // flags[0] is set if task is in progress
    // flags[1] is set if task will be retried only one more time
    // flags[0..15] are reverved for engine usage
    flags:int
    tag:%(Vector int)
    data:string
    id:fields_mask.0?long
    retries:fields_mask.1?int
    scheduled_time:fields_mask.2?int
    deadline:fields_mask.3?int
    // something else here
    = tasks.Task;

tasks.taskInfo
    type_name:string
    queue_id:%(Vector int)
    task:%tasks.task
    = tasks.TaskInfo;

tasks.queueTypeStats#e1b785f2
    fields_mask:#
    waiting_size:fields_mask.0?long
    scheduled_size:fields_mask.1?long
    in_progress_size:fields_mask.2?long
    num_queues:fields_mask.3?int
    // something else here
    = tasks.QueueTypeStats;

tasks.queueStats#1d942543
    {fields_mask:#}
    waiting_size:fields_mask.0?int
    scheduled_size:fields_mask.1?int
    in_progress_size:fields_mask.2?int
    = tasks.QueueStats fields_mask;

tasks.queueTypeInfo
    type_name:string
    settings:%tasks.QueueTypeSettings
    stats:%tasks.queueTypeStats
    = tasks.QueueTypeInfo;

// If days_of_week and days are specified then if ANY of them is correct, task will be added to queue
tasks.cronTime#d4177d7f
    fields_mask:#
    seconds:fields_mask.0?%(Vector int)       // [0..59]
    minutes:fields_mask.1?%(Vector int)       // [0..59]
    hours:fields_mask.2?%(Vector int)         // [0..23]
    days_of_week:fields_mask.3?%(Vector int)  // [0..7], 0 - Sunday, 6 - Saturday, 7 - Sunday
    days:fields_mask.4?%(Vector int)          // [1..31]
    months:fields_mask.5?%(Vector int)        // [1..12]
    = tasks.CronTime;

tasks.fullFilledCron#d4177d7e
    fields_mask:#
    a0:fields_mask.0?int
    a1:fields_mask.1?int
    a2:fields_mask.2?int
    a3:fields_mask.3?int
    a4:fields_mask.4?int
    a5:fields_mask.5?int
    a6:fields_mask.6?int
    a7:fields_mask.7?int
    a8:fields_mask.8?int
    a9:fields_mask.9?int
    a10:fields_mask.10?int
    a11:fields_mask.11?int
    a12:fields_mask.12?int
    a13:fields_mask.13?int
    a14:fields_mask.14?int
    a15:fields_mask.15?int
    a16:fields_mask.16?int
    a17:fields_mask.17?int
    a18:fields_mask.18?int
    a19:fields_mask.19?int
    a20:fields_mask.20?int
    a21:fields_mask.21?int
    a22:fields_mask.22?int
    a23:fields_mask.23?int
    a24:fields_mask.24?int
    a25:fields_mask.25?int
    a26:fields_mask.26?int
    a27:fields_mask.27?int
    a28:fields_mask.28?int
    a29:fields_mask.29?int
    a30:fields_mask.30?int
    a31:fields_mask.31?int
    a32:fields_mask.31?int
    = tasks.FullFilledCron;

tasks.cronTask
    type_name:string
    queue_id:%(Vector int)
    task:%tasks.Task
    time:%tasks.CronTime
    = tasks.CronTask;

tasks.cronTaskWithId
    id:int
    next_time:int
    task:%tasks.cronTask
    = tasks.CronTaskWithId;

tasks.taskStatusNotCurrentlyInEngine = tasks.TaskStatus;
tasks.taskStatusScheduled = tasks.TaskStatus;
tasks.taskStatusWaiting = tasks.TaskStatus;
tasks.taskStatusInProgress = tasks.TaskStatus;

myTuple {n:#} (Tuple Int n) = MyTuple n;
myInt val1:Int = MyValue;
myString val2:String = MyValue;
myDictOfInt %(Dictionary int) = MyDictOfInt;
myDouble Double = MyDouble;
myMcValue x:service1.Value = MyMcValue;
myAnonMcValue service1.Value = MyAnonMcValue;
myMcValueVector xs:%(Vector service1.Value) = MyMcValueVector;
myMcValueTuple xs:%(Tuple service1.Value 3) = MyMcValueTuple;
myTwoDicts a:%(Dictionary int) b:%(Dictionary int) = MyTwoDicts;

myMaybe1 (Maybe %(MyTuple 10)) = MyMaybe1;
myMaybe2 (Maybe (%MyTuple 10)) = MyMaybe2;

myBoxedVectorSlice data:(Vector Int) = MyBoxedVectorSlice;
myBoxedTupleSlice n:# data:(Tuple Int n) = MyBoxedTupleSlice;
myBoxedArray data:(Tuple Int 2) = MyBoxedArray;

integer value:int = Integer;
benchObject xs:%(Vector int) ys:%(Vector %Integer) = BenchObject;

service1.not_found = service1.Value;
// generally, service1.strvalue is returned in every case, except for functions `service1.incr`, `service1.decr`,
// in which service1.longvalue is returned
service1.strvalue value:string flags:int = service1.Value;
service1.longvalue value:long flags:int = service1.Value;
service1.strvalueWithTime value:string flags:int modificationTime:int = service1.Value;
service1.longvalueWithTime value:long flags:int modificationTime:int = service1.Value;

service1.keysStat
	start_time:int //Timestamp of last enable request
	keys_tops:%(Dictionary %(Dictionary int)) //Possible tops: send_bytes, receive_bytes, read_count, write_count
	= service1.KeysStat;

service5.emptyOutput = service5.Output;
service5.stringOutput http_code:int response:string = service5.Output;

service5.params#12ae5cb5 fields_mask:#
               max_execution_speed:fields_mask.0?int max_execution_speed_bytes:fields_mask.1?int = service5.Params;


service6.error code:int = service6.Error;

service6.findResultRow x:int = service6.FindResultRow;
service6.findWithBoundsResult x:int = service6.FindWithBoundsResult;

pkg2.foo x:int = pkg2.Foo;
pkg2.t1 x:pkg2.Foo = pkg2.T1;
pkg2.t2 %pkg2.Foo = pkg2.T2;

service3.productStatsOld#6319810b
    type:int
    count_new:int
    count_total:int
    count_scheduled:int
    next_scheduled_at:int
    = service3.ProductStatsOld;

service3.productStats#49c1d0a1 {fields_mask:#}
    type:int
    count_new:fields_mask.0?int
    count_total:fields_mask.1?int
    count_scheduled:fields_mask.2?int
    next_scheduled_at:fields_mask.3?int
    last_created_at:fields_mask.4?int
    = service3.ProductStats fields_mask;

service3.product#461f4ce2 {mode:#}
    type:int
    id:%(Vector int)
    info:%(Vector int)
    date:int
    expiration_date:int
    removed:mode.0?Bool
    = service3.Product mode;

service3.groupRecord#8d6c22ea {mode:#}
    info:%(Vector int)
    date:int
    expiration_date:int
    removed:mode.0?Bool
    = service3.GroupRecord mode;

service3.groupedProducts {mode:#}
    type:int
    id:%(Vector int)
    group:%(VectorTotal %(service3.GroupRecord mode))
    = service3.GroupedProducts mode;

service3.groupSizeLimit type:int limit:int = service3.GroupSizeLimit;
service3.groupCountLimit types:%(Vector int) limit:int = service3.GroupCountLimit;
service3.limits default_group_size_limit:int custom_group_size_limits:%(Vector %service3.groupSizeLimit)
              default_group_count_limit:int custom_group_count_limits:%(Vector %service3.groupCountLimit)
              = service3.Limits;

antispam.pattern#04d672f2 {fields_mask:#} id:fields_mask.0?int flags:fields_mask.1?int = antispam.Pattern fields_mask;
antispam.patternFound#a7688492 ip:int uahash:int flags:int type:int text:string = antispam.PatternFull;
antispam.patternNotFound = antispam.PatternFull;

withFlags00 {flags1:#} {flags2:#} x:flags1.0?int y:flags2.0?int = WithFlags00 flags1 flags2;
withFlags01 {flags1:#} {flags2:#} x:flags1.0?int y:flags2.1?int = WithFlags01 flags1 flags2;
withFlags10 {flags1:#} {flags2:#} x:flags1.1?int y:flags2.0?int = WithFlags10 flags1 flags2;
withFlags11 {flags1:#} {flags2:#} x:flags1.1?int y:flags2.1?int = WithFlags11 flags1 flags2;

// See BACK-4784
withFloat x:float y:Float z:%Float = WithFloat;

issue3498 x:(Vector (Either %service6.Error %(Vector service6.findResultRow))) = Issue3498;

tree_stats.objectLimitValueLong = tree_stats.ObjectLimitValue;
tree_stats.objectLimitValueDouble double = tree_stats.ObjectLimitValue;

fieldConflict1 x:%Int set_x:%Int = FieldConflict1;
fieldConflict2 x:%Int setX:%Int = FieldConflict2;
fieldConflict3 x:%Int SetX:%Int = FieldConflict3;
fieldConflict4 X:%Int SetX:%Int = FieldConflict4;

---functions---

@any getMaybeIface x:service1.Value = Maybe service1.Value;

@any getNonOptNat n:# xs:(Tuple int n) = Tuple int n;

@any  service6.multiFind
  clusters:     %(Vector int)
  limit:        int
  eq_threshold: double
  = Vector (Either %service6.Error %(Vector service6.findResultRow));

@any service6.multiFindWithBounds
  clusters:     %(Vector int)
  = Vector (Either int %(Vector %service6.FindWithBoundsResult));

@any  antispam.getPattern id:int = antispam.PatternFull;

@any  get_arrays n:# a:n*[int] b:5*[int] = Tuple int 5;

@any service5.performQuery query:string = service5.Output;
@any service5.query query:string params:%service5.Params = service5.Output;
@any service5.insert table:string data:string = service5.Output;

//@any withNatParam {n:#} = MyTuple n;

@any tasks.addTask type_name:string queue_id:%(Vector int) task:%tasks.Task = Long; // id is returned

@any tasks.getQueueTypes settings_mask:# stats_mask:# = Vector %tasks.QueueTypeInfo;

@any tasks.getAnyTask = Maybe %tasks.TaskInfo;

@any tasks.getTaskFromQueue type_name:string queue_id:%(Vector int) = Maybe %tasks.TaskInfo;

@any tasks.getQueueSize type_name:string queue_id:%(Vector int) fields_mask:# local_dep:fields_mask.4?int = tasks.QueueStats fields_mask;

@any getStats x:tasks.queueTypeStats = tasks.QueueTypeStats;

@any boxedVector32 x:(Vector int) = Vector int;
@any boxedVector32BoxedElem x:(Vector Int) = Vector Int;
@any boxedVector64 x:(Vector Long) = Vector Long;
@any boxedTuple x:(Tuple int 3) = Tuple int 3;
@any boxedTupleSlice1 n:# x:(Tuple Int n) = Tuple Int n;
@any boxedTupleSlice2 x:MyBoxedTupleSlice = MyBoxedTupleSlice;
@any boxedTupleSlice3 n:# x:(Tuple %Int n) = Tuple %Int n;
@any boxedArray x:MyBoxedArray = MyBoxedArray;
@any boxedString x:String = String;
@any boxedInt x:Int = Int;

@any getFloat x:float = Float;
@any getMyValue x:MyValue = MyValue;
@any getMyDictOfInt x:MyDictOfInt = MyDictOfInt;

@any service1.set key:string flags:int delay:int value:string = Bool;
// sets value iff the key is absent
@any service1.add key:string flags:int delay:int value:string = Bool;
// sets value iff the key exists
@any service1.replace key:string flags:int delay:int value:string = Bool;
// update delay iff the key exists
@any service1.touch key:string delay:int = Bool;
// adds new entry, if it's absent
// returns *new* value anyway
@any service1.addOrGet key:string flags:int delay:int value:string = service1.Value;
// returns service1.longvalue after executing
@any service1.incr key:string value:long = service1.Value;
// returns service1.longvalue after executing
@any service1.decr key:string value:long = service1.Value;
@any service1.delete key:string = Bool;
@any service1.get key:string = service1.Value;
@any service1.exists key:string = Bool;
@any service1.addOrIncr key:string flags:int delay:int value:long = service1.Value;
// sets value iff the current value is casToken
@any service1.cas key:string flags:int delay:int casToken:string newValue:string = Bool;
// appends newValue to current value
// assigns newValue, if current key is absent
@any service1.append key:string flags:int delay:int suffix:string = Bool;

// Next two functions will be removed. Do not use them
@any service1.setOrIncr key:string flags:int delay:int value:long = service1.Value;
@any service1.replaceOrIncr key:string flags:int delay:int value:long = service1.Value;

// All wildcard quries are parsed by hand in php. Be carefull changing them
// returns all entries. The prefix is removed from keys
@any service1.getWildcard prefix:string = Vector %(Map string string);
@any service1.getWildcardDict prefix:string = Dictionary string;
// list of keys
@any service1.getWildcardList prefix:string = Vector string;
@any service1.getWildcardWithFlags prefix:string = Dictionary service1.Value;

// -1 for no expire, time before key is expired, false for no key
@any service1.getExpireTime key:string = Maybe int;

// Enable stat for period specified.
// Result stored till engine restart.
// It is allowed to store maximum 5 different periods.
// Returns false if there are maximum periods stored.
// Subsequent request with already stored period resets all stat of this period.
// period - 1..86400
@any service1.enableKeysStat period:int = Bool;
// Disable and delete stored stat for period specified.
// period - 1..86400, 0 - all periods
@any service1.disableKeysStat period:int = Bool;
// period - 1..86400
@any service1.getKeysStat period:int = Maybe %service1.KeysStat;
@any service1.getKeysStatPeriods = Vector int;

@any service1.disableExpiration prefix:string = Bool;
@any service1.enableExpiration prefix:string = Bool;

@any unique.stringToInt key:string = Int;
@any unique.get key:string = Maybe int;

@any getDouble x:Double = Double;
@any getMyDouble x:%MyDouble = MyDouble;

@any service3.createProduct user_id:int type:int id:%(Vector int) info:%(Vector int) date:int expiration_date:int = Bool;
@any service3.deleteProduct user_id:int type:int id:%(Vector int) info:%(Vector int) = Bool;
@any service3.restoreProduct user_id:int type:int id:%(Vector int) info:%(Vector int) = Bool;

@any service3.deleteGroupedProducts user_id:int type:int id:%(Vector int) start_date:int end_date:int = Bool;
@any service3.restoreGroupedProducts user_id:int type:int id:%(Vector int) start_date:int end_date:int = Bool;
@any service3.deleteAllProducts user_id:int type:int start_date:int end_date:int = Bool;
@any service3.restoreAllProducts user_id:int type:int start_date:int end_date:int = Bool;

@any service3.setLastVisitTimestamp user_id:int timestamp:int = Bool;
@any service3.getLastVisitTimestamp user_id:int = Maybe int;

@any service3.getProductStats#261f6898 user_id:int types:%(Vector int) = Maybe %(Vector %service3.ProductStatsOld);

@any service3.getScheduledProducts#f53ad7bd user_id:int types:%(Vector int) = Maybe %(Vector %(service3.Product 0));

@any service3.getProducts#eb306233
    user_id:int
    mode:#
    types:%(Vector int)
    start_date:int end_date:int
    offset:int limit:int
    allowed_info0:%(Vector int) // be ignored if it is empty
    = Maybe %(Vector %(service3.Product mode));

@any service3.setLimits limits:%service3.Limits = BoolStat;
@any service3.getLimits = service3.Limits;

//! common/tl/schemas/service2.tl

---types---
service2.objectId {objectIdLength:#} id:%(Tuple int objectIdLength) = service2.ObjectId objectIdLength;

service2.counterSet {intCountersNum:#} {floatCountersNum:#}
                         intCounters:%(Tuple int intCountersNum)
                         floatCounters:%(Tuple double floatCountersNum)
                       = service2.CounterSet intCountersNum floatCountersNum;

service2.deltaSet {objectIdLength:#} {intCountersNum:#} {floatCountersNum:#}
                       id:%(service2.ObjectId objectIdLength)
                       counters:%(service2.CounterSet intCountersNum floatCountersNum)
                     = service2.DeltaSet objectIdLength intCountersNum floatCountersNum;

---functions---
@write service2.set objectIdLength:# intCountersNum:# floatCountersNum:#
                         intCounters:%(Tuple int intCountersNum)
                         floatCounters:%(Tuple int floatCountersNum)
                         newValues:%(service2.DeltaSet objectIdLength intCountersNum floatCountersNum)
                       = True;

@readwrite service2.addOrIncrMany objectIdLength:# intCountersNum:# floatCountersNum:# objectsNum:#
                                       intCounters:%(Tuple int intCountersNum)
                                       floatCounters:%(Tuple int floatCountersNum)
                                       deltas:%(Tuple %(service2.DeltaSet objectIdLength intCountersNum floatCountersNum) objectsNum)
                                     = Tuple %(service2.CounterSet intCountersNum floatCountersNum) objectsNum;

@write service2.setObjectTtl objectIdLength:# objectId:%(service2.ObjectId objectIdLength) ttl:int = True;

