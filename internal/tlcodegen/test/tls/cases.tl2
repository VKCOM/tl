// BASE TYPES
int <=> int;
long <=> long;
int32 <=> int;
int64 <=> long;
string <=> string;
vector<t:Type> <=> []t;
tuple<t:Type> <=> []t;
@tl2ext tuple_N<t:Type,n:#> <=> [n]t;
dictionaryField<t:Type> = key:string value:t;
dictionary<t:Type> <=> vector<dictionaryField<t>>;
dictionaryFieldAny<k:Type,v:Type> = key:k value:v;
dictionaryAny<k:Type,v:Type> <=> []dictionaryFieldAny<k,v>;
true = ;
@tl2Maybe maybe<t:Type> = 
	// tlgen:tl1name:"resultFalse"
	| ResultFalse
	// tlgen:tl1name:"resultTrue"
	| ResultTrue t;
pair<x:Type,y:Type> = x:x y:y;
// BLOCK: TEST RECURSIVE TYPES
cases.myCycle1 = fields_mask:uint32 a?:cases.myCycle2;
cases.myCycle2 = fields_mask:uint32 a?:cases.myCycle3;
cases.myCycle3 = fields_mask:uint32 a?:cases.myCycle1;
// BLOCK: TEST BRACKETS (arrays, vectors, dicitinaries etc.)
cases.testArray = n:uint32 arr:[]int;
cases.testVector = arr:vector<int>;
cases.testTuple = tpl:tuple_N<int,4>;
// will be map
cases.testDictString = dict:dictionary<int>;
// will be map
cases.testDictInt = dict:dictionaryAny<int,int>;
// will be array of tuples
cases.testDictAny = dict:dictionaryAny<double,int>;
// BLOCK: TEST UNIONS
cases.testMaybe = value:maybe<int>;
cases.testUnion = 
	// tlgen:tl1name:"cases.testUnion1"
	| TestUnion1
		value:int
	// tlgen:tl1name:"cases.testUnion2"
	| TestUnion2
		value:string
	// tlgen:tl1name:"cases.testUnion3"
	| TestUnion3 int
	// tlgen:tl1name:"cases.testUnion4"
	| TestUnion4 string;
cases.testUnionContainer = value:cases.testUnion;
cases.testEnum = 
	// tlgen:tl1name:"cases.testEnum1"
	| TestEnum1
	// tlgen:tl1name:"cases.testEnum2"
	| TestEnum2
	// tlgen:tl1name:"cases.testEnum3"
	| TestEnum3;
cases.testEnumContainer = value:cases.testEnum;
// BLOCK: TEST FIELD MASKS
cases.testRecursiveFieldmask = f0:uint32 f1?:uint32 f2?:uint32 t1:bool t2:bool t3:bool;
cases.testLocalFieldmask = f1:uint32 f2?:uint32 f3:bool f4:bool;
cases.testOutFieldMask = f1?:uint32 f2:bool f3:[]int;
cases.testOutFieldMaskContainer = f:uint32 inner:cases.testOutFieldMask;
cases.testBeforeReadBitValidation = n:uint32 a?:[]int b?:[]int;
cases.testAllPossibleFieldConfigs = 
	local:uint32
	// no fieldmask, no nat dependencies in type
	f00:int
	// no fieldmask, true type
	f01:true
	// no fieldmask, have some local nat dependencies in type
	f02:[]int
	// no fieldmask, have only external nat dependencies in type
	f03:[]int
	// local fieldmask, no nat dependencies in type
	f10?:int
	f11:bool
	// local fieldmask, have some local nat dependencies in type
	f12?:[]int
	// local fieldmask, have only external nat dependencies in type
	f13?:[]int
	// outer fieldmask, no nat dependencies in type
	f20?:int
	f21:bool
	// outer fieldmask, have some local nat dependencies in type
	f22?:[]int
	// outer fieldmask, have only external nat dependencies in type
	f23?:[]int;
cases.testAllPossibleFieldConfigsContainer = outer:uint32 value:cases.testAllPossibleFieldConfigs;
// BLOCK: TEST INPLACING ARGUMENTS
cases.testInplaceStructArgs = a1:uint32 a2:uint32 a3:uint32 arg:cases.inplace1<int>;
cases.testInplaceStructArgs2 = a1:uint32 a2:uint32 a3:uint32 arg:cases.inplace1<pair<tuple<int>,tuple<int>>>;
cases.inplace1<x:Type> = value:cases.inplace2<x>;
cases.inplace2<x:Type> = value:cases.inplace3<tuple_N<x,2>>;
cases.inplace3<x:Type> = value:pair<tuple<x>,tuple<x>>;
// BLOCK: Bytes vesrion
cases_bytes.testArray = n:uint32 arr:[]string;
cases_bytes.testVector = arr:vector<string>;
cases_bytes.testTuple = tpl:tuple_N<string,4>;
// will be map
cases_bytes.testDictStringString = dict:dictionary<string>;
// will be map
cases_bytes.testDictString = dict:dictionary<int>;
// will be map
cases_bytes.testDictInt = dict:dictionaryAny<int,int>;
// will be array of tuples
cases_bytes.testDictAny = dict:dictionaryAny<double,int>;
cases_bytes.testEnum = 
	// tlgen:tl1name:"cases_bytes.testEnum1"
	| TestEnum1
	// tlgen:tl1name:"cases_bytes.testEnum2"
	| TestEnum2
	// tlgen:tl1name:"cases_bytes.testEnum3"
	| TestEnum3;
cases_bytes.testEnumContainer = value:cases.testEnum;
// BLOCK: BENCHMARKS
// We store xxh3 components in LE endianness, as common in TL
benchmarks.vruHash = low:long high:long;
benchmarks.vruPosition = 
	fields_mask:uint32
	commit_bit:bool
	meta_block:bool
	split_payload:bool
	rotation_block:bool
	canonical_hash:bool
	// Motivation for storing it in each block - when random seeking into the middle of file, we must be sure without scanning from beginning
	payload_offset:long
	// Only for debug, not used in any logic
	block_time_nano:long
	hash:benchmarks.vruHash
	file_offset:long
	// incremented after each block.
	seq_number?:long;
benchmarks.vrutoyTopLevelUnion = 
	// tlgen:tl1name:"benchmarks.vrutoytopLevelUnionBig"
	| VrutoytopLevelUnionBig
		next_positions:vector<benchmarks.vruPosition>
	// tlgen:tl1name:"benchmarks.vrutoytopLevelUnionEmpty"
	| VrutoytopLevelUnionEmpty;
benchmarks.vrutoyTopLevelContainer = value:benchmarks.vrutoyTopLevelUnion;
benchmarks.vrutoyPositions = next_positions:[]benchmarks.vruPosition;
benchmarks.vrutoyTopLevelContainerWithDependency = n:uint32 value:benchmarks.vrutoyPositions;
casesTL2.testObject = 
	n:uint32
	f1:bool
	f2:bool
	f3:vector<bool>
	f4:benchmarks.vrutoyPositions
	f5?:legacy_bool
	f6:vector<benchmarks.vrutoyTopLevelUnion>
	f7?:vector<true>;
casesTL2.testVectorBool = x:vector<bool>;
casesTL2.testArrayFixedBool = a1:[1]bool a2:[0]bool a3:[7]bool a4:[8]bool a5:[11]bool a6:[16]bool;
casesTL2.testArrayFlexibleBool = n:uint32 arr:[]bool;
casesTL2.testFixedParam = x:casesTL2.testObjectWithParam_N<4>;
@tl2ext casesTL2.testObjectWithParam_N<n:#> = x?:int y:[n]int;
casesTL2.testParamsGeneration = 
	n1:uint32
	n2:uint32
	x1:casesTL2.testObjectWithMuiltiParams_N_M<4,1>
	x2:casesTL2.testObjectWithMuiltiParams_M<2>
	x3:casesTL2.testObjectWithMuiltiParams_N<3>
	x4:casesTL2.testObjectWithMuiltiParams;
casesTL2.testObjectWithMuiltiParams = f1?:[]int f2?:[]int;
@tl2ext casesTL2.testObjectWithMuiltiParams_N<n:#> = f1?:[n]int f2?:[]int;
@tl2ext casesTL2.testObjectWithMuiltiParams_M<m:#> = f1?:[]int f2?:[m]int;
@tl2ext casesTL2.testObjectWithMuiltiParams_N_M<n:#,m:#> = f1?:[n]int f2?:[m]int;
casesGo.testNames = write:int read:int;
@read casesTL2.testFunctionNoDep1#1b8b9feb x:int => ;
@read casesTL2.testFunctionNoDep2#0a2c0bf9 x:int => ;
@read casesTL2.testFunctionNoDep3#f020849b x:int => ;
@read casesTL2.testFunctionNoDep4#5a933a50 x:int => ;
@read casesTL2.testFunctionNoDep5#2b47b925 x:int => ;
@read casesTL2.testFunctionWithDep1#b6c63b07 n:uint32 => ;
@read casesTL2.testFunctionWithDep2#9d44a2fd n:uint32 => ;
