// Copyright 2025 V Kontakte LLC
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Code generated by vktl/cmd/tlgen2; DO NOT EDIT.
package internal

import (
	"github.com/vkcom/tl/pkg/basictl"
)

var _ = basictl.NatWrite

type CurlRequest struct {
	FieldMask         uint32
	Method            string
	Url               string
	Headers           map[string]string // Conditional: item.FieldMask.0
	Body              string            // Conditional: item.FieldMask.1
	Timeout           int32             // Conditional: item.FieldMask.2
	TimeoutConnection int32             // Conditional: item.FieldMask.3
	MaxRedirs         int32             // Conditional: item.FieldMask.4
	SslVersion        int32             // Conditional: item.FieldMask.5
	ResolveIpv        int32             // Conditional: item.FieldMask.6
	HttpProxy         string            // Conditional: item.FieldMask.7
	Limit             int32             // Conditional: item.FieldMask.8
	Route             string            // Conditional: item.FieldMask.9
	Version           int32             // Conditional: item.FieldMask.10
	Origin            string            // Conditional: item.FieldMask.11
	TlsCert           string            // Conditional: item.FieldMask.12
	TlsCertPk         string            // Conditional: item.FieldMask.13
	tl2mask0          byte
	tl2mask1          byte
}

func (CurlRequest) TLName() string { return "curl.request" }
func (CurlRequest) TLTag() uint32  { return 0x3f5a4651 }

func (item *CurlRequest) SetHeaders(v map[string]string) {
	item.Headers = v
	item.FieldMask |= 1 << 0
	item.tl2mask0 |= 1
}
func (item *CurlRequest) ClearHeaders() {
	BuiltinVectorDictionaryFieldStringReset(item.Headers)
	item.FieldMask &^= 1 << 0
	item.tl2mask0 &^= 1
}
func (item *CurlRequest) IsSetHeaders() bool { return item.tl2mask0&1 != 0 }

func (item *CurlRequest) SetBody(v string) {
	item.Body = v
	item.FieldMask |= 1 << 1
	item.tl2mask0 |= 2
}
func (item *CurlRequest) ClearBody() {
	item.Body = ""
	item.FieldMask &^= 1 << 1
	item.tl2mask0 &^= 2
}
func (item *CurlRequest) IsSetBody() bool { return item.tl2mask0&2 != 0 }

func (item *CurlRequest) SetTimeout(v int32) {
	item.Timeout = v
	item.FieldMask |= 1 << 2
	item.tl2mask0 |= 4
}
func (item *CurlRequest) ClearTimeout() {
	item.Timeout = 0
	item.FieldMask &^= 1 << 2
	item.tl2mask0 &^= 4
}
func (item *CurlRequest) IsSetTimeout() bool { return item.tl2mask0&4 != 0 }

func (item *CurlRequest) SetTimeoutConnection(v int32) {
	item.TimeoutConnection = v
	item.FieldMask |= 1 << 3
	item.tl2mask0 |= 8
}
func (item *CurlRequest) ClearTimeoutConnection() {
	item.TimeoutConnection = 0
	item.FieldMask &^= 1 << 3
	item.tl2mask0 &^= 8
}
func (item *CurlRequest) IsSetTimeoutConnection() bool { return item.tl2mask0&8 != 0 }

func (item *CurlRequest) SetMaxRedirs(v int32) {
	item.MaxRedirs = v
	item.FieldMask |= 1 << 4
	item.tl2mask0 |= 16
}
func (item *CurlRequest) ClearMaxRedirs() {
	item.MaxRedirs = 0
	item.FieldMask &^= 1 << 4
	item.tl2mask0 &^= 16
}
func (item *CurlRequest) IsSetMaxRedirs() bool { return item.tl2mask0&16 != 0 }

func (item *CurlRequest) SetSslVersion(v int32) {
	item.SslVersion = v
	item.FieldMask |= 1 << 5
	item.tl2mask0 |= 32
}
func (item *CurlRequest) ClearSslVersion() {
	item.SslVersion = 0
	item.FieldMask &^= 1 << 5
	item.tl2mask0 &^= 32
}
func (item *CurlRequest) IsSetSslVersion() bool { return item.tl2mask0&32 != 0 }

func (item *CurlRequest) SetResolveIpv(v int32) {
	item.ResolveIpv = v
	item.FieldMask |= 1 << 6
	item.tl2mask0 |= 64
}
func (item *CurlRequest) ClearResolveIpv() {
	item.ResolveIpv = 0
	item.FieldMask &^= 1 << 6
	item.tl2mask0 &^= 64
}
func (item *CurlRequest) IsSetResolveIpv() bool { return item.tl2mask0&64 != 0 }

func (item *CurlRequest) SetHttpProxy(v string) {
	item.HttpProxy = v
	item.FieldMask |= 1 << 7
	item.tl2mask0 |= 128
}
func (item *CurlRequest) ClearHttpProxy() {
	item.HttpProxy = ""
	item.FieldMask &^= 1 << 7
	item.tl2mask0 &^= 128
}
func (item *CurlRequest) IsSetHttpProxy() bool { return item.tl2mask0&128 != 0 }

func (item *CurlRequest) SetLimit(v int32) {
	item.Limit = v
	item.FieldMask |= 1 << 8
	item.tl2mask1 |= 1
}
func (item *CurlRequest) ClearLimit() {
	item.Limit = 0
	item.FieldMask &^= 1 << 8
	item.tl2mask1 &^= 1
}
func (item *CurlRequest) IsSetLimit() bool { return item.tl2mask1&1 != 0 }

func (item *CurlRequest) SetRoute(v string) {
	item.Route = v
	item.FieldMask |= 1 << 9
	item.tl2mask1 |= 2
}
func (item *CurlRequest) ClearRoute() {
	item.Route = ""
	item.FieldMask &^= 1 << 9
	item.tl2mask1 &^= 2
}
func (item *CurlRequest) IsSetRoute() bool { return item.tl2mask1&2 != 0 }

func (item *CurlRequest) SetVersion(v int32) {
	item.Version = v
	item.FieldMask |= 1 << 10
	item.tl2mask1 |= 4
}
func (item *CurlRequest) ClearVersion() {
	item.Version = 0
	item.FieldMask &^= 1 << 10
	item.tl2mask1 &^= 4
}
func (item *CurlRequest) IsSetVersion() bool { return item.tl2mask1&4 != 0 }

func (item *CurlRequest) SetOrigin(v string) {
	item.Origin = v
	item.FieldMask |= 1 << 11
	item.tl2mask1 |= 8
}
func (item *CurlRequest) ClearOrigin() {
	item.Origin = ""
	item.FieldMask &^= 1 << 11
	item.tl2mask1 &^= 8
}
func (item *CurlRequest) IsSetOrigin() bool { return item.tl2mask1&8 != 0 }

func (item *CurlRequest) SetTlsCert(v string) {
	item.TlsCert = v
	item.FieldMask |= 1 << 12
	item.tl2mask1 |= 16
}
func (item *CurlRequest) ClearTlsCert() {
	item.TlsCert = ""
	item.FieldMask &^= 1 << 12
	item.tl2mask1 &^= 16
}
func (item *CurlRequest) IsSetTlsCert() bool { return item.tl2mask1&16 != 0 }

func (item *CurlRequest) SetTlsCertPk(v string) {
	item.TlsCertPk = v
	item.FieldMask |= 1 << 13
	item.tl2mask1 |= 32
}
func (item *CurlRequest) ClearTlsCertPk() {
	item.TlsCertPk = ""
	item.FieldMask &^= 1 << 13
	item.tl2mask1 &^= 32
}
func (item *CurlRequest) IsSetTlsCertPk() bool { return item.tl2mask1&32 != 0 }

func (item *CurlRequest) Reset() {
	item.FieldMask = 0
	item.Method = ""
	item.Url = ""
	BuiltinVectorDictionaryFieldStringReset(item.Headers)
	item.Body = ""
	item.Timeout = 0
	item.TimeoutConnection = 0
	item.MaxRedirs = 0
	item.SslVersion = 0
	item.ResolveIpv = 0
	item.HttpProxy = ""
	item.Limit = 0
	item.Route = ""
	item.Version = 0
	item.Origin = ""
	item.TlsCert = ""
	item.TlsCertPk = ""
	item.tl2mask0 = 0
	item.tl2mask1 = 0
}

func (item *CurlRequest) FillRandom(rg *basictl.RandGenerator) {
	item.tl2mask0 = 0
	item.tl2mask1 = 0
	item.FieldMask = basictl.RandomFieldMask(rg, 0b11111111111111)
	item.Method = basictl.RandomString(rg)
	item.Url = basictl.RandomString(rg)
	if item.FieldMask&(1<<0) != 0 {
		item.tl2mask0 |= 1
		BuiltinVectorDictionaryFieldStringFillRandom(rg, &item.Headers)
	} else {
		BuiltinVectorDictionaryFieldStringReset(item.Headers)
	}
	if item.FieldMask&(1<<1) != 0 {
		item.tl2mask0 |= 2
		item.Body = basictl.RandomString(rg)
	} else {
		item.Body = ""
	}
	if item.FieldMask&(1<<2) != 0 {
		item.tl2mask0 |= 4
		item.Timeout = basictl.RandomInt(rg)
	} else {
		item.Timeout = 0
	}
	if item.FieldMask&(1<<3) != 0 {
		item.tl2mask0 |= 8
		item.TimeoutConnection = basictl.RandomInt(rg)
	} else {
		item.TimeoutConnection = 0
	}
	if item.FieldMask&(1<<4) != 0 {
		item.tl2mask0 |= 16
		item.MaxRedirs = basictl.RandomInt(rg)
	} else {
		item.MaxRedirs = 0
	}
	if item.FieldMask&(1<<5) != 0 {
		item.tl2mask0 |= 32
		item.SslVersion = basictl.RandomInt(rg)
	} else {
		item.SslVersion = 0
	}
	if item.FieldMask&(1<<6) != 0 {
		item.tl2mask0 |= 64
		item.ResolveIpv = basictl.RandomInt(rg)
	} else {
		item.ResolveIpv = 0
	}
	if item.FieldMask&(1<<7) != 0 {
		item.tl2mask0 |= 128
		item.HttpProxy = basictl.RandomString(rg)
	} else {
		item.HttpProxy = ""
	}
	if item.FieldMask&(1<<8) != 0 {
		item.tl2mask1 |= 1
		item.Limit = basictl.RandomInt(rg)
	} else {
		item.Limit = 0
	}
	if item.FieldMask&(1<<9) != 0 {
		item.tl2mask1 |= 2
		item.Route = basictl.RandomString(rg)
	} else {
		item.Route = ""
	}
	if item.FieldMask&(1<<10) != 0 {
		item.tl2mask1 |= 4
		item.Version = basictl.RandomInt(rg)
	} else {
		item.Version = 0
	}
	if item.FieldMask&(1<<11) != 0 {
		item.tl2mask1 |= 8
		item.Origin = basictl.RandomString(rg)
	} else {
		item.Origin = ""
	}
	if item.FieldMask&(1<<12) != 0 {
		item.tl2mask1 |= 16
		item.TlsCert = basictl.RandomString(rg)
	} else {
		item.TlsCert = ""
	}
	if item.FieldMask&(1<<13) != 0 {
		item.tl2mask1 |= 32
		item.TlsCertPk = basictl.RandomString(rg)
	} else {
		item.TlsCertPk = ""
	}
}

func (item *CurlRequest) Read(w []byte) (_ []byte, err error) {
	item.tl2mask0 = 0
	item.tl2mask1 = 0
	if w, err = basictl.NatRead(w, &item.FieldMask); err != nil {
		return w, err
	}
	if w, err = basictl.StringRead(w, &item.Method); err != nil {
		return w, err
	}
	if w, err = basictl.StringRead(w, &item.Url); err != nil {
		return w, err
	}
	if item.FieldMask&(1<<0) != 0 {
		item.tl2mask0 |= 1
		if w, err = BuiltinVectorDictionaryFieldStringRead(w, &item.Headers); err != nil {
			return w, err
		}
	} else {
		BuiltinVectorDictionaryFieldStringReset(item.Headers)
	}
	if item.FieldMask&(1<<1) != 0 {
		item.tl2mask0 |= 2
		if w, err = basictl.StringRead(w, &item.Body); err != nil {
			return w, err
		}
	} else {
		item.Body = ""
	}
	if item.FieldMask&(1<<2) != 0 {
		item.tl2mask0 |= 4
		if w, err = basictl.IntRead(w, &item.Timeout); err != nil {
			return w, err
		}
	} else {
		item.Timeout = 0
	}
	if item.FieldMask&(1<<3) != 0 {
		item.tl2mask0 |= 8
		if w, err = basictl.IntRead(w, &item.TimeoutConnection); err != nil {
			return w, err
		}
	} else {
		item.TimeoutConnection = 0
	}
	if item.FieldMask&(1<<4) != 0 {
		item.tl2mask0 |= 16
		if w, err = basictl.IntRead(w, &item.MaxRedirs); err != nil {
			return w, err
		}
	} else {
		item.MaxRedirs = 0
	}
	if item.FieldMask&(1<<5) != 0 {
		item.tl2mask0 |= 32
		if w, err = basictl.IntRead(w, &item.SslVersion); err != nil {
			return w, err
		}
	} else {
		item.SslVersion = 0
	}
	if item.FieldMask&(1<<6) != 0 {
		item.tl2mask0 |= 64
		if w, err = basictl.IntRead(w, &item.ResolveIpv); err != nil {
			return w, err
		}
	} else {
		item.ResolveIpv = 0
	}
	if item.FieldMask&(1<<7) != 0 {
		item.tl2mask0 |= 128
		if w, err = basictl.StringRead(w, &item.HttpProxy); err != nil {
			return w, err
		}
	} else {
		item.HttpProxy = ""
	}
	if item.FieldMask&(1<<8) != 0 {
		item.tl2mask1 |= 1
		if w, err = basictl.IntRead(w, &item.Limit); err != nil {
			return w, err
		}
	} else {
		item.Limit = 0
	}
	if item.FieldMask&(1<<9) != 0 {
		item.tl2mask1 |= 2
		if w, err = basictl.StringRead(w, &item.Route); err != nil {
			return w, err
		}
	} else {
		item.Route = ""
	}
	if item.FieldMask&(1<<10) != 0 {
		item.tl2mask1 |= 4
		if w, err = basictl.IntRead(w, &item.Version); err != nil {
			return w, err
		}
	} else {
		item.Version = 0
	}
	if item.FieldMask&(1<<11) != 0 {
		item.tl2mask1 |= 8
		if w, err = basictl.StringRead(w, &item.Origin); err != nil {
			return w, err
		}
	} else {
		item.Origin = ""
	}
	if item.FieldMask&(1<<12) != 0 {
		item.tl2mask1 |= 16
		if w, err = basictl.StringRead(w, &item.TlsCert); err != nil {
			return w, err
		}
	} else {
		item.TlsCert = ""
	}
	if item.FieldMask&(1<<13) != 0 {
		item.tl2mask1 |= 32
		if w, err = basictl.StringRead(w, &item.TlsCertPk); err != nil {
			return w, err
		}
	} else {
		item.TlsCertPk = ""
	}
	return w, nil
}

func (item *CurlRequest) WriteGeneral(w []byte) (_ []byte, err error) {
	return item.Write(w), nil
}

func (item *CurlRequest) Write(w []byte) []byte {
	w = basictl.NatWrite(w, item.FieldMask)
	w = basictl.StringWrite(w, item.Method)
	w = basictl.StringWrite(w, item.Url)
	if item.FieldMask&(1<<0) != 0 {
		w = BuiltinVectorDictionaryFieldStringWrite(w, item.Headers)
	}
	if item.FieldMask&(1<<1) != 0 {
		w = basictl.StringWrite(w, item.Body)
	}
	if item.FieldMask&(1<<2) != 0 {
		w = basictl.IntWrite(w, item.Timeout)
	}
	if item.FieldMask&(1<<3) != 0 {
		w = basictl.IntWrite(w, item.TimeoutConnection)
	}
	if item.FieldMask&(1<<4) != 0 {
		w = basictl.IntWrite(w, item.MaxRedirs)
	}
	if item.FieldMask&(1<<5) != 0 {
		w = basictl.IntWrite(w, item.SslVersion)
	}
	if item.FieldMask&(1<<6) != 0 {
		w = basictl.IntWrite(w, item.ResolveIpv)
	}
	if item.FieldMask&(1<<7) != 0 {
		w = basictl.StringWrite(w, item.HttpProxy)
	}
	if item.FieldMask&(1<<8) != 0 {
		w = basictl.IntWrite(w, item.Limit)
	}
	if item.FieldMask&(1<<9) != 0 {
		w = basictl.StringWrite(w, item.Route)
	}
	if item.FieldMask&(1<<10) != 0 {
		w = basictl.IntWrite(w, item.Version)
	}
	if item.FieldMask&(1<<11) != 0 {
		w = basictl.StringWrite(w, item.Origin)
	}
	if item.FieldMask&(1<<12) != 0 {
		w = basictl.StringWrite(w, item.TlsCert)
	}
	if item.FieldMask&(1<<13) != 0 {
		w = basictl.StringWrite(w, item.TlsCertPk)
	}
	return w
}

func (item *CurlRequest) ReadBoxed(w []byte) (_ []byte, err error) {
	if w, err = basictl.NatReadExactTag(w, 0x3f5a4651); err != nil {
		return w, err
	}
	return item.Read(w)
}

func (item *CurlRequest) WriteBoxedGeneral(w []byte) (_ []byte, err error) {
	return item.WriteBoxed(w), nil
}

func (item *CurlRequest) WriteBoxed(w []byte) []byte {
	w = basictl.NatWrite(w, 0x3f5a4651)
	return item.Write(w)
}

func (item *CurlRequest) ReadResult(w []byte, ret *CurlResponse) (_ []byte, err error) {
	return ret.ReadBoxed(w)
}

func (item *CurlRequest) WriteResult(w []byte, ret CurlResponse) (_ []byte, err error) {
	w = ret.WriteBoxed(w)
	return w, nil
}

func (item *CurlRequest) ReadResultTL2(r []byte, ctx *basictl.TL2ReadContext, ret *CurlResponse) (_ []byte, err error) {
	currentSize := 0
	if r, currentSize, err = basictl.TL2ParseSize(r); err != nil {
		return r, err
	}
	if currentSize == 0 {
		ret.Reset()
		return r, nil
	}
	if len(r) < currentSize {
		return r, basictl.TL2Error("not enough data: expected %d, got %d", currentSize, len(r))
	}

	currentR := r[:currentSize]
	r = r[currentSize:]

	var block byte
	if currentR, err = basictl.ByteReadTL2(currentR, &block); err != nil {
		return r, err
	}
	if block&1 != 0 {
		var index int
		if currentR, index, err = basictl.TL2ParseSize(currentR); err != nil {
			return r, err
		}
		if index != 0 {
			return currentR, basictl.TL2Error("function result must not use variant type field")
		}
	}

	if block&2 != 0 {
		if currentR, err = ret.InternalReadTL2(currentR); err != nil {
			return currentR, err
		}
	} else {
		ret.Reset()
	}
	return r, nil
}

func (item *CurlRequest) calculateLayoutResult(sizes []int, optimizeEmpty bool, ret CurlResponse) ([]int, int) {
	sizes = append(sizes, 1062880849)
	sizePosition := len(sizes)
	sizes = append(sizes, 0)

	currentSize := 1
	lastUsedByte := 0
	var sz int
	if sizes, sz = ret.CalculateLayout(sizes, true); sz != 0 {
		currentSize += sz
		lastUsedByte = currentSize
	}
	if lastUsedByte < currentSize {
		currentSize = lastUsedByte
	}
	sizes[sizePosition] = currentSize
	if currentSize == 0 {
		sizes = sizes[:sizePosition+1]
	}
	if !optimizeEmpty || currentSize != 0 {
		currentSize += basictl.TL2CalculateSize(currentSize)
	}
	Unused(sz)
	return sizes, currentSize
}

func (item *CurlRequest) writeResultTL2(w []byte, sizes []int, optimizeEmpty bool, ret CurlResponse) ([]byte, []int, int) {
	if sizes[0] != 1062880849 {
		panic("tl2: tag mismatch between calculate and write")
	}
	currentSize := sizes[1]
	sizes = sizes[2:]

	if optimizeEmpty && currentSize == 0 {
		return w, sizes, 0
	}
	w = basictl.TL2WriteSize(w, currentSize)
	if currentSize == 0 {
		return w, sizes, 1
	}
	oldLen := len(w)
	var sz int
	var currentBlock byte
	currentBlockPosition := len(w)
	w = append(w, 0)

	if w, sizes, sz = ret.InternalWriteTL2(w, sizes, true); sz != 0 {
		currentBlock |= 2
	}
	if currentBlockPosition < len(w) {
		w[currentBlockPosition] = currentBlock
	}
	if len(w)-oldLen != currentSize {
		panic("tl2: mismatch between calculate and write")
	}
	Unused(sz)
	return w, sizes, currentSize
}

func (item *CurlRequest) WriteResultTL2(w []byte, ctx *basictl.TL2WriteContext, ret CurlResponse) (_ []byte, err error) {
	var sizes, sizes2 []int
	if ctx != nil {
		sizes = ctx.SizeBuffer[:0]
	}
	sizes, _ = item.calculateLayoutResult(sizes, false, ret)
	w, sizes2, _ = item.writeResultTL2(w, sizes, false, ret)
	if len(sizes2) != 0 {
		panic("tl2: internal write did not consume all size data")
	}
	if ctx != nil {
		ctx.SizeBuffer = sizes
	}
	return w, nil
}

func (item *CurlRequest) ReadResultJSON(legacyTypeNames bool, in *basictl.JsonLexer, ret *CurlResponse) error {
	tctx := &basictl.JSONReadContext{LegacyTypeNames: legacyTypeNames}
	if err := ret.ReadJSONGeneral(tctx, in); err != nil {
		return err
	}
	return nil
}

func (item *CurlRequest) WriteResultJSON(w []byte, ret CurlResponse) (_ []byte, err error) {
	tctx := basictl.JSONWriteContext{}
	return item.writeResultJSON(&tctx, w, ret)
}

func (item *CurlRequest) writeResultJSON(tctx *basictl.JSONWriteContext, w []byte, ret CurlResponse) (_ []byte, err error) {
	w = ret.WriteJSONOpt(tctx, w)
	return w, nil
}

func (item *CurlRequest) FillRandomResult(rg *basictl.RandGenerator, w []byte) ([]byte, error) {
	var ret CurlResponse
	ret.FillRandom(rg)
	return item.WriteResult(w, ret)
}

func (item *CurlRequest) ReadResultWriteResultJSON(tctx *basictl.JSONWriteContext, r []byte, w []byte) (_ []byte, _ []byte, err error) {
	var ret CurlResponse
	if r, err = item.ReadResult(r, &ret); err != nil {
		return r, w, err
	}
	w, err = item.writeResultJSON(tctx, w, ret)
	return r, w, err
}

func (item *CurlRequest) ReadResultJSONWriteResult(r []byte, w []byte) (_ []byte, _ []byte, err error) {
	var ret CurlResponse
	if err = item.ReadResultJSON(true, &basictl.JsonLexer{Data: r}, &ret); err != nil {
		return r, w, err
	}
	w, err = item.WriteResult(w, ret)
	return r, w, err
}

func (item *CurlRequest) ReadResultWriteResultTL2(tctx *basictl.TL2WriteContext, r []byte, w []byte) (_ []byte, _ []byte, err error) {
	var ret CurlResponse
	if r, err = item.ReadResult(r, &ret); err != nil {
		return r, w, err
	}
	w, err = item.WriteResultTL2(w, tctx, ret)
	return r, w, err
}

func (item *CurlRequest) ReadResultTL2WriteResult(tctx *basictl.TL2ReadContext, r []byte, w []byte) (_ []byte, _ []byte, err error) {
	var ret CurlResponse
	if r, err = item.ReadResultTL2(r, tctx, &ret); err != nil {
		return r, w, err
	}
	w, err = item.WriteResult(w, ret)
	return r, w, err
}

func (item *CurlRequest) ReadResultTL2WriteResultJSON(tctx *basictl.TL2ReadContext, jctx *basictl.JSONWriteContext, r []byte, w []byte) (_ []byte, _ []byte, err error) {
	var ret CurlResponse
	if r, err = item.ReadResultTL2(r, tctx, &ret); err != nil {
		return r, w, err
	}
	w, err = item.writeResultJSON(jctx, w, ret)
	return r, w, err
}

func (item *CurlRequest) ReadResultJSONWriteResultTL2(tctx *basictl.TL2WriteContext, r []byte, w []byte) (_ []byte, _ []byte, err error) {
	var ret CurlResponse
	if err = item.ReadResultJSON(true, &basictl.JsonLexer{Data: r}, &ret); err != nil {
		return r, w, err
	}
	w, err = item.WriteResultTL2(w, tctx, ret)
	return r, w, err
}

func (item CurlRequest) String() string {
	return string(item.WriteJSON(nil))
}

func (item *CurlRequest) ReadJSON(legacyTypeNames bool, in *basictl.JsonLexer) error {
	tctx := basictl.JSONReadContext{LegacyTypeNames: legacyTypeNames}
	return item.ReadJSONGeneral(&tctx, in)
}

func (item *CurlRequest) ReadJSONGeneral(tctx *basictl.JSONReadContext, in *basictl.JsonLexer) error {
	var propFieldMaskPresented bool
	var propMethodPresented bool
	var propUrlPresented bool
	var propHeadersPresented bool
	var propBodyPresented bool
	var propTimeoutPresented bool
	var propTimeoutConnectionPresented bool
	var propMaxRedirsPresented bool
	var propSslVersionPresented bool
	var propResolveIpvPresented bool
	var propHttpProxyPresented bool
	var propLimitPresented bool
	var propRoutePresented bool
	var propVersionPresented bool
	var propOriginPresented bool
	var propTlsCertPresented bool
	var propTlsCertPkPresented bool

	if in != nil {
		in.Delim('{')
		if !in.Ok() {
			return in.Error()
		}
		for !in.IsDelim('}') {
			key := in.UnsafeFieldName(true)
			in.WantColon()
			switch key {
			case "field_mask":
				if propFieldMaskPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("curl.request", "field_mask")
				}
				if err := Json2ReadUint32(in, &item.FieldMask); err != nil {
					return err
				}
				propFieldMaskPresented = true
			case "method":
				if propMethodPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("curl.request", "method")
				}
				if err := Json2ReadString(in, &item.Method); err != nil {
					return err
				}
				propMethodPresented = true
			case "url":
				if propUrlPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("curl.request", "url")
				}
				if err := Json2ReadString(in, &item.Url); err != nil {
					return err
				}
				propUrlPresented = true
			case "headers":
				if propHeadersPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("curl.request", "headers")
				}
				if err := BuiltinVectorDictionaryFieldStringReadJSONGeneral(tctx, in, &item.Headers); err != nil {
					return err
				}
				propHeadersPresented = true
			case "body":
				if propBodyPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("curl.request", "body")
				}
				if err := Json2ReadString(in, &item.Body); err != nil {
					return err
				}
				propBodyPresented = true
			case "timeout":
				if propTimeoutPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("curl.request", "timeout")
				}
				if err := Json2ReadInt32(in, &item.Timeout); err != nil {
					return err
				}
				propTimeoutPresented = true
			case "timeout_connection":
				if propTimeoutConnectionPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("curl.request", "timeout_connection")
				}
				if err := Json2ReadInt32(in, &item.TimeoutConnection); err != nil {
					return err
				}
				propTimeoutConnectionPresented = true
			case "max_redirs":
				if propMaxRedirsPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("curl.request", "max_redirs")
				}
				if err := Json2ReadInt32(in, &item.MaxRedirs); err != nil {
					return err
				}
				propMaxRedirsPresented = true
			case "ssl_version":
				if propSslVersionPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("curl.request", "ssl_version")
				}
				if err := Json2ReadInt32(in, &item.SslVersion); err != nil {
					return err
				}
				propSslVersionPresented = true
			case "resolve_ipv":
				if propResolveIpvPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("curl.request", "resolve_ipv")
				}
				if err := Json2ReadInt32(in, &item.ResolveIpv); err != nil {
					return err
				}
				propResolveIpvPresented = true
			case "http_proxy":
				if propHttpProxyPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("curl.request", "http_proxy")
				}
				if err := Json2ReadString(in, &item.HttpProxy); err != nil {
					return err
				}
				propHttpProxyPresented = true
			case "limit":
				if propLimitPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("curl.request", "limit")
				}
				if err := Json2ReadInt32(in, &item.Limit); err != nil {
					return err
				}
				propLimitPresented = true
			case "route":
				if propRoutePresented {
					return ErrorInvalidJSONWithDuplicatingKeys("curl.request", "route")
				}
				if err := Json2ReadString(in, &item.Route); err != nil {
					return err
				}
				propRoutePresented = true
			case "version":
				if propVersionPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("curl.request", "version")
				}
				if err := Json2ReadInt32(in, &item.Version); err != nil {
					return err
				}
				propVersionPresented = true
			case "origin":
				if propOriginPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("curl.request", "origin")
				}
				if err := Json2ReadString(in, &item.Origin); err != nil {
					return err
				}
				propOriginPresented = true
			case "tls_cert":
				if propTlsCertPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("curl.request", "tls_cert")
				}
				if err := Json2ReadString(in, &item.TlsCert); err != nil {
					return err
				}
				propTlsCertPresented = true
			case "tls_cert_pk":
				if propTlsCertPkPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("curl.request", "tls_cert_pk")
				}
				if err := Json2ReadString(in, &item.TlsCertPk); err != nil {
					return err
				}
				propTlsCertPkPresented = true
			default:
				return ErrorInvalidJSONExcessElement("curl.request", key)
			}
			in.WantComma()
		}
		in.Delim('}')
		if !in.Ok() {
			return in.Error()
		}
	}
	if !propFieldMaskPresented {
		item.FieldMask = 0
	}
	if !propMethodPresented {
		item.Method = ""
	}
	if !propUrlPresented {
		item.Url = ""
	}
	if !propHeadersPresented {
		BuiltinVectorDictionaryFieldStringReset(item.Headers)
	}
	if !propBodyPresented {
		item.Body = ""
	}
	if !propTimeoutPresented {
		item.Timeout = 0
	}
	if !propTimeoutConnectionPresented {
		item.TimeoutConnection = 0
	}
	if !propMaxRedirsPresented {
		item.MaxRedirs = 0
	}
	if !propSslVersionPresented {
		item.SslVersion = 0
	}
	if !propResolveIpvPresented {
		item.ResolveIpv = 0
	}
	if !propHttpProxyPresented {
		item.HttpProxy = ""
	}
	if !propLimitPresented {
		item.Limit = 0
	}
	if !propRoutePresented {
		item.Route = ""
	}
	if !propVersionPresented {
		item.Version = 0
	}
	if !propOriginPresented {
		item.Origin = ""
	}
	if !propTlsCertPresented {
		item.TlsCert = ""
	}
	if !propTlsCertPkPresented {
		item.TlsCertPk = ""
	}
	if propHeadersPresented {
		item.FieldMask |= 1 << 0
	}
	if propBodyPresented {
		item.FieldMask |= 1 << 1
	}
	if propTimeoutPresented {
		item.FieldMask |= 1 << 2
	}
	if propTimeoutConnectionPresented {
		item.FieldMask |= 1 << 3
	}
	if propMaxRedirsPresented {
		item.FieldMask |= 1 << 4
	}
	if propSslVersionPresented {
		item.FieldMask |= 1 << 5
	}
	if propResolveIpvPresented {
		item.FieldMask |= 1 << 6
	}
	if propHttpProxyPresented {
		item.FieldMask |= 1 << 7
	}
	if propLimitPresented {
		item.FieldMask |= 1 << 8
	}
	if propRoutePresented {
		item.FieldMask |= 1 << 9
	}
	if propVersionPresented {
		item.FieldMask |= 1 << 10
	}
	if propOriginPresented {
		item.FieldMask |= 1 << 11
	}
	if propTlsCertPresented {
		item.FieldMask |= 1 << 12
	}
	if propTlsCertPkPresented {
		item.FieldMask |= 1 << 13
	}
	if item.FieldMask&(1<<0) != 0 {
		item.tl2mask0 |= 1
	}
	if item.FieldMask&(1<<1) != 0 {
		item.tl2mask0 |= 2
	}
	if item.FieldMask&(1<<2) != 0 {
		item.tl2mask0 |= 4
	}
	if item.FieldMask&(1<<3) != 0 {
		item.tl2mask0 |= 8
	}
	if item.FieldMask&(1<<4) != 0 {
		item.tl2mask0 |= 16
	}
	if item.FieldMask&(1<<5) != 0 {
		item.tl2mask0 |= 32
	}
	if item.FieldMask&(1<<6) != 0 {
		item.tl2mask0 |= 64
	}
	if item.FieldMask&(1<<7) != 0 {
		item.tl2mask0 |= 128
	}
	if item.FieldMask&(1<<8) != 0 {
		item.tl2mask1 |= 1
	}
	if item.FieldMask&(1<<9) != 0 {
		item.tl2mask1 |= 2
	}
	if item.FieldMask&(1<<10) != 0 {
		item.tl2mask1 |= 4
	}
	if item.FieldMask&(1<<11) != 0 {
		item.tl2mask1 |= 8
	}
	if item.FieldMask&(1<<12) != 0 {
		item.tl2mask1 |= 16
	}
	if item.FieldMask&(1<<13) != 0 {
		item.tl2mask1 |= 32
	}
	return nil
}

// This method is general version of WriteJSON, use it instead!
func (item *CurlRequest) WriteJSONGeneral(tctx *basictl.JSONWriteContext, w []byte) (_ []byte, err error) {
	return item.WriteJSONOpt(tctx, w), nil
}

func (item *CurlRequest) WriteJSON(w []byte) []byte {
	tctx := basictl.JSONWriteContext{}
	return item.WriteJSONOpt(&tctx, w)
}
func (item *CurlRequest) WriteJSONOpt(tctx *basictl.JSONWriteContext, w []byte) []byte {
	w = append(w, '{')
	backupIndexFieldMask := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"field_mask":`...)
	w = basictl.JSONWriteUint32(w, item.FieldMask)
	if (item.FieldMask != 0) == false {
		w = w[:backupIndexFieldMask]
	}
	backupIndexMethod := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"method":`...)
	w = basictl.JSONWriteString(w, item.Method)
	if (len(item.Method) != 0) == false {
		w = w[:backupIndexMethod]
	}
	backupIndexUrl := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"url":`...)
	w = basictl.JSONWriteString(w, item.Url)
	if (len(item.Url) != 0) == false {
		w = w[:backupIndexUrl]
	}
	if item.FieldMask&(1<<0) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"headers":`...)
		w = BuiltinVectorDictionaryFieldStringWriteJSONOpt(tctx, w, item.Headers)
	}
	if item.FieldMask&(1<<1) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"body":`...)
		w = basictl.JSONWriteString(w, item.Body)
	}
	if item.FieldMask&(1<<2) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"timeout":`...)
		w = basictl.JSONWriteInt32(w, item.Timeout)
	}
	if item.FieldMask&(1<<3) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"timeout_connection":`...)
		w = basictl.JSONWriteInt32(w, item.TimeoutConnection)
	}
	if item.FieldMask&(1<<4) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"max_redirs":`...)
		w = basictl.JSONWriteInt32(w, item.MaxRedirs)
	}
	if item.FieldMask&(1<<5) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"ssl_version":`...)
		w = basictl.JSONWriteInt32(w, item.SslVersion)
	}
	if item.FieldMask&(1<<6) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"resolve_ipv":`...)
		w = basictl.JSONWriteInt32(w, item.ResolveIpv)
	}
	if item.FieldMask&(1<<7) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"http_proxy":`...)
		w = basictl.JSONWriteString(w, item.HttpProxy)
	}
	if item.FieldMask&(1<<8) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"limit":`...)
		w = basictl.JSONWriteInt32(w, item.Limit)
	}
	if item.FieldMask&(1<<9) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"route":`...)
		w = basictl.JSONWriteString(w, item.Route)
	}
	if item.FieldMask&(1<<10) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"version":`...)
		w = basictl.JSONWriteInt32(w, item.Version)
	}
	if item.FieldMask&(1<<11) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"origin":`...)
		w = basictl.JSONWriteString(w, item.Origin)
	}
	if item.FieldMask&(1<<12) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"tls_cert":`...)
		w = basictl.JSONWriteString(w, item.TlsCert)
	}
	if item.FieldMask&(1<<13) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"tls_cert_pk":`...)
		w = basictl.JSONWriteString(w, item.TlsCertPk)
	}
	return append(w, '}')
}

func (item *CurlRequest) MarshalJSON() ([]byte, error) {
	return item.WriteJSON(nil), nil
}

func (item *CurlRequest) UnmarshalJSON(b []byte) error {
	if err := item.ReadJSON(true, &basictl.JsonLexer{Data: b}); err != nil {
		return ErrorInvalidJSON("curl.request", err.Error())
	}
	return nil
}

func (item *CurlRequest) CalculateLayout(sizes []int, optimizeEmpty bool) ([]int, int) {
	sizes = append(sizes, 1062880849)
	sizePosition := len(sizes)
	sizes = append(sizes, 0)

	currentSize := 1
	lastUsedByte := 0
	var sz int

	if item.FieldMask != 0 {
		currentSize += 4
		lastUsedByte = currentSize
	}
	if len(item.Method) != 0 {
		currentSize += basictl.TL2CalculateSize(len(item.Method)) + len(item.Method)
		lastUsedByte = currentSize
	}
	if len(item.Url) != 0 {
		currentSize += basictl.TL2CalculateSize(len(item.Url)) + len(item.Url)
		lastUsedByte = currentSize
	}
	if item.tl2mask0&1 != 0 {
		sizes, sz = BuiltinVectorDictionaryFieldStringCalculateLayout(sizes, false, &item.Headers)
		currentSize += sz
		lastUsedByte = currentSize
	}
	if item.tl2mask0&2 != 0 {
		currentSize += basictl.TL2CalculateSize(len(item.Body)) + len(item.Body)
		lastUsedByte = currentSize
	}
	if item.tl2mask0&4 != 0 {
		currentSize += 4
		lastUsedByte = currentSize
	}
	if item.tl2mask0&8 != 0 {
		currentSize += 4
		lastUsedByte = currentSize
	}
	currentSize++
	if item.tl2mask0&16 != 0 {
		currentSize += 4
		lastUsedByte = currentSize
	}
	if item.tl2mask0&32 != 0 {
		currentSize += 4
		lastUsedByte = currentSize
	}
	if item.tl2mask0&64 != 0 {
		currentSize += 4
		lastUsedByte = currentSize
	}
	if item.tl2mask0&128 != 0 {
		currentSize += basictl.TL2CalculateSize(len(item.HttpProxy)) + len(item.HttpProxy)
		lastUsedByte = currentSize
	}
	if item.tl2mask1&1 != 0 {
		currentSize += 4
		lastUsedByte = currentSize
	}
	if item.tl2mask1&2 != 0 {
		currentSize += basictl.TL2CalculateSize(len(item.Route)) + len(item.Route)
		lastUsedByte = currentSize
	}
	if item.tl2mask1&4 != 0 {
		currentSize += 4
		lastUsedByte = currentSize
	}
	if item.tl2mask1&8 != 0 {
		currentSize += basictl.TL2CalculateSize(len(item.Origin)) + len(item.Origin)
		lastUsedByte = currentSize
	}
	currentSize++
	if item.tl2mask1&16 != 0 {
		currentSize += basictl.TL2CalculateSize(len(item.TlsCert)) + len(item.TlsCert)
		lastUsedByte = currentSize
	}
	if item.tl2mask1&32 != 0 {
		currentSize += basictl.TL2CalculateSize(len(item.TlsCertPk)) + len(item.TlsCertPk)
		lastUsedByte = currentSize
	}

	if lastUsedByte < currentSize {
		currentSize = lastUsedByte
	}
	sizes[sizePosition] = currentSize
	if currentSize == 0 {
		sizes = sizes[:sizePosition+1]
	}
	if !optimizeEmpty || currentSize != 0 {
		currentSize += basictl.TL2CalculateSize(currentSize)
	}
	Unused(sz)
	return sizes, currentSize
}

func (item *CurlRequest) InternalWriteTL2(w []byte, sizes []int, optimizeEmpty bool) ([]byte, []int, int) {
	if sizes[0] != 1062880849 {
		panic("tl2: tag mismatch between calculate and write")
	}
	currentSize := sizes[1]
	sizes = sizes[2:]
	if optimizeEmpty && currentSize == 0 {
		return w, sizes, 0
	}
	w = basictl.TL2WriteSize(w, currentSize)
	if currentSize == 0 {
		return w, sizes, 1
	}
	oldLen := len(w)
	var sz int
	var currentBlock byte
	currentBlockPosition := len(w)
	w = append(w, 0)
	if item.FieldMask != 0 {
		w = basictl.NatWrite(w, item.FieldMask)
		currentBlock |= 2
	}
	if len(item.Method) != 0 {
		w = basictl.StringWriteTL2(w, item.Method)
		currentBlock |= 4
	}
	if len(item.Url) != 0 {
		w = basictl.StringWriteTL2(w, item.Url)
		currentBlock |= 8
	}
	if item.tl2mask0&1 != 0 {
		w, sizes, _ = BuiltinVectorDictionaryFieldStringInternalWriteTL2(w, sizes, false, &item.Headers)
		currentBlock |= 16
	}
	if item.tl2mask0&2 != 0 {
		w = basictl.StringWriteTL2(w, item.Body)
		currentBlock |= 32
	}
	if item.tl2mask0&4 != 0 {
		w = basictl.IntWrite(w, item.Timeout)
		currentBlock |= 64
	}
	if item.tl2mask0&8 != 0 {
		w = basictl.IntWrite(w, item.TimeoutConnection)
		currentBlock |= 128
	}
	if currentBlockPosition < len(w) {
		w[currentBlockPosition] = currentBlock
	}
	currentBlock = 0
	// start the next block
	currentBlockPosition = len(w)
	if len(w)-oldLen < currentSize {
		w = append(w, 0)
	}
	if item.tl2mask0&16 != 0 {
		w = basictl.IntWrite(w, item.MaxRedirs)
		currentBlock |= 1
	}
	if item.tl2mask0&32 != 0 {
		w = basictl.IntWrite(w, item.SslVersion)
		currentBlock |= 2
	}
	if item.tl2mask0&64 != 0 {
		w = basictl.IntWrite(w, item.ResolveIpv)
		currentBlock |= 4
	}
	if item.tl2mask0&128 != 0 {
		w = basictl.StringWriteTL2(w, item.HttpProxy)
		currentBlock |= 8
	}
	if item.tl2mask1&1 != 0 {
		w = basictl.IntWrite(w, item.Limit)
		currentBlock |= 16
	}
	if item.tl2mask1&2 != 0 {
		w = basictl.StringWriteTL2(w, item.Route)
		currentBlock |= 32
	}
	if item.tl2mask1&4 != 0 {
		w = basictl.IntWrite(w, item.Version)
		currentBlock |= 64
	}
	if item.tl2mask1&8 != 0 {
		w = basictl.StringWriteTL2(w, item.Origin)
		currentBlock |= 128
	}
	if currentBlockPosition < len(w) {
		w[currentBlockPosition] = currentBlock
	}
	currentBlock = 0
	// start the next block
	currentBlockPosition = len(w)
	if len(w)-oldLen < currentSize {
		w = append(w, 0)
	}
	if item.tl2mask1&16 != 0 {
		w = basictl.StringWriteTL2(w, item.TlsCert)
		currentBlock |= 1
	}
	if item.tl2mask1&32 != 0 {
		w = basictl.StringWriteTL2(w, item.TlsCertPk)
		currentBlock |= 2
	}
	if currentBlockPosition < len(w) {
		w[currentBlockPosition] = currentBlock
	}
	if len(w)-oldLen != currentSize {
		panic("tl2: mismatch between calculate and write")
	}
	Unused(sz)
	return w, sizes, 1
}

func (item *CurlRequest) WriteTL2(w []byte, ctx *basictl.TL2WriteContext) []byte {
	var sizes, sizes2 []int
	if ctx != nil {
		sizes = ctx.SizeBuffer[:0]
	}
	sizes, _ = item.CalculateLayout(sizes, false)
	w, sizes2, _ = item.InternalWriteTL2(w, sizes, false)
	if len(sizes2) != 0 {
		panic("tl2: internal write did not consume all size data")
	}
	if ctx != nil {
		ctx.SizeBuffer = sizes
	}
	return w
}

func (item *CurlRequest) InternalReadTL2(r []byte) (_ []byte, err error) {
	currentSize := 0
	if r, currentSize, err = basictl.TL2ParseSize(r); err != nil {
		return r, err
	}
	if currentSize == 0 {
		item.Reset()
		return r, nil
	}
	if len(r) < currentSize {
		return r, basictl.TL2Error("not enough data: expected %d, got %d", currentSize, len(r))
	}

	currentR := r[:currentSize]
	r = r[currentSize:]

	var block byte
	if currentR, err = basictl.ByteReadTL2(currentR, &block); err != nil {
		return currentR, err
	}
	// read No of constructor
	if block&1 != 0 {
		var index int
		if currentR, index, err = basictl.TL2ParseSize(currentR); err != nil {
			return currentR, err
		}
		if index != 0 {
			return r, ErrorInvalidUnionIndex("curl.request", index)
		}
	}
	item.tl2mask0 = 0
	item.tl2mask1 = 0
	if block&2 != 0 {
		if currentR, err = basictl.NatRead(currentR, &item.FieldMask); err != nil {
			return currentR, err
		}
	} else {
		item.FieldMask = 0
	}
	if block&4 != 0 {
		if currentR, err = basictl.StringReadTL2(currentR, &item.Method); err != nil {
			return currentR, err
		}
	} else {
		item.Method = ""
	}
	if block&8 != 0 {
		if currentR, err = basictl.StringReadTL2(currentR, &item.Url); err != nil {
			return currentR, err
		}
	} else {
		item.Url = ""
	}
	if block&16 != 0 {
		item.tl2mask0 |= 1
		if currentR, err = BuiltinVectorDictionaryFieldStringInternalReadTL2(currentR, &item.Headers); err != nil {
			return currentR, err
		}
	} else {
		BuiltinVectorDictionaryFieldStringReset(item.Headers)
	}
	if block&32 != 0 {
		item.tl2mask0 |= 2
		if currentR, err = basictl.StringReadTL2(currentR, &item.Body); err != nil {
			return currentR, err
		}
	} else {
		item.Body = ""
	}
	if block&64 != 0 {
		item.tl2mask0 |= 4
		if currentR, err = basictl.IntRead(currentR, &item.Timeout); err != nil {
			return currentR, err
		}
	} else {
		item.Timeout = 0
	}
	if block&128 != 0 {
		item.tl2mask0 |= 8
		if currentR, err = basictl.IntRead(currentR, &item.TimeoutConnection); err != nil {
			return currentR, err
		}
	} else {
		item.TimeoutConnection = 0
	}
	// start the next block
	if len(currentR) > 0 {
		if currentR, err = basictl.ByteReadTL2(currentR, &block); err != nil {
			return currentR, err
		}
	} else {
		block = 0
	}
	if block&1 != 0 {
		item.tl2mask0 |= 16
		if currentR, err = basictl.IntRead(currentR, &item.MaxRedirs); err != nil {
			return currentR, err
		}
	} else {
		item.MaxRedirs = 0
	}
	if block&2 != 0 {
		item.tl2mask0 |= 32
		if currentR, err = basictl.IntRead(currentR, &item.SslVersion); err != nil {
			return currentR, err
		}
	} else {
		item.SslVersion = 0
	}
	if block&4 != 0 {
		item.tl2mask0 |= 64
		if currentR, err = basictl.IntRead(currentR, &item.ResolveIpv); err != nil {
			return currentR, err
		}
	} else {
		item.ResolveIpv = 0
	}
	if block&8 != 0 {
		item.tl2mask0 |= 128
		if currentR, err = basictl.StringReadTL2(currentR, &item.HttpProxy); err != nil {
			return currentR, err
		}
	} else {
		item.HttpProxy = ""
	}
	if block&16 != 0 {
		item.tl2mask1 |= 1
		if currentR, err = basictl.IntRead(currentR, &item.Limit); err != nil {
			return currentR, err
		}
	} else {
		item.Limit = 0
	}
	if block&32 != 0 {
		item.tl2mask1 |= 2
		if currentR, err = basictl.StringReadTL2(currentR, &item.Route); err != nil {
			return currentR, err
		}
	} else {
		item.Route = ""
	}
	if block&64 != 0 {
		item.tl2mask1 |= 4
		if currentR, err = basictl.IntRead(currentR, &item.Version); err != nil {
			return currentR, err
		}
	} else {
		item.Version = 0
	}
	if block&128 != 0 {
		item.tl2mask1 |= 8
		if currentR, err = basictl.StringReadTL2(currentR, &item.Origin); err != nil {
			return currentR, err
		}
	} else {
		item.Origin = ""
	}
	// start the next block
	if len(currentR) > 0 {
		if currentR, err = basictl.ByteReadTL2(currentR, &block); err != nil {
			return currentR, err
		}
	} else {
		block = 0
	}
	if block&1 != 0 {
		item.tl2mask1 |= 16
		if currentR, err = basictl.StringReadTL2(currentR, &item.TlsCert); err != nil {
			return currentR, err
		}
	} else {
		item.TlsCert = ""
	}
	if block&2 != 0 {
		item.tl2mask1 |= 32
		if currentR, err = basictl.StringReadTL2(currentR, &item.TlsCertPk); err != nil {
			return currentR, err
		}
	} else {
		item.TlsCertPk = ""
	}
	Unused(currentR)
	return r, nil
}

func (item *CurlRequest) ReadTL2(r []byte, ctx *basictl.TL2ReadContext) (_ []byte, err error) {
	return item.InternalReadTL2(r)
}
