// Copyright 2025 V Kontakte LLC
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Code generated by vktl/cmd/tlgen2; DO NOT EDIT.
package tlCasesTestAllPossibleFieldConfigs

import (
	"github.com/vkcom/tl/internal/tlcodegen/test/gen/casesTL1/internal"
	"github.com/vkcom/tl/internal/tlcodegen/test/gen/casesTL1/internal/tl/tlBuiltinTupleInt"
	"github.com/vkcom/tl/internal/tlcodegen/test/gen/casesTL1/internal/tl/tlTrue"
	"github.com/vkcom/tl/pkg/basictl"
)

var _ = basictl.NatWrite
var _ = internal.ErrorInvalidEnumTag

type CasesTestAllPossibleFieldConfigs struct {
	Local uint32
	F00   int32
	F01   tlTrue.True
	F02   []int32
	F03   []int32
	F10   int32 // Conditional: item.Local.0
	// F11 (TrueType) // Conditional: item.Local.1
	F12 []int32 // Conditional: item.Local.2
	F13 []int32 // Conditional: item.Local.3
	F20 int32   // Conditional: nat_outer.0
	// F21 (TrueType) // Conditional: nat_outer.1
	F22 []int32 // Conditional: nat_outer.2
	F23 []int32 // Conditional: nat_outer.3
}

func (CasesTestAllPossibleFieldConfigs) TLName() string { return "cases.testAllPossibleFieldConfigs" }
func (CasesTestAllPossibleFieldConfigs) TLTag() uint32  { return 0xfb6836d3 }

func (item *CasesTestAllPossibleFieldConfigs) SetF10(v int32) {
	item.F10 = v
	item.Local |= 1 << 0
}
func (item *CasesTestAllPossibleFieldConfigs) ClearF10() {
	item.F10 = 0
	item.Local &^= 1 << 0
}
func (item *CasesTestAllPossibleFieldConfigs) IsSetF10() bool { return item.Local&(1<<0) != 0 }

func (item *CasesTestAllPossibleFieldConfigs) SetF11(v bool) {
	if v {
		item.Local |= 1 << 1
	} else {
		item.Local &^= 1 << 1
	}
}
func (item *CasesTestAllPossibleFieldConfigs) IsSetF11() bool { return item.Local&(1<<1) != 0 }

func (item *CasesTestAllPossibleFieldConfigs) SetF12(v []int32) {
	item.F12 = v
	item.Local |= 1 << 2
}
func (item *CasesTestAllPossibleFieldConfigs) ClearF12() {
	item.F12 = item.F12[:0]
	item.Local &^= 1 << 2
}
func (item *CasesTestAllPossibleFieldConfigs) IsSetF12() bool { return item.Local&(1<<2) != 0 }

func (item *CasesTestAllPossibleFieldConfigs) SetF13(v []int32) {
	item.F13 = v
	item.Local |= 1 << 3
}
func (item *CasesTestAllPossibleFieldConfigs) ClearF13() {
	item.F13 = item.F13[:0]
	item.Local &^= 1 << 3
}
func (item *CasesTestAllPossibleFieldConfigs) IsSetF13() bool { return item.Local&(1<<3) != 0 }

func (item *CasesTestAllPossibleFieldConfigs) SetF20(v int32, nat_outer *uint32) {
	item.F20 = v
	if nat_outer != nil {
		*nat_outer |= 1 << 0
	}
}
func (item *CasesTestAllPossibleFieldConfigs) ClearF20(nat_outer *uint32) {
	item.F20 = 0
	if nat_outer != nil {
		*nat_outer &^= 1 << 0
	}
}
func (item *CasesTestAllPossibleFieldConfigs) IsSetF20(nat_outer uint32) bool {
	return nat_outer&(1<<0) != 0
}

func (item *CasesTestAllPossibleFieldConfigs) SetF21(v bool, nat_outer *uint32) {
	if nat_outer != nil {
		if v {
			*nat_outer |= 1 << 1
		} else {
			*nat_outer &^= 1 << 1
		}
	}
}
func (item *CasesTestAllPossibleFieldConfigs) IsSetF21(nat_outer uint32) bool {
	return nat_outer&(1<<1) != 0
}

func (item *CasesTestAllPossibleFieldConfigs) SetF22(v []int32, nat_outer *uint32) {
	item.F22 = v
	if nat_outer != nil {
		*nat_outer |= 1 << 2
	}
}
func (item *CasesTestAllPossibleFieldConfigs) ClearF22(nat_outer *uint32) {
	item.F22 = item.F22[:0]
	if nat_outer != nil {
		*nat_outer &^= 1 << 2
	}
}
func (item *CasesTestAllPossibleFieldConfigs) IsSetF22(nat_outer uint32) bool {
	return nat_outer&(1<<2) != 0
}

func (item *CasesTestAllPossibleFieldConfigs) SetF23(v []int32, nat_outer *uint32) {
	item.F23 = v
	if nat_outer != nil {
		*nat_outer |= 1 << 3
	}
}
func (item *CasesTestAllPossibleFieldConfigs) ClearF23(nat_outer *uint32) {
	item.F23 = item.F23[:0]
	if nat_outer != nil {
		*nat_outer &^= 1 << 3
	}
}
func (item *CasesTestAllPossibleFieldConfigs) IsSetF23(nat_outer uint32) bool {
	return nat_outer&(1<<3) != 0
}

func (item *CasesTestAllPossibleFieldConfigs) Reset() {
	item.Local = 0
	item.F00 = 0
	item.F02 = item.F02[:0]
	item.F03 = item.F03[:0]
	item.F10 = 0
	item.F12 = item.F12[:0]
	item.F13 = item.F13[:0]
	item.F20 = 0
	item.F22 = item.F22[:0]
	item.F23 = item.F23[:0]
}

func (item *CasesTestAllPossibleFieldConfigs) FillRandom(rg *basictl.RandGenerator, nat_outer uint32) {
	item.Local = basictl.RandomFieldMask(rg, 0b1111)
	item.Local = rg.LimitValue(item.Local)
	item.F00 = basictl.RandomInt(rg)
	tlBuiltinTupleInt.BuiltinTupleIntFillRandom(rg, &item.F02, item.Local)
	tlBuiltinTupleInt.BuiltinTupleIntFillRandom(rg, &item.F03, nat_outer)
	if item.Local&(1<<0) != 0 {
		item.F10 = basictl.RandomInt(rg)
	} else {
		item.F10 = 0
	}
	if item.Local&(1<<2) != 0 {
		tlBuiltinTupleInt.BuiltinTupleIntFillRandom(rg, &item.F12, item.Local)
	} else {
		item.F12 = item.F12[:0]
	}
	if item.Local&(1<<3) != 0 {
		tlBuiltinTupleInt.BuiltinTupleIntFillRandom(rg, &item.F13, nat_outer)
	} else {
		item.F13 = item.F13[:0]
	}
	if nat_outer&(1<<0) != 0 {
		item.F20 = basictl.RandomInt(rg)
	} else {
		item.F20 = 0
	}
	if nat_outer&(1<<2) != 0 {
		tlBuiltinTupleInt.BuiltinTupleIntFillRandom(rg, &item.F22, item.Local)
	} else {
		item.F22 = item.F22[:0]
	}
	if nat_outer&(1<<3) != 0 {
		tlBuiltinTupleInt.BuiltinTupleIntFillRandom(rg, &item.F23, nat_outer)
	} else {
		item.F23 = item.F23[:0]
	}
}

func (item *CasesTestAllPossibleFieldConfigs) Read(w []byte, nat_outer uint32) (_ []byte, err error) {
	if w, err = basictl.NatRead(w, &item.Local); err != nil {
		return w, err
	}
	if w, err = basictl.IntRead(w, &item.F00); err != nil {
		return w, err
	}
	if w, err = tlBuiltinTupleInt.BuiltinTupleIntRead(w, &item.F02, item.Local); err != nil {
		return w, err
	}
	if w, err = tlBuiltinTupleInt.BuiltinTupleIntRead(w, &item.F03, nat_outer); err != nil {
		return w, err
	}
	if item.Local&(1<<0) != 0 {
		if w, err = basictl.IntRead(w, &item.F10); err != nil {
			return w, err
		}
	} else {
		item.F10 = 0
	}
	if item.Local&(1<<2) != 0 {
		if w, err = tlBuiltinTupleInt.BuiltinTupleIntRead(w, &item.F12, item.Local); err != nil {
			return w, err
		}
	} else {
		item.F12 = item.F12[:0]
	}
	if item.Local&(1<<3) != 0 {
		if w, err = tlBuiltinTupleInt.BuiltinTupleIntRead(w, &item.F13, nat_outer); err != nil {
			return w, err
		}
	} else {
		item.F13 = item.F13[:0]
	}
	if nat_outer&(1<<0) != 0 {
		if w, err = basictl.IntRead(w, &item.F20); err != nil {
			return w, err
		}
	} else {
		item.F20 = 0
	}
	if nat_outer&(1<<2) != 0 {
		if w, err = tlBuiltinTupleInt.BuiltinTupleIntRead(w, &item.F22, item.Local); err != nil {
			return w, err
		}
	} else {
		item.F22 = item.F22[:0]
	}
	if nat_outer&(1<<3) != 0 {
		if w, err = tlBuiltinTupleInt.BuiltinTupleIntRead(w, &item.F23, nat_outer); err != nil {
			return w, err
		}
	} else {
		item.F23 = item.F23[:0]
	}
	return w, nil
}

func (item *CasesTestAllPossibleFieldConfigs) WriteGeneral(w []byte, nat_outer uint32) (_ []byte, err error) {
	return item.Write(w, nat_outer)
}

func (item *CasesTestAllPossibleFieldConfigs) Write(w []byte, nat_outer uint32) (_ []byte, err error) {
	w = basictl.NatWrite(w, item.Local)
	w = basictl.IntWrite(w, item.F00)
	if w, err = tlBuiltinTupleInt.BuiltinTupleIntWrite(w, item.F02, item.Local); err != nil {
		return w, err
	}
	if w, err = tlBuiltinTupleInt.BuiltinTupleIntWrite(w, item.F03, nat_outer); err != nil {
		return w, err
	}
	if item.Local&(1<<0) != 0 {
		w = basictl.IntWrite(w, item.F10)
	}
	if item.Local&(1<<2) != 0 {
		if w, err = tlBuiltinTupleInt.BuiltinTupleIntWrite(w, item.F12, item.Local); err != nil {
			return w, err
		}
	}
	if item.Local&(1<<3) != 0 {
		if w, err = tlBuiltinTupleInt.BuiltinTupleIntWrite(w, item.F13, nat_outer); err != nil {
			return w, err
		}
	}
	if nat_outer&(1<<0) != 0 {
		w = basictl.IntWrite(w, item.F20)
	}
	if nat_outer&(1<<2) != 0 {
		if w, err = tlBuiltinTupleInt.BuiltinTupleIntWrite(w, item.F22, item.Local); err != nil {
			return w, err
		}
	}
	if nat_outer&(1<<3) != 0 {
		if w, err = tlBuiltinTupleInt.BuiltinTupleIntWrite(w, item.F23, nat_outer); err != nil {
			return w, err
		}
	}
	return w, nil
}

func (item *CasesTestAllPossibleFieldConfigs) ReadBoxed(w []byte, nat_outer uint32) (_ []byte, err error) {
	if w, err = basictl.NatReadExactTag(w, 0xfb6836d3); err != nil {
		return w, err
	}
	return item.Read(w, nat_outer)
}

func (item *CasesTestAllPossibleFieldConfigs) WriteBoxedGeneral(w []byte, nat_outer uint32) (_ []byte, err error) {
	return item.WriteBoxed(w, nat_outer)
}

func (item *CasesTestAllPossibleFieldConfigs) WriteBoxed(w []byte, nat_outer uint32) (_ []byte, err error) {
	w = basictl.NatWrite(w, 0xfb6836d3)
	return item.Write(w, nat_outer)
}

func (item *CasesTestAllPossibleFieldConfigs) ReadJSONGeneral(tctx *basictl.JSONReadContext, in *basictl.JsonLexer, nat_outer uint32) error {
	var propLocalPresented bool
	var propF00Presented bool
	var propF01Presented bool
	var rawF02 []byte
	var rawF03 []byte
	var propF10Presented bool
	var trueTypeF11Presented bool
	var trueTypeF11Value bool
	var rawF12 []byte
	var rawF13 []byte
	var propF20Presented bool
	var rawF22 []byte
	var rawF23 []byte

	if in != nil {
		in.Delim('{')
		if !in.Ok() {
			return in.Error()
		}
		for !in.IsDelim('}') {
			key := in.UnsafeFieldName(true)
			in.WantColon()
			switch key {
			case "local":
				if propLocalPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "local")
				}
				if err := internal.Json2ReadUint32(in, &item.Local); err != nil {
					return err
				}
				propLocalPresented = true
			case "f00":
				if propF00Presented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "f00")
				}
				if err := internal.Json2ReadInt32(in, &item.F00); err != nil {
					return err
				}
				propF00Presented = true
			case "f01":
				if propF01Presented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "f01")
				}
				if err := item.F01.ReadJSONGeneral(tctx, in); err != nil {
					return err
				}
				propF01Presented = true
			case "f02":
				if rawF02 != nil {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "f02")
				}
				rawF02 = in.Raw()
				if !in.Ok() {
					return in.Error()
				}
			case "f03":
				if rawF03 != nil {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "f03")
				}
				rawF03 = in.Raw()
				if !in.Ok() {
					return in.Error()
				}
			case "f10":
				if propF10Presented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "f10")
				}
				if err := internal.Json2ReadInt32(in, &item.F10); err != nil {
					return err
				}
				propF10Presented = true
			case "f11":
				if trueTypeF11Presented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "f11")
				}
				if err := internal.Json2ReadBool(in, &trueTypeF11Value); err != nil {
					return err
				}
				trueTypeF11Presented = true
			case "f12":
				if rawF12 != nil {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "f12")
				}
				rawF12 = in.Raw()
				if !in.Ok() {
					return in.Error()
				}
			case "f13":
				if rawF13 != nil {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "f13")
				}
				rawF13 = in.Raw()
				if !in.Ok() {
					return in.Error()
				}
			case "f20":
				if propF20Presented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "f20")
				}
				if nat_outer&(1<<0) == 0 {
					return internal.ErrorInvalidJSON("cases.testAllPossibleFieldConfigs", "field 'f20' is defined, while corresponding implicit fieldmask bit is 0")
				}
				if err := internal.Json2ReadInt32(in, &item.F20); err != nil {
					return err
				}
				propF20Presented = true
			case "f21":
				return internal.ErrorInvalidJSON("cases.testAllPossibleFieldConfigs", "implicit true field 'f21' cannot be defined, set fieldmask instead")
			case "f22":
				if rawF22 != nil {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "f22")
				}
				rawF22 = in.Raw()
				if !in.Ok() {
					return in.Error()
				}
			case "f23":
				if rawF23 != nil {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "f23")
				}
				rawF23 = in.Raw()
				if !in.Ok() {
					return in.Error()
				}
			default:
				return internal.ErrorInvalidJSONExcessElement("cases.testAllPossibleFieldConfigs", key)
			}
			in.WantComma()
		}
		in.Delim('}')
		if !in.Ok() {
			return in.Error()
		}
	}
	if !propLocalPresented {
		item.Local = 0
	}
	if !propF00Presented {
		item.F00 = 0
	}
	if !propF10Presented {
		item.F10 = 0
	}
	if !propF20Presented {
		item.F20 = 0
	}
	if propF10Presented {
		item.Local |= 1 << 0
	}
	if trueTypeF11Presented {
		if trueTypeF11Value {
			item.Local |= 1 << 1
		}
	}
	if rawF12 != nil {
		item.Local |= 1 << 2
	}
	if rawF13 != nil {
		item.Local |= 1 << 3
	}
	var inF02Pointer *basictl.JsonLexer
	inF02 := basictl.JsonLexer{Data: rawF02}
	if rawF02 != nil {
		inF02Pointer = &inF02
	}
	if err := tlBuiltinTupleInt.BuiltinTupleIntReadJSONGeneral(tctx, inF02Pointer, &item.F02, item.Local); err != nil {
		return err
	}

	var inF03Pointer *basictl.JsonLexer
	inF03 := basictl.JsonLexer{Data: rawF03}
	if rawF03 != nil {
		inF03Pointer = &inF03
	}
	if err := tlBuiltinTupleInt.BuiltinTupleIntReadJSONGeneral(tctx, inF03Pointer, &item.F03, nat_outer); err != nil {
		return err
	}

	if item.Local&(1<<2) == 0 {
		item.F12 = item.F12[:0]
	} else {
		var inF12Pointer *basictl.JsonLexer
		inF12 := basictl.JsonLexer{Data: rawF12}
		if rawF12 != nil {
			inF12Pointer = &inF12
		}
		if err := tlBuiltinTupleInt.BuiltinTupleIntReadJSONGeneral(tctx, inF12Pointer, &item.F12, item.Local); err != nil {
			return err
		}

	}
	if item.Local&(1<<3) == 0 {
		item.F13 = item.F13[:0]
	} else {
		var inF13Pointer *basictl.JsonLexer
		inF13 := basictl.JsonLexer{Data: rawF13}
		if rawF13 != nil {
			inF13Pointer = &inF13
		}
		if err := tlBuiltinTupleInt.BuiltinTupleIntReadJSONGeneral(tctx, inF13Pointer, &item.F13, nat_outer); err != nil {
			return err
		}

	}
	if nat_outer&(1<<2) == 0 {
		if rawF22 != nil {
			return internal.ErrorInvalidJSON("cases.testAllPossibleFieldConfigs", "field 'f22' is defined, while corresponding implicit fieldmask bit is 0")
		}
		item.F22 = item.F22[:0]
	} else {
		var inF22Pointer *basictl.JsonLexer
		inF22 := basictl.JsonLexer{Data: rawF22}
		if rawF22 != nil {
			inF22Pointer = &inF22
		}
		if err := tlBuiltinTupleInt.BuiltinTupleIntReadJSONGeneral(tctx, inF22Pointer, &item.F22, item.Local); err != nil {
			return err
		}

	}
	if nat_outer&(1<<3) == 0 {
		if rawF23 != nil {
			return internal.ErrorInvalidJSON("cases.testAllPossibleFieldConfigs", "field 'f23' is defined, while corresponding implicit fieldmask bit is 0")
		}
		item.F23 = item.F23[:0]
	} else {
		var inF23Pointer *basictl.JsonLexer
		inF23 := basictl.JsonLexer{Data: rawF23}
		if rawF23 != nil {
			inF23Pointer = &inF23
		}
		if err := tlBuiltinTupleInt.BuiltinTupleIntReadJSONGeneral(tctx, inF23Pointer, &item.F23, nat_outer); err != nil {
			return err
		}

	}
	// tries to set bit to zero if it is 1
	if trueTypeF11Presented && !trueTypeF11Value && (item.Local&(1<<1) != 0) {
		return internal.ErrorInvalidJSON("cases.testAllPossibleFieldConfigs", "fieldmask bit item.Local.1 is indefinite because of the contradictions in values")
	}
	return nil
}

// This method is general version of WriteJSON, use it instead!
func (item *CasesTestAllPossibleFieldConfigs) WriteJSONGeneral(tctx *basictl.JSONWriteContext, w []byte, nat_outer uint32) (_ []byte, err error) {
	return item.WriteJSONOpt(tctx, w, nat_outer)
}

func (item *CasesTestAllPossibleFieldConfigs) WriteJSON(w []byte, nat_outer uint32) (_ []byte, err error) {
	tctx := basictl.JSONWriteContext{}
	return item.WriteJSONOpt(&tctx, w, nat_outer)
}
func (item *CasesTestAllPossibleFieldConfigs) WriteJSONOpt(tctx *basictl.JSONWriteContext, w []byte, nat_outer uint32) (_ []byte, err error) {
	w = append(w, '{')
	backupIndexLocal := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"local":`...)
	w = basictl.JSONWriteUint32(w, item.Local)
	if (item.Local != 0) == false {
		w = w[:backupIndexLocal]
	}
	backupIndexF00 := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"f00":`...)
	w = basictl.JSONWriteInt32(w, item.F00)
	if (item.F00 != 0) == false {
		w = w[:backupIndexF00]
	}
	backupIndexF02 := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"f02":`...)
	if w, err = tlBuiltinTupleInt.BuiltinTupleIntWriteJSONOpt(tctx, w, item.F02, item.Local); err != nil {
		return w, err
	}
	if (len(item.F02) != 0) == false {
		w = w[:backupIndexF02]
	}
	backupIndexF03 := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"f03":`...)
	if w, err = tlBuiltinTupleInt.BuiltinTupleIntWriteJSONOpt(tctx, w, item.F03, nat_outer); err != nil {
		return w, err
	}
	if (len(item.F03) != 0) == false {
		w = w[:backupIndexF03]
	}
	if item.Local&(1<<0) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"f10":`...)
		w = basictl.JSONWriteInt32(w, item.F10)
	}
	if item.Local&(1<<1) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"f11":true`...)
	}
	if item.Local&(1<<2) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"f12":`...)
		if w, err = tlBuiltinTupleInt.BuiltinTupleIntWriteJSONOpt(tctx, w, item.F12, item.Local); err != nil {
			return w, err
		}
	}
	if item.Local&(1<<3) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"f13":`...)
		if w, err = tlBuiltinTupleInt.BuiltinTupleIntWriteJSONOpt(tctx, w, item.F13, nat_outer); err != nil {
			return w, err
		}
	}
	if nat_outer&(1<<0) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"f20":`...)
		w = basictl.JSONWriteInt32(w, item.F20)
	}
	if nat_outer&(1<<2) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"f22":`...)
		if w, err = tlBuiltinTupleInt.BuiltinTupleIntWriteJSONOpt(tctx, w, item.F22, item.Local); err != nil {
			return w, err
		}
	}
	if nat_outer&(1<<3) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"f23":`...)
		if w, err = tlBuiltinTupleInt.BuiltinTupleIntWriteJSONOpt(tctx, w, item.F23, nat_outer); err != nil {
			return w, err
		}
	}
	return append(w, '}'), nil
}
