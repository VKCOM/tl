// Copyright 2025 V Kontakte LLC
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Code generated by vktl/cmd/tlgen2; DO NOT EDIT.
package meta

import (
	"fmt"

	"github.com/vkcom/tl/internal/tlcodegen/test/gen/goldmaster/internal"
	"github.com/vkcom/tl/pkg/basictl"
)

func SchemaGenerator() string { return "(devel)" }
func SchemaURL() string {
	return "https://github.com/VKCOM/tl/blob/master/internal/tlcodegen/test/tls/goldmaster.tl"
}
func SchemaCommit() string    { return "abcdefgh" }
func SchemaTimestamp() uint32 { return 301822800 }

// We can create only types which have zero type arguments and zero nat arguments
type Object interface {
	TLName() string // returns type's TL name. For union, returns constructor name depending on actual union value
	TLTag() uint32  // returns type's TL tag. For union, returns constructor tag depending on actual union value
	String() string // returns type's representation for debugging (JSON for now)

	FillRandom(rg *basictl.RandGenerator)
	Read(w []byte) ([]byte, error)              // reads type's bare TL representation by consuming bytes from the start of w and returns remaining bytes, plus error
	ReadBoxed(w []byte) ([]byte, error)         // same as Read, but reads/checks TLTag first (this method is general version of Write, use it only when you are working with interface)
	WriteGeneral(w []byte) ([]byte, error)      // same as Write, but has common signature (with error) for all objects, so can be called through interface
	WriteBoxedGeneral(w []byte) ([]byte, error) // same as WriteBoxed, but has common signature (with error) for all objects, so can be called through interface

	MarshalJSON() ([]byte, error) // returns type's JSON representation, plus error
	UnmarshalJSON([]byte) error   // reads type's JSON representation

	ReadJSON(legacyTypeNames bool, in *basictl.JsonLexer) error
	// like MarshalJSON, but appends to w and returns it
	// pass empty basictl.JSONWriteContext{} if you do not know which options you need
	WriteJSONGeneral(tctx *basictl.JSONWriteContext, w []byte) ([]byte, error)

	ReadTL2(r []byte, ctx *basictl.TL2ReadContext) ([]byte, error)
	WriteTL2(w []byte, ctx *basictl.TL2WriteContext) []byte
}

type Function interface {
	Object

	FillRandomResult(rg *basictl.RandGenerator, w []byte) ([]byte, error)

	// tctx is for options controlling transcoding short-long version during Long ID and legacyTypeNames->newTypeNames transition
	// pass empty basictl.JSONWriteContext{} if you do not know which options you need
	ReadResultWriteResultJSON(tctx *basictl.JSONWriteContext, r []byte, w []byte) ([]byte, []byte, error) // combination of ReadResult(r) + WriteResultJSON(w). Returns new r, new w, plus error
	ReadResultJSONWriteResult(r []byte, w []byte) ([]byte, []byte, error)                                 // combination of ReadResultJSON(r) + WriteResult(w). Returns new r, new w, plus error

	ReadResultWriteResultTL2(tctx *basictl.TL2WriteContext, r []byte, w []byte) (_ []byte, _ []byte, err error)
	ReadResultTL2WriteResult(tctx *basictl.TL2ReadContext, r []byte, w []byte) (_ []byte, _ []byte, err error)
}

func GetAllTLItems() []TLItem {
	var allItems []TLItem
	for _, item := range itemsByName {
		if item != nil {
			allItems = append(allItems, *item)
		}
	}
	return allItems
}

// for quick one-liners
func GetTLName(tag uint32, notFoundName string) string {
	if item := FactoryItemByTLTag(tag); item != nil {
		return item.TLName()
	}
	return notFoundName
}

type TLItem struct {
	tag         uint32
	annotations uint32
	tlName      string

	hasTL1 bool
	hasTL2 bool

	resultTypeContainsUnionTypes    bool
	argumentsTypesContainUnionTypes bool

	// either createObject != nil or createFunction != nil for object/function respectively
	// also, createFunctionLong can be != nil if there is long adapter (legacy to be removed soon)
	// also, createObjectBytes, createFunctionBytes, createFunctionLongBytes
	// can be != nil independently, if factory_bytes is imported
	createFunction          func() Function
	createFunctionLong      func() Function
	createObject            func() Object
	createFunctionBytes     func() Function
	createFunctionLongBytes func() Function
	createObjectBytes       func() Object
}

func (item TLItem) TLTag() uint32  { return item.tag }
func (item TLItem) TLName() string { return item.tlName }

// true for TL1-originated types
func (item TLItem) HasTL1() bool { return item.hasTL1 }

// true for TL2-originated types and for TL1-originated types if in TL2 generation whitelist
func (item TLItem) HasTL2() bool { return item.hasTL2 }
func (item TLItem) CreateObject() Object {
	if item.createFunction != nil {
		return item.createFunction()
	}
	return item.createObject()
}

// used in TL generator tests only, do not use in product code
func (item TLItem) CreateObjectBytes() Object {
	if item.createFunctionBytes != nil {
		return item.createFunctionBytes()
	}
	if item.createFunction != nil {
		return item.createFunction()
	}
	if item.createObjectBytes != nil {
		return item.createObjectBytes()
	}
	return item.createObject()
}

func (item TLItem) IsFunction() bool         { return item.createFunction != nil }
func (item TLItem) CreateFunction() Function { return item.createFunction() }

// used in TL generator tests only, do not use in product code
func (item TLItem) CreateFunctionBytes() Function {
	if item.createFunctionBytes != nil {
		return item.createFunctionBytes()
	}
	return item.createFunction()
}

func (item TLItem) HasUnionTypesInResult() bool    { return item.resultTypeContainsUnionTypes }
func (item TLItem) HasUnionTypesInArguments() bool { return item.argumentsTypesContainUnionTypes }

// For transcoding short-long version during Long ID transition
func (item TLItem) HasFunctionLong() bool        { return item.createFunctionLong != nil }
func (item TLItem) CreateFunctionLong() Function { return item.createFunctionLong() }

// we simplify interface by commenting this method no one yet needs.
// hopefully it will be removed together with long adapters code
// func (item TLItem) CreateFunctionLongBytes() Function {
//     if item.createFunctionLongBytes != nil {
//         return item.createFunctionLongBytes()
//     }
//     return item.createFunctionLong()
// }

// Annotations
func (item TLItem) AnnotationAny() bool       { return item.annotations&0x1 != 0 }
func (item TLItem) AnnotationInternal() bool  { return item.annotations&0x2 != 0 }
func (item TLItem) AnnotationKphp() bool      { return item.annotations&0x4 != 0 }
func (item TLItem) AnnotationRead() bool      { return item.annotations&0x8 != 0 }
func (item TLItem) AnnotationReadwrite() bool { return item.annotations&0x10 != 0 }
func (item TLItem) AnnotationWrite() bool     { return item.annotations&0x20 != 0 }

// TLItem serves as a single type for all TL1 enum values
func (item *TLItem) Reset()                                {}
func (item *TLItem) FillRandom(rg *basictl.RandGenerator)  {}
func (item *TLItem) Read(w []byte) ([]byte, error)         { return w, nil }
func (item *TLItem) WriteGeneral(w []byte) ([]byte, error) { return w, nil }
func (item *TLItem) Write(w []byte) []byte                 { return w }
func (item *TLItem) ReadBoxed(w []byte) ([]byte, error)    { return basictl.NatReadExactTag(w, item.tag) }
func (item *TLItem) WriteBoxedGeneral(w []byte) ([]byte, error) {
	return basictl.NatWrite(w, item.tag), nil
}
func (item *TLItem) WriteBoxed(w []byte) []byte { return basictl.NatWrite(w, item.tag) }
func (item TLItem) String() string {
	return string(item.WriteJSON(nil))
}
func (item *TLItem) ReadJSON(legacyTypeNames bool, in *basictl.JsonLexer) error {
	in.Delim('{')
	if !in.Ok() {
		return in.Error()
	}
	for !in.IsDelim('}') {
		return internal.ErrorInvalidJSONExcessElement(item.tlName, in.UnsafeFieldName(true))
	}
	in.Delim('}')
	if !in.Ok() {
		return in.Error()
	}
	return nil
}

func (item *TLItem) WriteJSONGeneral(tctx *basictl.JSONWriteContext, w []byte) (_ []byte, err error) {
	return item.WriteJSON(w), nil
}
func (item *TLItem) WriteJSON(w []byte) []byte {
	w = append(w, '{')
	return append(w, '}')
}
func (item *TLItem) MarshalJSON() ([]byte, error) {
	return item.WriteJSON(nil), nil
}
func (item *TLItem) UnmarshalJSON(b []byte) error {
	if err := item.ReadJSON(true, &basictl.JsonLexer{Data: b}); err != nil {
		return internal.ErrorInvalidJSON(item.tlName, err.Error())
	}
	return nil
}

func (item *TLItem) ReadTL2(r []byte, ctx *basictl.TL2ReadContext) ([]byte, error) {
	return r, nil
}

func (item *TLItem) WriteTL2(w []byte, ctx *basictl.TL2WriteContext) []byte {
	return w
}
func FactoryItemByTLTag(tag uint32) *TLItem {
	return itemsByTag[tag]
}

func FactoryItemByTLName(name string) *TLItem {
	return itemsByName[name]
}

var itemsByTag = map[uint32]*TLItem{}

var itemsByName = map[string]*TLItem{}

// Do not call directly, called by factory init code
func SetGlobalFactoryCreateForFunction(name string, createFunction func() Function, createFunctionLong func() Function) {
	item := itemsByName[name]
	if item == nil || item.createFunction == nil { // only replace !nil createFunction
		panic(fmt.Sprintf("factory cannot find function %s to set", name))
	}
	item.createFunction = createFunction
	item.createFunctionLong = createFunctionLong
}

// Do not call directly, called by factory init code
func SetGlobalFactoryCreateForObject(name string, createObject func() Object) {
	item := itemsByName[name]
	if item == nil || item.createObject == nil { // only replace !nil createObject
		panic(fmt.Sprintf("factory cannot find object %s to set", name))
	}
	item.createObject = createObject
}

// Do not call directly, called by factory init code
func SetGlobalFactoryCreateForEnumElement(name string) {
	item := itemsByName[name]
	if item == nil || item.createObject == nil { // only replace !nil createObject
		panic(fmt.Sprintf("factory cannot find enum %s to set", name))
	}
	item.createObject = func() Object { return item }
}

// Do not call directly, called by factory init code
func SetGlobalFactoryCreateForFunctionBytes(name string, createFunctionBytes func() Function, createFunctionLongBytes func() Function) {
	item := itemsByName[name]
	if item == nil || item.createFunction == nil { // only replace !nil createFunction
		panic(fmt.Sprintf("factory cannot find function %s to set", name))
	}
	item.createFunctionBytes = createFunctionBytes
	item.createFunctionLongBytes = createFunctionLongBytes
}

// Do not call directly, called by factory init code
func SetGlobalFactoryCreateForObjectBytes(name string, createObjectBytes func() Object) {
	item := itemsByName[name]
	if item == nil || item.createObject == nil { // only replace !nil createObject
		panic(fmt.Sprintf("factory cannot find object %s to set", name))
	}
	item.createObjectBytes = createObjectBytes
}

func pleaseImportFactoryObject() Object {
	panic("factory functions are not linked to reduce code bloat, please import 'gen/factory' instead of 'gen/meta'.")
}

func pleaseImportFactoryFunction() Function {
	panic("factory functions are not linked to reduce code bloat, please import 'gen/factory' instead of 'gen/meta'.")
}

func fillObject(item *TLItem) {
	itemsByName[item.tlName] = item
	if item.tag != 0 {
		itemsByTag[item.tag] = item
	}
	item.createObject = pleaseImportFactoryObject
}

func fillFunction(item *TLItem) {
	itemsByName[item.tlName] = item
	if item.tag != 0 {
		itemsByTag[item.tag] = item
	}
	item.createFunction = pleaseImportFactoryFunction
}

func init() {
	// TL
	fillObject(&TLItem{tag: 0x623360f3, annotations: 0x0, tlName: "a.blue", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0xf35d7a69, annotations: 0x0, tlName: "a.color", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0x6127e7b8, annotations: 0x0, tlName: "a.green", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0x00000002, annotations: 0x0, tlName: "a.myFalse", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0x00000001, annotations: 0x0, tlName: "a.myTrue", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0xb83a723d, annotations: 0x0, tlName: "a.red", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0x7082d18f, annotations: 0x0, tlName: "a.top2", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0xa7662843, annotations: 0x0, tlName: "a.uNionA", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0x944aaa97, annotations: 0x0, tlName: "ab.alias", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillFunction(&TLItem{tag: 0x20c5fb2d, annotations: 0x8, tlName: "ab.call1", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillFunction(&TLItem{tag: 0x8db2a4f8, annotations: 0x8, tlName: "ab.call10", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: true, argumentsTypesContainUnionTypes: false})
	fillFunction(&TLItem{tag: 0xecb2a36c, annotations: 0x8, tlName: "ab.call11", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: true, argumentsTypesContainUnionTypes: true})
	fillFunction(&TLItem{tag: 0x77d5f057, annotations: 0x8, tlName: "ab.call2", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillFunction(&TLItem{tag: 0x0a083445, annotations: 0x8, tlName: "ab.call3", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillFunction(&TLItem{tag: 0xc1220a1e, annotations: 0x8, tlName: "ab.call4", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillFunction(&TLItem{tag: 0x7ba4d28d, annotations: 0x8, tlName: "ab.call5", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillFunction(&TLItem{tag: 0x84d815cb, annotations: 0x8, tlName: "ab.call6", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillFunction(&TLItem{tag: 0x46ec10bf, annotations: 0x8, tlName: "ab.call7", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillFunction(&TLItem{tag: 0x1b8652d9, annotations: 0x8, tlName: "ab.call8", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillFunction(&TLItem{tag: 0x75de906c, annotations: 0x8, tlName: "ab.call9", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0x7651b1ac, annotations: 0x0, tlName: "ab.code", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0x14a35d80, annotations: 0x0, tlName: "ab.counterChangeRequestPeriodsMany", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0xd9c36de5, annotations: 0x0, tlName: "ab.counterChangeRequestPeriodsOne", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0x1ec6a63e, annotations: 0x0, tlName: "ab.empty", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0xe0e96c86, annotations: 0x0, tlName: "ab.myType", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0x4dac492a, annotations: 0x0, tlName: "ab.testMaybe", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0xe67bce28, annotations: 0x0, tlName: "ab.topLevel1", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0xcef933fb, annotations: 0x0, tlName: "ab.topLevel2", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0xa99fef6a, annotations: 0x0, tlName: "ab.typeA", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0xff2e6d58, annotations: 0x0, tlName: "ab.typeB", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0x69920d6e, annotations: 0x0, tlName: "ab.typeC", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0x76615bf1, annotations: 0x0, tlName: "ab.typeD", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0x71687381, annotations: 0x0, tlName: "ab.useCycle", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0x3325d884, annotations: 0x0, tlName: "ab.useDictString", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0xdf61f632, annotations: 0x0, tlName: "au.nionA", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0xa9471844, annotations: 0x0, tlName: "b.red", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillFunction(&TLItem{tag: 0xa7302fbc, annotations: 0x8, tlName: "call1", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillFunction(&TLItem{tag: 0xf02024c6, annotations: 0x8, tlName: "call2", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillFunction(&TLItem{tag: 0x6ace6718, annotations: 0x8, tlName: "call3", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillFunction(&TLItem{tag: 0x46d7de8f, annotations: 0x8, tlName: "call4", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillFunction(&TLItem{tag: 0xfc51061c, annotations: 0x8, tlName: "call5", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillFunction(&TLItem{tag: 0xe41e4696, annotations: 0x8, tlName: "call6", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillFunction(&TLItem{tag: 0x262a43e2, annotations: 0x8, tlName: "call7", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillFunction(&TLItem{tag: 0x7b400184, annotations: 0x8, tlName: "call8", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillFunction(&TLItem{tag: 0x67a0d62d, annotations: 0x8, tlName: "call9", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0xeab6a6b4, annotations: 0x0, tlName: "cd.myType", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0x8c202f64, annotations: 0x0, tlName: "cd.response", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0x5cd1ca89, annotations: 0x0, tlName: "cd.topLevel3", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0xa831a920, annotations: 0x0, tlName: "cd.typeA", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0x377b4996, annotations: 0x0, tlName: "cd.typeB", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0xdb0f93d4, annotations: 0x0, tlName: "cd.typeC", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0xb5528285, annotations: 0x0, tlName: "cd.typeD", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0x6ed67ca0, annotations: 0x0, tlName: "cd.useCycle", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillFunction(&TLItem{tag: 0x3f5a4651, annotations: 0x4, tlName: "curl.request", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: true, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0xaf514651, annotations: 0x0, tlName: "curl.responseError", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0x57d7a33a, annotations: 0x0, tlName: "curl.responseOk", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0x136ecc9e, annotations: 0x0, tlName: "cyc1.myCycle", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0xfba5eecb, annotations: 0x0, tlName: "cyc2.myCycle", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0x47866860, annotations: 0x0, tlName: "cyc3.myCycle", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0xc867fae3, annotations: 0x0, tlName: "cycleTuple", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0x647ddaf5, annotations: 0x0, tlName: "halfStr", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0x12ab5219, annotations: 0x0, tlName: "hren", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0xa8509bda, annotations: 0x0, tlName: "int", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0x7934e71f, annotations: 0x0, tlName: "int32s", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0xf5609de0, annotations: 0x0, tlName: "int64s", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0x22076cba, annotations: 0x0, tlName: "long", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0xc457763c, annotations: 0x0, tlName: "maybeTest1", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0x0e1ae81e, annotations: 0x0, tlName: "multiPoint", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0xba59e151, annotations: 0x0, tlName: "myInt32", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0x1d95db9d, annotations: 0x0, tlName: "myInt64", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0xc60c1b41, annotations: 0x0, tlName: "myNat", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0x79e0c6df, annotations: 0x0, tlName: "myPlus", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0x692c291b, annotations: 0x0, tlName: "myPlus3", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0x8d868379, annotations: 0x0, tlName: "myZero", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0x103a40cf, annotations: 0x0, tlName: "myZero3", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0x344ddf50, annotations: 0x0, tlName: "nativeWrappers", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0x3a728324, annotations: 0x0, tlName: "noStr", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0xebb26b29, annotations: 0x0, tlName: "replace", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0xf46f9b9b, annotations: 0x0, tlName: "replace17", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0xe2d4ebee, annotations: 0x0, tlName: "replace2", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0x51e324e4, annotations: 0x0, tlName: "replace3", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0x8b5bc78a, annotations: 0x0, tlName: "replace5", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0xabd49d06, annotations: 0x0, tlName: "replace6", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0xff8f7db8, annotations: 0x0, tlName: "service5.emptyOutput", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillFunction(&TLItem{tag: 0x7cf362ba, annotations: 0x10, tlName: "service5.insert", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: true, argumentsTypesContainUnionTypes: false})
	fillFunction(&TLItem{tag: 0x7cf362bc, annotations: 0x10, tlName: "service5.insertList", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: true, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0xff8f7db9, annotations: 0x0, tlName: "service5Long.emptyOutput", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillFunction(&TLItem{tag: 0x7cf362bb, annotations: 0x10, tlName: "service5Long.insert", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: true, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0xdc170ff7, annotations: 0x0, tlName: "service5Long.stringOutput", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0xdc170ff4, annotations: 0x0, tlName: "service5.stringOutput", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0xb5286e24, annotations: 0x0, tlName: "string", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0x88920e90, annotations: 0x0, tlName: "testMaybe", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0x0aa03cf2, annotations: 0x0, tlName: "testMaybe2", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0x3fedd339, annotations: 0x0, tlName: "true", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0x157673c1, annotations: 0x0, tlName: "typeA", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0x9d024802, annotations: 0x0, tlName: "typeB", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0x6b8ef43f, annotations: 0x0, tlName: "typeC", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0xb1f4369e, annotations: 0x0, tlName: "typeD", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0x742161d2, annotations: 0x0, tlName: "unionArgsUse", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0xfb9ce817, annotations: 0x0, tlName: "useDictUgly", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0x0a63ec5f, annotations: 0x0, tlName: "useResponse", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0x9aa3dee5, annotations: 0x0, tlName: "useStr", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillObject(&TLItem{tag: 0xdfdd4180, annotations: 0x0, tlName: "useTrue", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
	fillFunction(&TLItem{tag: 0x3c857e52, annotations: 0x10, tlName: "usefulService.getUserEntity", hasTL1: true, hasTL2: true, resultTypeContainsUnionTypes: false, argumentsTypesContainUnionTypes: false})
}
