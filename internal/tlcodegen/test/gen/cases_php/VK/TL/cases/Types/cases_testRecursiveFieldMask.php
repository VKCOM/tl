<?php

/**
 * AUTOGENERATED, DO NOT EDIT! If you want to modify it, check tl schema.
 *
 * This autogenerated code represents tl class for typed RPC API.
 */

namespace VK\TL\cases\Types;

use VK\TL;

/**
 * @kphp-tl-class
 */
class cases_testRecursiveFieldMask implements TL\Readable, TL\Writeable {

  /** Field mask for $f1 field */
  const BIT_F1_0 = (1 << 0);

  /** Field mask for $f2 field */
  const BIT_F2_1 = (1 << 1);

  /** Field mask for $t1 field */
  const BIT_T1_0 = (1 << 0);

  /** Field mask for $t2 field */
  const BIT_T2_1 = (1 << 1);

  /** Field mask for $t3 field */
  const BIT_T3_2 = (1 << 2);

  /** @var int */
  public $f0 = 0;

  /** @var int|null */
  public $f1 = null;

  /** @var int|null */
  public $f2 = null;

  /** @var boolean */
  public $t1 = false;

  /** @var boolean */
  public $t2 = false;

  /** @var boolean */
  public $t3 = false;

  /**
   * @param int $f0
   */
  public function __construct($f0 = 0) {
    $this->f0 = $f0;
  }

  /**
   * @param TL\tl_input_stream $stream
   * @return bool 
   */
  public function read_boxed($stream) {
    [$magic, $success] = $stream->read_uint32();
    if (!$success || $magic != 0xc58cf85e) {
      return false;
    }
    return $this->read($stream);
  }

  /**
   * @param TL\tl_input_stream $stream
   * @return bool 
   */
  public function read($stream) {
    [$this->f0, $success] = $stream->read_uint32();
    if (!$success) {
      return false;
    }
    if (($this->f0 & (1 << 0)) != 0) {
      [$this->f1, $success] = $stream->read_uint32();
      if (!$success) {
        return false;
      }
    } else {
      $this->f1 = null;
    }
    if (($this->f1 & (1 << 1)) != 0) {
      [$this->f2, $success] = $stream->read_uint32();
      if (!$success) {
        return false;
      }
    } else {
      $this->f2 = null;
    }
    if (($this->f0 & (1 << 0)) != 0) {
      $this->t1 = true;
    } else {
      $this->t1 = false;
    }
    if (($this->f1 & (1 << 1)) != 0) {
      $this->t2 = true;
    } else {
      $this->t2 = false;
    }
    if (($this->f2 & (1 << 2)) != 0) {
      $this->t3 = true;
    } else {
      $this->t3 = false;
    }
    return true;
  }

  /**
   * @param TL\tl_output_stream $stream
   * @return bool 
   */
  public function write_boxed($stream) {
    $success = $stream->write_uint32(0xc58cf85e);
    if (!$success) {
      return false;
    }
    return $this->write($stream);
  }

  /**
   * @param TL\tl_output_stream $stream
   * @return bool 
   */
  public function write($stream) {
    $success = $stream->write_uint32($this->f0);
    if (!$success) {
      return false;
    }
    if (($this->f0 & (1 << 0)) != 0) {
      $success = $stream->write_uint32($this->f1);
      if (!$success) {
        return false;
      }
    }
    if (($this->f1 & (1 << 1)) != 0) {
      $success = $stream->write_uint32($this->f2);
      if (!$success) {
        return false;
      }
    }
    return true;
  }

  /**
   * @return int
   */
  public function calculateF0() {
    $mask = 0;

    if (!is_null($this->f1) && $this->t1) {
      $mask |= (self::BIT_F1_0 | self::BIT_T1_0);
    }

    return $mask;
  }

  /**
   * @return int
   */
  public function calculateF1() {
    $mask = 0;

    if (!is_null($this->f2) && $this->t2) {
      $mask |= (self::BIT_F2_1 | self::BIT_T2_1);
    }

    return $mask;
  }

  /**
   * @return int
   */
  public function calculateF2() {
    $mask = 0;

    if ($this->t3) {
      $mask |= self::BIT_T3_2;
    }

    return $mask;
  }

}
