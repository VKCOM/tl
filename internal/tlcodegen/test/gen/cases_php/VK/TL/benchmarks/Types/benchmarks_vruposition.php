<?php

/**
 * AUTOGENERATED, DO NOT EDIT! If you want to modify it, check tl schema.
 *
 * This autogenerated code represents tl class for typed RPC API.
 */

namespace VK\TL\benchmarks\Types;

use VK\TL;

/**
 * @kphp-tl-class
 */
class benchmarks_vruposition implements TL\Readable, TL\Writeable {

  /** Field mask for $commit_bit field */
  const BIT_COMMIT_BIT_0 = (1 << 0);

  /** Field mask for $meta_block field */
  const BIT_META_BLOCK_1 = (1 << 1);

  /** Field mask for $split_payload field */
  const BIT_SPLIT_PAYLOAD_3 = (1 << 3);

  /** Field mask for $rotation_block field */
  const BIT_ROTATION_BLOCK_5 = (1 << 5);

  /** Field mask for $canonical_hash field */
  const BIT_CANONICAL_HASH_15 = (1 << 15);

  /** Field mask for $seq_number field */
  const BIT_SEQ_NUMBER_14 = (1 << 14);

  /** @var int */
  public $fields_mask = 0;

  /** @var boolean */
  public $commit_bit = false;

  /** @var boolean */
  public $meta_block = false;

  /** @var boolean */
  public $split_payload = false;

  /** @var boolean */
  public $rotation_block = false;

  /** @var boolean */
  public $canonical_hash = false;

  /** @var int */
  public $payload_offset = 0;

  /** @var int */
  public $block_time_nano = 0;

  /** @var TL\benchmarks\Types\benchmarks_vruhash */
  public $hash = null;

  /** @var int */
  public $file_offset = 0;

  /** @var int|null */
  public $seq_number = null;

  /**
   * @param int $fields_mask
   * @param int $payload_offset
   * @param int $block_time_nano
   * @param TL\benchmarks\Types\benchmarks_vruhash $hash
   * @param int $file_offset
   */
  public function __construct($fields_mask = 0, $payload_offset = 0, $block_time_nano = 0, $hash = null, $file_offset = 0) {
    $this->fields_mask = $fields_mask;
    $this->payload_offset = $payload_offset;
    $this->block_time_nano = $block_time_nano;
    $this->hash = $hash;
    $this->file_offset = $file_offset;
  }

  /**
   * @param TL\tl_input_stream $stream
   * @return bool 
   */
  public function read_boxed($stream) {
    [$magic, $success] = $stream->read_uint32();
    if (!$success || $magic != 0x32792c04) {
      return false;
    }
    return $this->read($stream);
  }

  /**
   * @param TL\tl_input_stream $stream
   * @return bool 
   */
  public function read($stream) {
    [$this->fields_mask, $success] = $stream->read_uint32();
    if (!$success) {
      return false;
    }
    if (($this->fields_mask & (1 << 0)) != 0) {
      $this->commit_bit = true;
    } else {
      $this->commit_bit = false;
    }
    if (($this->fields_mask & (1 << 1)) != 0) {
      $this->meta_block = true;
    } else {
      $this->meta_block = false;
    }
    if (($this->fields_mask & (1 << 3)) != 0) {
      $this->split_payload = true;
    } else {
      $this->split_payload = false;
    }
    if (($this->fields_mask & (1 << 5)) != 0) {
      $this->rotation_block = true;
    } else {
      $this->rotation_block = false;
    }
    if (($this->fields_mask & (1 << 15)) != 0) {
      $this->canonical_hash = true;
    } else {
      $this->canonical_hash = false;
    }
    [$this->payload_offset, $success] = $stream->read_int64();
    if (!$success) {
      return false;
    }
    [$this->block_time_nano, $success] = $stream->read_int64();
    if (!$success) {
      return false;
    }
    if (is_null($this->hash)) {
      $this->hash = new TL\benchmarks\Types\benchmarks_vruhash();
    }
    $success = $this->hash->read($stream);
    if (!$success) {
      return false;
    }
    [$this->file_offset, $success] = $stream->read_int64();
    if (!$success) {
      return false;
    }
    if (($this->fields_mask & (1 << 14)) != 0) {
      [$this->seq_number, $success] = $stream->read_int64();
      if (!$success) {
        return false;
      }
    } else {
      $this->seq_number = null;
    }
    return true;
  }

  /**
   * @param TL\tl_output_stream $stream
   * @return bool 
   */
  public function write_boxed($stream) {
    $success = $stream->write_uint32(0x32792c04);
    if (!$success) {
      return false;
    }
    return $this->write($stream);
  }

  /**
   * @param TL\tl_output_stream $stream
   * @return bool 
   */
  public function write($stream) {
    $success = $stream->write_uint32($this->fields_mask);
    if (!$success) {
      return false;
    }
    $success = $stream->write_int64($this->payload_offset);
    if (!$success) {
      return false;
    }
    $success = $stream->write_int64($this->block_time_nano);
    if (!$success) {
      return false;
    }
    if (is_null($this->hash)) {
      $this->hash = new TL\benchmarks\Types\benchmarks_vruhash();
    }
    $success = $this->hash->write($stream);
    if (!$success) {
      return false;
    }
    $success = $stream->write_int64($this->file_offset);
    if (!$success) {
      return false;
    }
    if (($this->fields_mask & (1 << 14)) != 0) {
      $success = $stream->write_int64($this->seq_number);
      if (!$success) {
        return false;
      }
    }
    return true;
  }

  /**
   * @return int
   */
  public function calculateFieldsMask() {
    $mask = 0;

    if ($this->commit_bit) {
      $mask |= self::BIT_COMMIT_BIT_0;
    }

    if ($this->meta_block) {
      $mask |= self::BIT_META_BLOCK_1;
    }

    if ($this->split_payload) {
      $mask |= self::BIT_SPLIT_PAYLOAD_3;
    }

    if ($this->rotation_block) {
      $mask |= self::BIT_ROTATION_BLOCK_5;
    }

    if ($this->seq_number !== null) {
      $mask |= self::BIT_SEQ_NUMBER_14;
    }

    if ($this->canonical_hash) {
      $mask |= self::BIT_CANONICAL_HASH_15;
    }

    return $mask;
  }

}
