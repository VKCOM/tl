// Code generated by vktl/cmd/tlgen2; DO NOT EDIT.
#include "unique/headers/unique.stringToInt.h"
#include "unique/headers/unique.get.h"
#include "__common_namespace/headers/int.h"


bool tlgen::unique::Get::write_json(std::ostream& s)const {
  if (!::tlgen::details::UniqueGetWriteJSON(s, *this)) { return false; }
  return true;
}

bool tlgen::unique::Get::read(::tlgen::basictl::tl_istream & s) noexcept {
  if (!::tlgen::details::UniqueGetRead(s, *this)) { return s.set_error_unknown_scenario(); }
  s.sync();
  return true;
}

bool tlgen::unique::Get::write(::tlgen::basictl::tl_ostream & s) const noexcept {
  if (!::tlgen::details::UniqueGetWrite(s, *this)) { return s.set_error_unknown_scenario(); }
  s.sync();
  return true;
}

void tlgen::unique::Get::read(::tlgen::basictl::tl_throwable_istream & s) {
  ::tlgen::basictl::tl_istream s2(s);
  this->read(s2);
  s2.pass_data(s);
}

void tlgen::unique::Get::write(::tlgen::basictl::tl_throwable_ostream & s) const {
  ::tlgen::basictl::tl_ostream s2(s);
  this->write(s2);
  s2.pass_data(s);
}

bool tlgen::unique::Get::read_boxed(::tlgen::basictl::tl_istream & s) noexcept {
  if (!::tlgen::details::UniqueGetReadBoxed(s, *this)) { return s.set_error_unknown_scenario(); }
  s.sync();
  return true;
}

bool tlgen::unique::Get::write_boxed(::tlgen::basictl::tl_ostream & s) const noexcept {
  if (!::tlgen::details::UniqueGetWriteBoxed(s, *this)) { return s.set_error_unknown_scenario(); }
  s.sync();
  return true;
}

void tlgen::unique::Get::read_boxed(::tlgen::basictl::tl_throwable_istream & s) {
  ::tlgen::basictl::tl_istream s2(s);
  this->read_boxed(s2);
  s2.pass_data(s);
}

void tlgen::unique::Get::write_boxed(::tlgen::basictl::tl_throwable_ostream & s) const {
  ::tlgen::basictl::tl_ostream s2(s);
  this->write_boxed(s2);
  s2.pass_data(s);
}

void tlgen::details::UniqueGetReset(::tlgen::unique::Get& item) noexcept {
  (void)item;
  item.key.clear();
}

bool tlgen::details::UniqueGetWriteJSON(std::ostream& s, const ::tlgen::unique::Get& item) noexcept {
  (void)s;
  (void)item;
  s << "{";
  if (item.key.size() != 0) {
    s << "\"key\":";
    s << "\"" << item.key << "\"";
  }
  s << "}";
  return true;
}

bool tlgen::details::UniqueGetRead(::tlgen::basictl::tl_istream & s, ::tlgen::unique::Get& item) noexcept {
  (void)s;
  (void)item;
  if (!s.string_read(item.key)) { return false; }
  return true;
}

bool tlgen::details::UniqueGetWrite(::tlgen::basictl::tl_ostream & s, const ::tlgen::unique::Get& item) noexcept {
  (void)s;
  (void)item;
  if (!s.string_write(item.key)) { return false;}
  return true;
}

bool tlgen::details::UniqueGetReadBoxed(::tlgen::basictl::tl_istream & s, ::tlgen::unique::Get& item) {
  if (!s.nat_read_exact_tag(0xce89bbf2)) { return false; }
  return tlgen::details::UniqueGetRead(s, item);
}

bool tlgen::details::UniqueGetWriteBoxed(::tlgen::basictl::tl_ostream & s, const ::tlgen::unique::Get& item) {
  if (!s.nat_write(0xce89bbf2)) { return false; }
  return tlgen::details::UniqueGetWrite(s, item);
}

bool tlgen::details::UniqueGetReadResult(::tlgen::basictl::tl_istream & s, const tlgen::unique::Get& item, std::optional<int32_t>& result) {
  (void)s;
  (void)item;
  (void)result;
  if (!::tlgen::details::IntMaybeReadBoxed(s, result)) { return false; }
  return true;
}
bool tlgen::details::UniqueGetWriteResult(::tlgen::basictl::tl_ostream & s, const tlgen::unique::Get& item, const std::optional<int32_t>& result) {
  (void)s;
  (void)item;
  (void)result;
  if (!::tlgen::details::IntMaybeWriteBoxed(s, result)) { return false; }
  return true;
}

bool tlgen::unique::Get::read_result(::tlgen::basictl::tl_istream & s, std::optional<int32_t> & result) const noexcept {
  bool success = tlgen::details::UniqueGetReadResult(s, *this, result);
  s.sync();
  return success;
}
bool tlgen::unique::Get::write_result(::tlgen::basictl::tl_ostream & s, const std::optional<int32_t> & result) const noexcept {
  bool success = tlgen::details::UniqueGetWriteResult(s, *this, result);
  s.sync();
  return success;
}

void tlgen::unique::Get::read_result(::tlgen::basictl::tl_throwable_istream & s, std::optional<int32_t> & result) const {
  ::tlgen::basictl::tl_istream s2(s);
  this->read_result(s2, result);
  s2.pass_data(s);
}
void tlgen::unique::Get::write_result(::tlgen::basictl::tl_throwable_ostream & s, const std::optional<int32_t> & result) const {
  ::tlgen::basictl::tl_ostream s2(s);
  this->write_result(s2, result);
  s2.pass_data(s);
}

bool tlgen::unique::StringToInt::write_json(std::ostream& s)const {
  if (!::tlgen::details::UniqueStringToIntWriteJSON(s, *this)) { return false; }
  return true;
}

bool tlgen::unique::StringToInt::read(::tlgen::basictl::tl_istream & s) noexcept {
  if (!::tlgen::details::UniqueStringToIntRead(s, *this)) { return s.set_error_unknown_scenario(); }
  s.sync();
  return true;
}

bool tlgen::unique::StringToInt::write(::tlgen::basictl::tl_ostream & s) const noexcept {
  if (!::tlgen::details::UniqueStringToIntWrite(s, *this)) { return s.set_error_unknown_scenario(); }
  s.sync();
  return true;
}

void tlgen::unique::StringToInt::read(::tlgen::basictl::tl_throwable_istream & s) {
  ::tlgen::basictl::tl_istream s2(s);
  this->read(s2);
  s2.pass_data(s);
}

void tlgen::unique::StringToInt::write(::tlgen::basictl::tl_throwable_ostream & s) const {
  ::tlgen::basictl::tl_ostream s2(s);
  this->write(s2);
  s2.pass_data(s);
}

bool tlgen::unique::StringToInt::read_boxed(::tlgen::basictl::tl_istream & s) noexcept {
  if (!::tlgen::details::UniqueStringToIntReadBoxed(s, *this)) { return s.set_error_unknown_scenario(); }
  s.sync();
  return true;
}

bool tlgen::unique::StringToInt::write_boxed(::tlgen::basictl::tl_ostream & s) const noexcept {
  if (!::tlgen::details::UniqueStringToIntWriteBoxed(s, *this)) { return s.set_error_unknown_scenario(); }
  s.sync();
  return true;
}

void tlgen::unique::StringToInt::read_boxed(::tlgen::basictl::tl_throwable_istream & s) {
  ::tlgen::basictl::tl_istream s2(s);
  this->read_boxed(s2);
  s2.pass_data(s);
}

void tlgen::unique::StringToInt::write_boxed(::tlgen::basictl::tl_throwable_ostream & s) const {
  ::tlgen::basictl::tl_ostream s2(s);
  this->write_boxed(s2);
  s2.pass_data(s);
}

void tlgen::details::UniqueStringToIntReset(::tlgen::unique::StringToInt& item) noexcept {
  (void)item;
  item.key.clear();
}

bool tlgen::details::UniqueStringToIntWriteJSON(std::ostream& s, const ::tlgen::unique::StringToInt& item) noexcept {
  (void)s;
  (void)item;
  s << "{";
  if (item.key.size() != 0) {
    s << "\"key\":";
    s << "\"" << item.key << "\"";
  }
  s << "}";
  return true;
}

bool tlgen::details::UniqueStringToIntRead(::tlgen::basictl::tl_istream & s, ::tlgen::unique::StringToInt& item) noexcept {
  (void)s;
  (void)item;
  if (!s.string_read(item.key)) { return false; }
  return true;
}

bool tlgen::details::UniqueStringToIntWrite(::tlgen::basictl::tl_ostream & s, const ::tlgen::unique::StringToInt& item) noexcept {
  (void)s;
  (void)item;
  if (!s.string_write(item.key)) { return false;}
  return true;
}

bool tlgen::details::UniqueStringToIntReadBoxed(::tlgen::basictl::tl_istream & s, ::tlgen::unique::StringToInt& item) {
  if (!s.nat_read_exact_tag(0x0f766c35)) { return false; }
  return tlgen::details::UniqueStringToIntRead(s, item);
}

bool tlgen::details::UniqueStringToIntWriteBoxed(::tlgen::basictl::tl_ostream & s, const ::tlgen::unique::StringToInt& item) {
  if (!s.nat_write(0x0f766c35)) { return false; }
  return tlgen::details::UniqueStringToIntWrite(s, item);
}

bool tlgen::details::UniqueStringToIntReadResult(::tlgen::basictl::tl_istream & s, const tlgen::unique::StringToInt& item, int32_t& result) {
  (void)s;
  (void)item;
  (void)result;
  if (!s.nat_read_exact_tag(0xa8509bda)) { return false; }
  if (!s.int_read(result)) { return false; }
  return true;
}
bool tlgen::details::UniqueStringToIntWriteResult(::tlgen::basictl::tl_ostream & s, const tlgen::unique::StringToInt& item, const int32_t& result) {
  (void)s;
  (void)item;
  (void)result;
  if (!s.nat_write(0xa8509bda)) { return false; }
  if (!s.int_write(result)) { return false;}
  return true;
}

bool tlgen::unique::StringToInt::read_result(::tlgen::basictl::tl_istream & s, int32_t & result) const noexcept {
  bool success = tlgen::details::UniqueStringToIntReadResult(s, *this, result);
  s.sync();
  return success;
}
bool tlgen::unique::StringToInt::write_result(::tlgen::basictl::tl_ostream & s, const int32_t & result) const noexcept {
  bool success = tlgen::details::UniqueStringToIntWriteResult(s, *this, result);
  s.sync();
  return success;
}

void tlgen::unique::StringToInt::read_result(::tlgen::basictl::tl_throwable_istream & s, int32_t & result) const {
  ::tlgen::basictl::tl_istream s2(s);
  this->read_result(s2, result);
  s2.pass_data(s);
}
void tlgen::unique::StringToInt::write_result(::tlgen::basictl::tl_throwable_ostream & s, const int32_t & result) const {
  ::tlgen::basictl::tl_ostream s2(s);
  this->write_result(s2, result);
  s2.pass_data(s);
}
