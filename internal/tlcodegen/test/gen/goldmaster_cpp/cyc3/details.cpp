// Code generated by vktl/cmd/tlgen2; DO NOT EDIT.
#include "cyc3/headers/cyc3_vector.h"
#include "cyc1/headers/cyc1.myCycle.h"
#include "cyc3/headers/cyc3.myCycle.h"
#include "cyc3/headers/cyc3_cyc1.myCycle.h"


void tlgen::details::BuiltinVectorCyc1MyCycleReset(std::vector<::tlgen::cyc1::MyCycle>& item) {
  item.resize(0); // TODO - unwrap
}

bool tlgen::details::BuiltinVectorCyc1MyCycleWriteJSON(std::ostream & s, const std::vector<::tlgen::cyc1::MyCycle>& item) {
  s << "[";
  size_t index = 0;
  for(const auto & el : item) {
    if (!::tlgen::details::Cyc1MyCycleWriteJSON(s, el)) { return false; }
    if (index != item.size() - 1) {
      s << ",";
    }
    index++;
  }
  s << "]";
  return true;
}

bool tlgen::details::BuiltinVectorCyc1MyCycleRead(::tlgen::basictl::tl_istream & s, std::vector<::tlgen::cyc1::MyCycle>& item) {
  uint32_t len = 0;
  if (!s.nat_read(len)) { return false; }
  // TODO - check length sanity
  item.resize(len);
  for(auto && el : item) {
    if (!::tlgen::details::Cyc1MyCycleRead(s, el)) { return s.set_error_unknown_scenario(); }
  }
  return true;
}

bool tlgen::details::BuiltinVectorCyc1MyCycleWrite(::tlgen::basictl::tl_ostream & s, const std::vector<::tlgen::cyc1::MyCycle>& item) {
  if (!s.nat_write(item.size())) { return false; }
  for(const auto & el : item) {
    if (!::tlgen::details::Cyc1MyCycleWrite(s, el)) { return s.set_error_unknown_scenario(); }
  }
  return true;
}

bool tlgen::cyc3::MyCycle::write_json(std::ostream& s)const {
  if (!::tlgen::details::Cyc3MyCycleWriteJSON(s, *this)) { return false; }
  return true;
}

bool tlgen::cyc3::MyCycle::read(::tlgen::basictl::tl_istream & s) noexcept {
  if (!::tlgen::details::Cyc3MyCycleRead(s, *this)) { return s.set_error_unknown_scenario(); }
  s.sync();
  return true;
}

bool tlgen::cyc3::MyCycle::write(::tlgen::basictl::tl_ostream & s)const noexcept {
  if (!::tlgen::details::Cyc3MyCycleWrite(s, *this)) { return s.set_error_unknown_scenario(); }
  s.sync();
  return true;
}

void tlgen::cyc3::MyCycle::read(::tlgen::basictl::tl_throwable_istream & s) {
  ::tlgen::basictl::tl_istream s2(s);
  this->read(s2);
  s2.pass_data(s);
}

void tlgen::cyc3::MyCycle::write(::tlgen::basictl::tl_throwable_ostream & s)const {
  ::tlgen::basictl::tl_ostream s2(s);
  this->write(s2);
  s2.pass_data(s);
}

bool tlgen::cyc3::MyCycle::read_boxed(::tlgen::basictl::tl_istream & s) noexcept {
  if (!::tlgen::details::Cyc3MyCycleReadBoxed(s, *this)) { return s.set_error_unknown_scenario(); }
  s.sync();
  return true;
}

bool tlgen::cyc3::MyCycle::write_boxed(::tlgen::basictl::tl_ostream & s)const noexcept {
  if (!::tlgen::details::Cyc3MyCycleWriteBoxed(s, *this)) { return s.set_error_unknown_scenario(); }
  s.sync();
  return true;
}

void tlgen::cyc3::MyCycle::read_boxed(::tlgen::basictl::tl_throwable_istream & s) {
  ::tlgen::basictl::tl_istream s2(s);
  this->read_boxed(s2);
  s2.pass_data(s);
}

void tlgen::cyc3::MyCycle::write_boxed(::tlgen::basictl::tl_throwable_ostream & s)const {
  ::tlgen::basictl::tl_ostream s2(s);
  this->write_boxed(s2);
  s2.pass_data(s);
}

void tlgen::details::Cyc3MyCycleReset(::tlgen::cyc3::MyCycle& item) noexcept {
  (void)item;
  item.fields_mask = 0;
  item.a.clear();
}

bool tlgen::details::Cyc3MyCycleWriteJSON(std::ostream& s, const ::tlgen::cyc3::MyCycle& item) noexcept {
  (void)s;
  (void)item;
  auto add_comma = false;
  s << "{";
  if (item.fields_mask != 0) {
    add_comma = true;
    s << "\"fields_mask\":";
    s << item.fields_mask;
  }
  if (item.a.size() != 0) {
    if (add_comma) {
      s << ",";
    }
    add_comma = true;
    s << "\"a\":";
    if (!::tlgen::details::BuiltinVectorCyc1MyCycleWriteJSON(s, item.a)) { return false; }
  }
  s << "}";
  return true;
}

bool tlgen::details::Cyc3MyCycleRead(::tlgen::basictl::tl_istream & s, ::tlgen::cyc3::MyCycle& item) noexcept {
  (void)s;
  (void)item;
  if (!s.nat_read(item.fields_mask)) { return false; }
  if (!::tlgen::details::BuiltinVectorCyc1MyCycleRead(s, item.a)) { return false; }
  return true;
}

bool tlgen::details::Cyc3MyCycleWrite(::tlgen::basictl::tl_ostream & s, const ::tlgen::cyc3::MyCycle& item) noexcept {
  (void)s;
  (void)item;
  if (!s.nat_write(item.fields_mask)) { return false;}
  if (!::tlgen::details::BuiltinVectorCyc1MyCycleWrite(s, item.a)) { return false; }
  return true;
}

bool tlgen::details::Cyc3MyCycleReadBoxed(::tlgen::basictl::tl_istream & s, ::tlgen::cyc3::MyCycle& item) {
  if (!s.nat_read_exact_tag(0x47866860)) { return false; }
  return tlgen::details::Cyc3MyCycleRead(s, item);
}

bool tlgen::details::Cyc3MyCycleWriteBoxed(::tlgen::basictl::tl_ostream & s, const ::tlgen::cyc3::MyCycle& item) {
  if (!s.nat_write(0x47866860)) { return false; }
  return tlgen::details::Cyc3MyCycleWrite(s, item);
}

void tlgen::details::VectorCyc1MyCycleReset(std::vector<::tlgen::cyc1::MyCycle>& item) noexcept {
  (void)item;
  item.clear();
}

bool tlgen::details::VectorCyc1MyCycleWriteJSON(std::ostream& s, const std::vector<::tlgen::cyc1::MyCycle>& item) noexcept {
  (void)s;
  (void)item;
  if (!::tlgen::details::BuiltinVectorCyc1MyCycleWriteJSON(s, item)) { return false; }
  return true;
}

bool tlgen::details::VectorCyc1MyCycleRead(::tlgen::basictl::tl_istream & s, std::vector<::tlgen::cyc1::MyCycle>& item) noexcept {
  (void)s;
  (void)item;
  if (!::tlgen::details::BuiltinVectorCyc1MyCycleRead(s, item)) { return false; }
  return true;
}

bool tlgen::details::VectorCyc1MyCycleWrite(::tlgen::basictl::tl_ostream & s, const std::vector<::tlgen::cyc1::MyCycle>& item) noexcept {
  (void)s;
  (void)item;
  if (!::tlgen::details::BuiltinVectorCyc1MyCycleWrite(s, item)) { return false; }
  return true;
}

bool tlgen::details::VectorCyc1MyCycleReadBoxed(::tlgen::basictl::tl_istream & s, std::vector<::tlgen::cyc1::MyCycle>& item) {
  if (!s.nat_read_exact_tag(0x1cb5c415)) { return false; }
  return tlgen::details::VectorCyc1MyCycleRead(s, item);
}

bool tlgen::details::VectorCyc1MyCycleWriteBoxed(::tlgen::basictl::tl_ostream & s, const std::vector<::tlgen::cyc1::MyCycle>& item) {
  if (!s.nat_write(0x1cb5c415)) { return false; }
  return tlgen::details::VectorCyc1MyCycleWrite(s, item);
}
