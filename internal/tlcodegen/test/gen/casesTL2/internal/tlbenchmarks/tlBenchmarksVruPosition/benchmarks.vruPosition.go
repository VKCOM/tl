// Copyright 2025 V Kontakte LLC
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Code generated by vktl/cmd/tlgen2; DO NOT EDIT.
package tlBenchmarksVruPosition

import (
	"github.com/vkcom/tl/internal/tlcodegen/test/gen/casesTL2/internal"
	"github.com/vkcom/tl/internal/tlcodegen/test/gen/casesTL2/internal/tl/tlTrue"
	"github.com/vkcom/tl/internal/tlcodegen/test/gen/casesTL2/internal/tlbenchmarks/tlBenchmarksVruHash"
	"github.com/vkcom/tl/pkg/basictl"
)

var _ = basictl.NatWrite
var _ = internal.ErrorInvalidEnumTag

type BenchmarksVruPosition struct {
	FieldsMask uint32
	// commitBit (TrueType) // Conditional: item.mask1.2
	// metaBlock (TrueType) // Conditional: item.mask1.3
	// splitPayload (TrueType) // Conditional: item.mask1.4
	// rotationBlock (TrueType) // Conditional: item.mask1.5
	// canonicalHash (TrueType) // Conditional: item.mask1.6
	PayloadOffset int64
	BlockTimeNano int64
	Hash          tlBenchmarksVruHash.BenchmarksVruHash
	FileOffset    int64
	seqNumber     int64 // Conditional: item.mask2.3

	mask1 byte // for fields #1 .. #7
	mask2 byte // for fields #8 .. #15
}

func (BenchmarksVruPosition) TLName() string { return "benchmarks.vruPosition" }
func (BenchmarksVruPosition) TLTag() uint32  { return 0x00000000 }

func (item *BenchmarksVruPosition) SetCommitBit(v bool) {
	if v {
		item.mask1 |= 1 << 2
	} else {
		item.mask1 &^= 1 << 2
	}
}
func (item *BenchmarksVruPosition) IsSetCommitBit() bool { return item.mask1&(1<<2) != 0 }

func (item *BenchmarksVruPosition) SetMetaBlock(v bool) {
	if v {
		item.mask1 |= 1 << 3
	} else {
		item.mask1 &^= 1 << 3
	}
}
func (item *BenchmarksVruPosition) IsSetMetaBlock() bool { return item.mask1&(1<<3) != 0 }

func (item *BenchmarksVruPosition) SetSplitPayload(v bool) {
	if v {
		item.mask1 |= 1 << 4
	} else {
		item.mask1 &^= 1 << 4
	}
}
func (item *BenchmarksVruPosition) IsSetSplitPayload() bool { return item.mask1&(1<<4) != 0 }

func (item *BenchmarksVruPosition) SetRotationBlock(v bool) {
	if v {
		item.mask1 |= 1 << 5
	} else {
		item.mask1 &^= 1 << 5
	}
}
func (item *BenchmarksVruPosition) IsSetRotationBlock() bool { return item.mask1&(1<<5) != 0 }

func (item *BenchmarksVruPosition) SetCanonicalHash(v bool) {
	if v {
		item.mask1 |= 1 << 6
	} else {
		item.mask1 &^= 1 << 6
	}
}
func (item *BenchmarksVruPosition) IsSetCanonicalHash() bool { return item.mask1&(1<<6) != 0 }

func (item *BenchmarksVruPosition) GetSeqNumber() int64 {
	return item.seqNumber
}
func (item *BenchmarksVruPosition) SetSeqNumber(v int64) {
	item.seqNumber = v
	item.mask2 |= 1 << 3
}
func (item *BenchmarksVruPosition) ClearSeqNumber() {
	item.seqNumber = 0
	item.mask2 &^= 1 << 3
}
func (item *BenchmarksVruPosition) IsSetSeqNumber() bool { return item.mask2&(1<<3) != 0 }

func (item *BenchmarksVruPosition) Reset() {
	item.FieldsMask = 0
	item.PayloadOffset = 0
	item.BlockTimeNano = 0
	item.Hash.Reset()
	item.FileOffset = 0
	item.seqNumber = 0
}

func (item *BenchmarksVruPosition) FillRandom(rg *basictl.RandGenerator) {
	item.mask1 = basictl.RandomByte(rg)
	item.mask2 = basictl.RandomByte(rg)
	item.FieldsMask = basictl.RandomUint(rg)
	item.PayloadOffset = basictl.RandomLong(rg)
	item.BlockTimeNano = basictl.RandomLong(rg)
	item.Hash.FillRandom(rg)
	item.FileOffset = basictl.RandomLong(rg)
	if item.mask2&(1<<3) != 0 {
		item.seqNumber = basictl.RandomLong(rg)
	} else {
		item.seqNumber = 0
	}
}

func (item *BenchmarksVruPosition) Read(w []byte) (_ []byte, err error) {
	return w, basictl.TL2Error("not implemented for tl2 type")
}

func (item *BenchmarksVruPosition) WriteGeneral(w []byte) (_ []byte, err error) {
	return w, basictl.TL2Error("not implemented for tl2 type")
}

func (item *BenchmarksVruPosition) Write(w []byte) []byte {
	return w
}

func (item *BenchmarksVruPosition) ReadBoxed(w []byte) (_ []byte, err error) {
	return w, basictl.TL2Error("not implemented for tl2 type")
}

func (item *BenchmarksVruPosition) WriteBoxedGeneral(w []byte) (_ []byte, err error) {
	return w, basictl.TL2Error("not implemented for tl2 type")
}

func (item *BenchmarksVruPosition) WriteBoxed(w []byte) []byte {
	return w
}

func (item BenchmarksVruPosition) String() string {
	return string(item.WriteJSON(nil))
}

func (item *BenchmarksVruPosition) ReadJSON(legacyTypeNames bool, in *basictl.JsonLexer) error {
	tctx := basictl.JSONReadContext{LegacyTypeNames: legacyTypeNames}
	tctx.IsTL2 = true
	return item.ReadJSONGeneral(&tctx, in)
}

func (item *BenchmarksVruPosition) ReadJSONGeneral(tctx *basictl.JSONReadContext, in *basictl.JsonLexer) error {
	var propFieldsMaskPresented bool
	var trueTypecommitBitPresented bool
	var trueTypecommitBitValue bool
	var trueTypemetaBlockPresented bool
	var trueTypemetaBlockValue bool
	var trueTypesplitPayloadPresented bool
	var trueTypesplitPayloadValue bool
	var trueTyperotationBlockPresented bool
	var trueTyperotationBlockValue bool
	var trueTypecanonicalHashPresented bool
	var trueTypecanonicalHashValue bool
	var propPayloadOffsetPresented bool
	var propBlockTimeNanoPresented bool
	var propHashPresented bool
	var propFileOffsetPresented bool
	var propseqNumberPresented bool

	if in != nil {
		in.Delim('{')
		if !in.Ok() {
			return in.Error()
		}
		for !in.IsDelim('}') {
			key := in.UnsafeFieldName(true)
			in.WantColon()
			switch key {
			case "fields_mask":
				if propFieldsMaskPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("benchmarks.vruPosition", "fields_mask")
				}
				if err := internal.Json2ReadUint32(in, &item.FieldsMask); err != nil {
					return err
				}
				propFieldsMaskPresented = true
			case "commit_bit":
				if trueTypecommitBitPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("benchmarks.vruPosition", "commit_bit")
				}
				if err := internal.Json2ReadBool(in, &trueTypecommitBitValue); err != nil {
					return err
				}
				trueTypecommitBitPresented = true
			case "meta_block":
				if trueTypemetaBlockPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("benchmarks.vruPosition", "meta_block")
				}
				if err := internal.Json2ReadBool(in, &trueTypemetaBlockValue); err != nil {
					return err
				}
				trueTypemetaBlockPresented = true
			case "split_payload":
				if trueTypesplitPayloadPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("benchmarks.vruPosition", "split_payload")
				}
				if err := internal.Json2ReadBool(in, &trueTypesplitPayloadValue); err != nil {
					return err
				}
				trueTypesplitPayloadPresented = true
			case "rotation_block":
				if trueTyperotationBlockPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("benchmarks.vruPosition", "rotation_block")
				}
				if err := internal.Json2ReadBool(in, &trueTyperotationBlockValue); err != nil {
					return err
				}
				trueTyperotationBlockPresented = true
			case "canonical_hash":
				if trueTypecanonicalHashPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("benchmarks.vruPosition", "canonical_hash")
				}
				if err := internal.Json2ReadBool(in, &trueTypecanonicalHashValue); err != nil {
					return err
				}
				trueTypecanonicalHashPresented = true
			case "payload_offset":
				if propPayloadOffsetPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("benchmarks.vruPosition", "payload_offset")
				}
				if err := internal.Json2ReadInt64(in, &item.PayloadOffset); err != nil {
					return err
				}
				propPayloadOffsetPresented = true
			case "block_time_nano":
				if propBlockTimeNanoPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("benchmarks.vruPosition", "block_time_nano")
				}
				if err := internal.Json2ReadInt64(in, &item.BlockTimeNano); err != nil {
					return err
				}
				propBlockTimeNanoPresented = true
			case "hash":
				if propHashPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("benchmarks.vruPosition", "hash")
				}
				if err := item.Hash.ReadJSONGeneral(tctx, in); err != nil {
					return err
				}
				propHashPresented = true
			case "file_offset":
				if propFileOffsetPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("benchmarks.vruPosition", "file_offset")
				}
				if err := internal.Json2ReadInt64(in, &item.FileOffset); err != nil {
					return err
				}
				propFileOffsetPresented = true
			case "seq_number":
				if propseqNumberPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("benchmarks.vruPosition", "seq_number")
				}
				if err := internal.Json2ReadInt64(in, &item.seqNumber); err != nil {
					return err
				}
				propseqNumberPresented = true
			default:
				return internal.ErrorInvalidJSONExcessElement("benchmarks.vruPosition", key)
			}
			in.WantComma()
		}
		in.Delim('}')
		if !in.Ok() {
			return in.Error()
		}
	}
	if !propFieldsMaskPresented {
		item.FieldsMask = 0
	}
	if !propPayloadOffsetPresented {
		item.PayloadOffset = 0
	}
	if !propBlockTimeNanoPresented {
		item.BlockTimeNano = 0
	}
	if !propHashPresented {
		item.Hash.Reset()
	}
	if !propFileOffsetPresented {
		item.FileOffset = 0
	}
	if !propseqNumberPresented {
		item.seqNumber = 0
	}
	if trueTypecommitBitPresented {
		if trueTypecommitBitValue {
			item.mask1 |= 1 << 2
		}
		item.mask1 |= 1 << 2
	}
	if trueTypemetaBlockPresented {
		if trueTypemetaBlockValue {
			item.mask1 |= 1 << 3
		}
		item.mask1 |= 1 << 3
	}
	if trueTypesplitPayloadPresented {
		if trueTypesplitPayloadValue {
			item.mask1 |= 1 << 4
		}
		item.mask1 |= 1 << 4
	}
	if trueTyperotationBlockPresented {
		if trueTyperotationBlockValue {
			item.mask1 |= 1 << 5
		}
		item.mask1 |= 1 << 5
	}
	if trueTypecanonicalHashPresented {
		if trueTypecanonicalHashValue {
			item.mask1 |= 1 << 6
		}
		item.mask1 |= 1 << 6
	}
	if propseqNumberPresented {
		item.mask2 |= 1 << 3
	}
	// tries to set bit to zero if it is 1
	if trueTypecommitBitPresented && !trueTypecommitBitValue && (item.mask1&(1<<2) != 0) {
		return internal.ErrorInvalidJSON("benchmarks.vruPosition", "fieldmask bit item.mask1.2 is indefinite because of the contradictions in values")
	}
	// tries to set bit to zero if it is 1
	if trueTypemetaBlockPresented && !trueTypemetaBlockValue && (item.mask1&(1<<3) != 0) {
		return internal.ErrorInvalidJSON("benchmarks.vruPosition", "fieldmask bit item.mask1.3 is indefinite because of the contradictions in values")
	}
	// tries to set bit to zero if it is 1
	if trueTypesplitPayloadPresented && !trueTypesplitPayloadValue && (item.mask1&(1<<4) != 0) {
		return internal.ErrorInvalidJSON("benchmarks.vruPosition", "fieldmask bit item.mask1.4 is indefinite because of the contradictions in values")
	}
	// tries to set bit to zero if it is 1
	if trueTyperotationBlockPresented && !trueTyperotationBlockValue && (item.mask1&(1<<5) != 0) {
		return internal.ErrorInvalidJSON("benchmarks.vruPosition", "fieldmask bit item.mask1.5 is indefinite because of the contradictions in values")
	}
	// tries to set bit to zero if it is 1
	if trueTypecanonicalHashPresented && !trueTypecanonicalHashValue && (item.mask1&(1<<6) != 0) {
		return internal.ErrorInvalidJSON("benchmarks.vruPosition", "fieldmask bit item.mask1.6 is indefinite because of the contradictions in values")
	}
	return nil
}

// This method is general version of WriteJSON, use it instead!
func (item *BenchmarksVruPosition) WriteJSONGeneral(tctx *basictl.JSONWriteContext, w []byte) (_ []byte, err error) {
	return item.WriteJSONOpt(tctx, w), nil
}

func (item *BenchmarksVruPosition) WriteJSON(w []byte) []byte {
	tctx := basictl.JSONWriteContext{}
	tctx.IsTL2 = true
	return item.WriteJSONOpt(&tctx, w)
}
func (item *BenchmarksVruPosition) WriteJSONOpt(tctx *basictl.JSONWriteContext, w []byte) []byte {
	w = append(w, '{')
	backupIndexFieldsMask := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"fields_mask":`...)
	w = basictl.JSONWriteUint32(w, item.FieldsMask)
	if (item.FieldsMask != 0) == false {
		w = w[:backupIndexFieldsMask]
	}
	if item.mask1&(1<<2) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"commit_bit":true`...)
	}
	if item.mask1&(1<<3) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"meta_block":true`...)
	}
	if item.mask1&(1<<4) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"split_payload":true`...)
	}
	if item.mask1&(1<<5) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"rotation_block":true`...)
	}
	if item.mask1&(1<<6) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"canonical_hash":true`...)
	}
	backupIndexPayloadOffset := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"payload_offset":`...)
	w = basictl.JSONWriteInt64(w, item.PayloadOffset)
	if (item.PayloadOffset != 0) == false {
		w = w[:backupIndexPayloadOffset]
	}
	backupIndexBlockTimeNano := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"block_time_nano":`...)
	w = basictl.JSONWriteInt64(w, item.BlockTimeNano)
	if (item.BlockTimeNano != 0) == false {
		w = w[:backupIndexBlockTimeNano]
	}
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"hash":`...)
	w = item.Hash.WriteJSONOpt(tctx, w)
	backupIndexFileOffset := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"file_offset":`...)
	w = basictl.JSONWriteInt64(w, item.FileOffset)
	if (item.FileOffset != 0) == false {
		w = w[:backupIndexFileOffset]
	}
	if item.mask2&(1<<3) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"seq_number":`...)
		w = basictl.JSONWriteInt64(w, item.seqNumber)
	}
	return append(w, '}')
}

func (item *BenchmarksVruPosition) MarshalJSON() ([]byte, error) {
	return item.WriteJSON(nil), nil
}

func (item *BenchmarksVruPosition) UnmarshalJSON(b []byte) error {
	if err := item.ReadJSON(true, &basictl.JsonLexer{Data: b}); err != nil {
		return internal.ErrorInvalidJSON("benchmarks.vruPosition", err.Error())
	}
	return nil
}

func (item *BenchmarksVruPosition) CalculateLayout(sizes []int) []int {
	sizePosition := len(sizes)
	sizes = append(sizes, 0)

	currentSize := 0
	lastUsedByte := 0

	// calculate layout for item.FieldsMask
	if item.FieldsMask != 0 {

		lastUsedByte = 1
		currentSize += 4
	}

	var truecommitBit tlTrue.True
	// calculate layout for truecommitBit
	currentPosition := len(sizes)
	if item.mask1&(1<<2) != 0 {
		sizes = truecommitBit.CalculateLayout(sizes)
		if sizes[currentPosition] != 0 {
			lastUsedByte = 1
			currentSize += sizes[currentPosition]
			currentSize += basictl.TL2CalculateSize(sizes[currentPosition])
		} else {
			sizes = sizes[:currentPosition+1]
		}
	}

	var truemetaBlock tlTrue.True
	// calculate layout for truemetaBlock
	currentPosition = len(sizes)
	if item.mask1&(1<<3) != 0 {
		sizes = truemetaBlock.CalculateLayout(sizes)
		if sizes[currentPosition] != 0 {
			lastUsedByte = 1
			currentSize += sizes[currentPosition]
			currentSize += basictl.TL2CalculateSize(sizes[currentPosition])
		} else {
			sizes = sizes[:currentPosition+1]
		}
	}

	var truesplitPayload tlTrue.True
	// calculate layout for truesplitPayload
	currentPosition = len(sizes)
	if item.mask1&(1<<4) != 0 {
		sizes = truesplitPayload.CalculateLayout(sizes)
		if sizes[currentPosition] != 0 {
			lastUsedByte = 1
			currentSize += sizes[currentPosition]
			currentSize += basictl.TL2CalculateSize(sizes[currentPosition])
		} else {
			sizes = sizes[:currentPosition+1]
		}
	}

	var truerotationBlock tlTrue.True
	// calculate layout for truerotationBlock
	currentPosition = len(sizes)
	if item.mask1&(1<<5) != 0 {
		sizes = truerotationBlock.CalculateLayout(sizes)
		if sizes[currentPosition] != 0 {
			lastUsedByte = 1
			currentSize += sizes[currentPosition]
			currentSize += basictl.TL2CalculateSize(sizes[currentPosition])
		} else {
			sizes = sizes[:currentPosition+1]
		}
	}

	var truecanonicalHash tlTrue.True
	// calculate layout for truecanonicalHash
	currentPosition = len(sizes)
	if item.mask1&(1<<6) != 0 {
		sizes = truecanonicalHash.CalculateLayout(sizes)
		if sizes[currentPosition] != 0 {
			lastUsedByte = 1
			currentSize += sizes[currentPosition]
			currentSize += basictl.TL2CalculateSize(sizes[currentPosition])
		} else {
			sizes = sizes[:currentPosition+1]
		}
	}

	// calculate layout for item.PayloadOffset
	if item.PayloadOffset != 0 {

		lastUsedByte = 1
		currentSize += 8
	}

	// calculate layout for item.BlockTimeNano
	if item.BlockTimeNano != 0 {

		lastUsedByte = 2
		currentSize += 8
	}

	// calculate layout for item.Hash
	currentPosition = len(sizes)
	sizes = item.Hash.CalculateLayout(sizes)
	if sizes[currentPosition] != 0 {
		lastUsedByte = 2
		currentSize += sizes[currentPosition]
		currentSize += basictl.TL2CalculateSize(sizes[currentPosition])
	} else {
		sizes = sizes[:currentPosition+1]
	}

	// calculate layout for item.FileOffset
	if item.FileOffset != 0 {

		lastUsedByte = 2
		currentSize += 8
	}

	// calculate layout for item.seqNumber
	if item.mask2&(1<<3) != 0 {
		if item.seqNumber != 0 {

			lastUsedByte = 2
			currentSize += 8
		}
	}

	// append byte for each section until last mentioned field
	if lastUsedByte != 0 {
		currentSize += lastUsedByte
	} else {
		// remove unused values
		sizes = sizes[:sizePosition+1]
	}
	sizes[sizePosition] = currentSize
	return sizes
}

func (item *BenchmarksVruPosition) InternalWriteTL2(w []byte, sizes []int) ([]byte, []int) {
	currentSize := sizes[0]
	sizes = sizes[1:]

	serializedSize := 0

	w = basictl.TL2WriteSize(w, currentSize)
	if currentSize == 0 {
		return w, sizes
	}

	var currentBlock byte
	currentBlockPosition := len(w)
	w = append(w, 0)
	serializedSize += 1
	// write item.FieldsMask
	if item.FieldsMask != 0 {
		serializedSize += 4
		if 4 != 0 {
			currentBlock |= (1 << 1)
			w = basictl.NatWrite(w, item.FieldsMask)
		}
	}
	var truecommitBit tlTrue.True
	// write truecommitBit
	if item.mask1&(1<<2) != 0 {
		serializedSize += sizes[0]
		if sizes[0] != 0 {
			serializedSize += basictl.TL2CalculateSize(sizes[0])
			currentBlock |= (1 << 2)
			w, sizes = truecommitBit.InternalWriteTL2(w, sizes)
		} else {
			sizes = sizes[1:]
		}
	}
	var truemetaBlock tlTrue.True
	// write truemetaBlock
	if item.mask1&(1<<3) != 0 {
		serializedSize += sizes[0]
		if sizes[0] != 0 {
			serializedSize += basictl.TL2CalculateSize(sizes[0])
			currentBlock |= (1 << 3)
			w, sizes = truemetaBlock.InternalWriteTL2(w, sizes)
		} else {
			sizes = sizes[1:]
		}
	}
	var truesplitPayload tlTrue.True
	// write truesplitPayload
	if item.mask1&(1<<4) != 0 {
		serializedSize += sizes[0]
		if sizes[0] != 0 {
			serializedSize += basictl.TL2CalculateSize(sizes[0])
			currentBlock |= (1 << 4)
			w, sizes = truesplitPayload.InternalWriteTL2(w, sizes)
		} else {
			sizes = sizes[1:]
		}
	}
	var truerotationBlock tlTrue.True
	// write truerotationBlock
	if item.mask1&(1<<5) != 0 {
		serializedSize += sizes[0]
		if sizes[0] != 0 {
			serializedSize += basictl.TL2CalculateSize(sizes[0])
			currentBlock |= (1 << 5)
			w, sizes = truerotationBlock.InternalWriteTL2(w, sizes)
		} else {
			sizes = sizes[1:]
		}
	}
	var truecanonicalHash tlTrue.True
	// write truecanonicalHash
	if item.mask1&(1<<6) != 0 {
		serializedSize += sizes[0]
		if sizes[0] != 0 {
			serializedSize += basictl.TL2CalculateSize(sizes[0])
			currentBlock |= (1 << 6)
			w, sizes = truecanonicalHash.InternalWriteTL2(w, sizes)
		} else {
			sizes = sizes[1:]
		}
	}
	// write item.PayloadOffset
	if item.PayloadOffset != 0 {
		serializedSize += 8
		if 8 != 0 {
			currentBlock |= (1 << 7)
			w = basictl.LongWrite(w, item.PayloadOffset)
		}
	}

	// add byte for fields with index 8..15
	w[currentBlockPosition] = currentBlock
	currentBlock = 0
	if serializedSize != currentSize {
		currentBlockPosition = len(w)
		w = append(w, 0)
		serializedSize += 1
	} else {
		return w, sizes
	}
	// write item.BlockTimeNano
	if item.BlockTimeNano != 0 {
		serializedSize += 8
		if 8 != 0 {
			currentBlock |= (1 << 0)
			w = basictl.LongWrite(w, item.BlockTimeNano)
		}
	}
	// write item.Hash
	serializedSize += sizes[0]
	if sizes[0] != 0 {
		serializedSize += basictl.TL2CalculateSize(sizes[0])
		currentBlock |= (1 << 1)
		w, sizes = item.Hash.InternalWriteTL2(w, sizes)
	} else {
		sizes = sizes[1:]
	}
	// write item.FileOffset
	if item.FileOffset != 0 {
		serializedSize += 8
		if 8 != 0 {
			currentBlock |= (1 << 2)
			w = basictl.LongWrite(w, item.FileOffset)
		}
	}
	// write item.seqNumber
	if item.mask2&(1<<3) != 0 {
		if item.seqNumber != 0 {
			serializedSize += 8
			if 8 != 0 {
				currentBlock |= (1 << 3)
				w = basictl.LongWrite(w, item.seqNumber)
			}
		}
	}
	w[currentBlockPosition] = currentBlock
	return w, sizes
}

func (item *BenchmarksVruPosition) WriteTL2(w []byte, ctx *basictl.TL2WriteContext) []byte {
	var sizes []int
	if ctx != nil {
		sizes = ctx.SizeBuffer
	}
	sizes = item.CalculateLayout(sizes[:0])
	w, _ = item.InternalWriteTL2(w, sizes)
	if ctx != nil {
		ctx.SizeBuffer = sizes[:0]
	}
	return w
}

func (item *BenchmarksVruPosition) InternalReadTL2(r []byte) (_ []byte, err error) {
	currentSize := 0
	if r, currentSize, err = basictl.TL2ParseSize(r); err != nil {
		return r, err
	}
	if len(r) < currentSize {
		return r, basictl.TL2Error("not enough data: expected %d, got %d", currentSize, len(r))
	}

	currentR := r[:currentSize]
	r = r[currentSize:]

	if currentSize == 0 {
		item.Reset()
		return r, nil
	}
	var block byte
	if currentR, err = basictl.ByteReadTL2(currentR, &block); err != nil {
		return currentR, err
	}
	// read No of constructor
	if block&1 != 0 {
		var index int
		if currentR, err = basictl.TL2ReadSize(currentR, &index); err != nil {
			return currentR, err
		}
		if index != 0 {
			// unknown cases for current type
			item.Reset()
			return r, nil
		}
	}
	item.mask1 = block

	// read item.FieldsMask
	if block&(1<<1) != 0 {
		if currentR, err = basictl.NatRead(currentR, &item.FieldsMask); err != nil {
			return currentR, err
		}
	} else {
		item.FieldsMask = 0
	}

	var truecommitBit tlTrue.True
	// read truecommitBit
	if block&(1<<2) != 0 {
		if item.mask1&(1<<2) != 0 {
			if currentR, err = truecommitBit.InternalReadTL2(currentR); err != nil {
				return currentR, err
			}
		} else {
			return currentR, basictl.TL2Error("field mask contradiction: field item." + "commitBit" + "is presented but depending bit is absent")
		}
	} else {
		truecommitBit.Reset()
	}

	var truemetaBlock tlTrue.True
	// read truemetaBlock
	if block&(1<<3) != 0 {
		if item.mask1&(1<<3) != 0 {
			if currentR, err = truemetaBlock.InternalReadTL2(currentR); err != nil {
				return currentR, err
			}
		} else {
			return currentR, basictl.TL2Error("field mask contradiction: field item." + "metaBlock" + "is presented but depending bit is absent")
		}
	} else {
		truemetaBlock.Reset()
	}

	var truesplitPayload tlTrue.True
	// read truesplitPayload
	if block&(1<<4) != 0 {
		if item.mask1&(1<<4) != 0 {
			if currentR, err = truesplitPayload.InternalReadTL2(currentR); err != nil {
				return currentR, err
			}
		} else {
			return currentR, basictl.TL2Error("field mask contradiction: field item." + "splitPayload" + "is presented but depending bit is absent")
		}
	} else {
		truesplitPayload.Reset()
	}

	var truerotationBlock tlTrue.True
	// read truerotationBlock
	if block&(1<<5) != 0 {
		if item.mask1&(1<<5) != 0 {
			if currentR, err = truerotationBlock.InternalReadTL2(currentR); err != nil {
				return currentR, err
			}
		} else {
			return currentR, basictl.TL2Error("field mask contradiction: field item." + "rotationBlock" + "is presented but depending bit is absent")
		}
	} else {
		truerotationBlock.Reset()
	}

	var truecanonicalHash tlTrue.True
	// read truecanonicalHash
	if block&(1<<6) != 0 {
		if item.mask1&(1<<6) != 0 {
			if currentR, err = truecanonicalHash.InternalReadTL2(currentR); err != nil {
				return currentR, err
			}
		} else {
			return currentR, basictl.TL2Error("field mask contradiction: field item." + "canonicalHash" + "is presented but depending bit is absent")
		}
	} else {
		truecanonicalHash.Reset()
	}

	// read item.PayloadOffset
	if block&(1<<7) != 0 {
		if currentR, err = basictl.LongRead(currentR, &item.PayloadOffset); err != nil {
			return currentR, err
		}
	} else {
		item.PayloadOffset = 0
	}

	// read next block for fields 8..15
	if len(currentR) > 0 {
		if currentR, err = basictl.ByteReadTL2(currentR, &block); err != nil {
			return currentR, err
		}
	} else {
		block = 0
	}
	item.mask2 = block

	// read item.BlockTimeNano
	if block&(1<<0) != 0 {
		if currentR, err = basictl.LongRead(currentR, &item.BlockTimeNano); err != nil {
			return currentR, err
		}
	} else {
		item.BlockTimeNano = 0
	}

	// read item.Hash
	if block&(1<<1) != 0 {
		if currentR, err = item.Hash.InternalReadTL2(currentR); err != nil {
			return currentR, err
		}
	} else {
		item.Hash.Reset()
	}

	// read item.FileOffset
	if block&(1<<2) != 0 {
		if currentR, err = basictl.LongRead(currentR, &item.FileOffset); err != nil {
			return currentR, err
		}
	} else {
		item.FileOffset = 0
	}

	// read item.seqNumber
	if block&(1<<3) != 0 {
		if item.mask2&(1<<3) != 0 {
			if currentR, err = basictl.LongRead(currentR, &item.seqNumber); err != nil {
				return currentR, err
			}
		} else {
			return currentR, basictl.TL2Error("field mask contradiction: field item." + "seqNumber" + "is presented but depending bit is absent")
		}
	} else {
		item.seqNumber = 0
	}

	return r, nil
}

func (item *BenchmarksVruPosition) ReadTL2(r []byte, ctx *basictl.TL2ReadContext) (_ []byte, err error) {
	return item.InternalReadTL2(r)
}
