// Copyright 2025 V Kontakte LLC
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Code generated by vktl/cmd/tlgen2; DO NOT EDIT.
package tlCasesTestAllPossibleFieldConfigs

import (
	"github.com/vkcom/tl/internal/tlcodegen/test/gen/casesTL2/internal"
	"github.com/vkcom/tl/internal/tlcodegen/test/gen/casesTL2/internal/tl/tlBuiltinVectorInt32"
	"github.com/vkcom/tl/internal/tlcodegen/test/gen/casesTL2/internal/tl/tlTrue"
	"github.com/vkcom/tl/pkg/basictl"
)

var _ = basictl.NatWrite
var _ = internal.ErrorInvalidEnumTag

type CasesTestAllPossibleFieldConfigs struct {
	Local uint32
	F00   int32
	// F01 (TrueType)
	F02 []int32
	F03 []int32
	f10 int32
	F11 bool
	f12 []int32
	f13 []int32
	f20 int32
	F21 bool
	f22 []int32
	f23 []int32

	tl2mask0 byte
}

func (CasesTestAllPossibleFieldConfigs) TLName() string { return "cases.testAllPossibleFieldConfigs" }
func (CasesTestAllPossibleFieldConfigs) TLTag() uint32  { return 0x00000000 }

func (item *CasesTestAllPossibleFieldConfigs) GetF10() int32 {
	return item.f10
}
func (item *CasesTestAllPossibleFieldConfigs) SetF10(v int32) {
	item.f10 = v
	item.tl2mask0 |= 1
}
func (item *CasesTestAllPossibleFieldConfigs) ClearF10() {
	item.f10 = 0
	item.tl2mask0 &^= 1
}
func (item *CasesTestAllPossibleFieldConfigs) IsSetF10() bool { return item.tl2mask0&1 != 0 }

func (item *CasesTestAllPossibleFieldConfigs) GetF12() []int32 {
	return item.f12
}
func (item *CasesTestAllPossibleFieldConfigs) SetF12(v []int32) {
	item.f12 = v
	item.tl2mask0 |= 2
}
func (item *CasesTestAllPossibleFieldConfigs) ClearF12() {
	item.f12 = item.f12[:0]
	item.tl2mask0 &^= 2
}
func (item *CasesTestAllPossibleFieldConfigs) IsSetF12() bool { return item.tl2mask0&2 != 0 }

func (item *CasesTestAllPossibleFieldConfigs) GetF13() []int32 {
	return item.f13
}
func (item *CasesTestAllPossibleFieldConfigs) SetF13(v []int32) {
	item.f13 = v
	item.tl2mask0 |= 4
}
func (item *CasesTestAllPossibleFieldConfigs) ClearF13() {
	item.f13 = item.f13[:0]
	item.tl2mask0 &^= 4
}
func (item *CasesTestAllPossibleFieldConfigs) IsSetF13() bool { return item.tl2mask0&4 != 0 }

func (item *CasesTestAllPossibleFieldConfigs) GetF20() int32 {
	return item.f20
}
func (item *CasesTestAllPossibleFieldConfigs) SetF20(v int32) {
	item.f20 = v
	item.tl2mask0 |= 8
}
func (item *CasesTestAllPossibleFieldConfigs) ClearF20() {
	item.f20 = 0
	item.tl2mask0 &^= 8
}
func (item *CasesTestAllPossibleFieldConfigs) IsSetF20() bool { return item.tl2mask0&8 != 0 }

func (item *CasesTestAllPossibleFieldConfigs) GetF22() []int32 {
	return item.f22
}
func (item *CasesTestAllPossibleFieldConfigs) SetF22(v []int32) {
	item.f22 = v
	item.tl2mask0 |= 16
}
func (item *CasesTestAllPossibleFieldConfigs) ClearF22() {
	item.f22 = item.f22[:0]
	item.tl2mask0 &^= 16
}
func (item *CasesTestAllPossibleFieldConfigs) IsSetF22() bool { return item.tl2mask0&16 != 0 }

func (item *CasesTestAllPossibleFieldConfigs) GetF23() []int32 {
	return item.f23
}
func (item *CasesTestAllPossibleFieldConfigs) SetF23(v []int32) {
	item.f23 = v
	item.tl2mask0 |= 32
}
func (item *CasesTestAllPossibleFieldConfigs) ClearF23() {
	item.f23 = item.f23[:0]
	item.tl2mask0 &^= 32
}
func (item *CasesTestAllPossibleFieldConfigs) IsSetF23() bool { return item.tl2mask0&32 != 0 }

func (item *CasesTestAllPossibleFieldConfigs) Reset() {
	item.Local = 0
	item.F00 = 0
	item.F02 = item.F02[:0]
	item.F03 = item.F03[:0]
	item.f10 = 0
	item.F11 = false
	item.f12 = item.f12[:0]
	item.f13 = item.f13[:0]
	item.f20 = 0
	item.F21 = false
	item.f22 = item.f22[:0]
	item.f23 = item.f23[:0]
	item.tl2mask0 = 0
}

func (item *CasesTestAllPossibleFieldConfigs) FillRandom(rg *basictl.RandGenerator) {
	item.Local = basictl.RandomUint(rg)
	item.F00 = basictl.RandomInt(rg)
	tlBuiltinVectorInt32.BuiltinVectorInt32FillRandom(rg, &item.F02)
	tlBuiltinVectorInt32.BuiltinVectorInt32FillRandom(rg, &item.F03)
	item.f10 = basictl.RandomInt(rg)
	item.F11 = basictl.RandomUint(rg)&1 == 1
	tlBuiltinVectorInt32.BuiltinVectorInt32FillRandom(rg, &item.f12)
	tlBuiltinVectorInt32.BuiltinVectorInt32FillRandom(rg, &item.f13)
	item.f20 = basictl.RandomInt(rg)
	item.F21 = basictl.RandomUint(rg)&1 == 1
	tlBuiltinVectorInt32.BuiltinVectorInt32FillRandom(rg, &item.f22)
	tlBuiltinVectorInt32.BuiltinVectorInt32FillRandom(rg, &item.f23)
}

func (item *CasesTestAllPossibleFieldConfigs) Read(w []byte) (_ []byte, err error) {
	return w, basictl.TL2Error("not implemented for tl2 type")
}

func (item *CasesTestAllPossibleFieldConfigs) WriteGeneral(w []byte) (_ []byte, err error) {
	return w, basictl.TL2Error("not implemented for tl2 type")
}

func (item *CasesTestAllPossibleFieldConfigs) Write(w []byte) []byte {
	return w
}

func (item *CasesTestAllPossibleFieldConfigs) ReadBoxed(w []byte) (_ []byte, err error) {
	return w, basictl.TL2Error("not implemented for tl2 type")
}

func (item *CasesTestAllPossibleFieldConfigs) WriteBoxedGeneral(w []byte) (_ []byte, err error) {
	return w, basictl.TL2Error("not implemented for tl2 type")
}

func (item *CasesTestAllPossibleFieldConfigs) WriteBoxed(w []byte) []byte {
	return w
}

func (item CasesTestAllPossibleFieldConfigs) String() string {
	return string(item.WriteJSON(nil))
}

func (item *CasesTestAllPossibleFieldConfigs) ReadJSON(legacyTypeNames bool, in *basictl.JsonLexer) error {
	tctx := basictl.JSONReadContext{LegacyTypeNames: legacyTypeNames}
	tctx.IsTL2 = true
	return item.ReadJSONGeneral(&tctx, in)
}

func (item *CasesTestAllPossibleFieldConfigs) ReadJSONGeneral(tctx *basictl.JSONReadContext, in *basictl.JsonLexer) error {
	var propLocalPresented bool
	var propF00Presented bool
	var propF02Presented bool
	var propF03Presented bool
	var propf10Presented bool
	var propF11Presented bool
	var propf12Presented bool
	var propf13Presented bool
	var propf20Presented bool
	var propF21Presented bool
	var propf22Presented bool
	var propf23Presented bool

	if in != nil {
		in.Delim('{')
		if !in.Ok() {
			return in.Error()
		}
		for !in.IsDelim('}') {
			key := in.UnsafeFieldName(true)
			in.WantColon()
			switch key {
			case "local":
				if propLocalPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "local")
				}
				if err := internal.Json2ReadUint32(in, &item.Local); err != nil {
					return err
				}
				propLocalPresented = true
			case "f00":
				if propF00Presented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "f00")
				}
				if err := internal.Json2ReadInt32(in, &item.F00); err != nil {
					return err
				}
				propF00Presented = true
			case "f01":
				var tmpF01 tlTrue.True
				if err := tmpF01.ReadJSONGeneral(tctx, in); err != nil {
					return err
				}
			case "f02":
				if propF02Presented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "f02")
				}
				if err := tlBuiltinVectorInt32.BuiltinVectorInt32ReadJSONGeneral(tctx, in, &item.F02); err != nil {
					return err
				}
				propF02Presented = true
			case "f03":
				if propF03Presented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "f03")
				}
				if err := tlBuiltinVectorInt32.BuiltinVectorInt32ReadJSONGeneral(tctx, in, &item.F03); err != nil {
					return err
				}
				propF03Presented = true
			case "f10":
				if propf10Presented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "f10")
				}
				if err := internal.Json2ReadInt32(in, &item.f10); err != nil {
					return err
				}
				propf10Presented = true
			case "f11":
				if propF11Presented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "f11")
				}
				if err := internal.Json2ReadBool(in, &item.F11); err != nil {
					return err
				}
				propF11Presented = true
			case "f12":
				if propf12Presented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "f12")
				}
				if err := tlBuiltinVectorInt32.BuiltinVectorInt32ReadJSONGeneral(tctx, in, &item.f12); err != nil {
					return err
				}
				propf12Presented = true
			case "f13":
				if propf13Presented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "f13")
				}
				if err := tlBuiltinVectorInt32.BuiltinVectorInt32ReadJSONGeneral(tctx, in, &item.f13); err != nil {
					return err
				}
				propf13Presented = true
			case "f20":
				if propf20Presented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "f20")
				}
				if err := internal.Json2ReadInt32(in, &item.f20); err != nil {
					return err
				}
				propf20Presented = true
			case "f21":
				if propF21Presented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "f21")
				}
				if err := internal.Json2ReadBool(in, &item.F21); err != nil {
					return err
				}
				propF21Presented = true
			case "f22":
				if propf22Presented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "f22")
				}
				if err := tlBuiltinVectorInt32.BuiltinVectorInt32ReadJSONGeneral(tctx, in, &item.f22); err != nil {
					return err
				}
				propf22Presented = true
			case "f23":
				if propf23Presented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "f23")
				}
				if err := tlBuiltinVectorInt32.BuiltinVectorInt32ReadJSONGeneral(tctx, in, &item.f23); err != nil {
					return err
				}
				propf23Presented = true
			default:
				return internal.ErrorInvalidJSONExcessElement("cases.testAllPossibleFieldConfigs", key)
			}
			in.WantComma()
		}
		in.Delim('}')
		if !in.Ok() {
			return in.Error()
		}
	}
	if !propLocalPresented {
		item.Local = 0
	}
	if !propF00Presented {
		item.F00 = 0
	}
	if !propF02Presented {
		item.F02 = item.F02[:0]
	}
	if !propF03Presented {
		item.F03 = item.F03[:0]
	}
	if !propf10Presented {
		item.f10 = 0
	}
	if !propF11Presented {
		item.F11 = false
	}
	if !propf12Presented {
		item.f12 = item.f12[:0]
	}
	if !propf13Presented {
		item.f13 = item.f13[:0]
	}
	if !propf20Presented {
		item.f20 = 0
	}
	if !propF21Presented {
		item.F21 = false
	}
	if !propf22Presented {
		item.f22 = item.f22[:0]
	}
	if !propf23Presented {
		item.f23 = item.f23[:0]
	}
	return nil
}

// This method is general version of WriteJSON, use it instead!
func (item *CasesTestAllPossibleFieldConfigs) WriteJSONGeneral(tctx *basictl.JSONWriteContext, w []byte) (_ []byte, err error) {
	return item.WriteJSONOpt(tctx, w), nil
}

func (item *CasesTestAllPossibleFieldConfigs) WriteJSON(w []byte) []byte {
	tctx := basictl.JSONWriteContext{}
	tctx.IsTL2 = true
	return item.WriteJSONOpt(&tctx, w)
}
func (item *CasesTestAllPossibleFieldConfigs) WriteJSONOpt(tctx *basictl.JSONWriteContext, w []byte) []byte {
	w = append(w, '{')
	backupIndexLocal := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"local":`...)
	w = basictl.JSONWriteUint32(w, item.Local)
	if (item.Local != 0) == false {
		w = w[:backupIndexLocal]
	}
	backupIndexF00 := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"f00":`...)
	w = basictl.JSONWriteInt32(w, item.F00)
	if (item.F00 != 0) == false {
		w = w[:backupIndexF00]
	}
	backupIndexF02 := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"f02":`...)
	w = tlBuiltinVectorInt32.BuiltinVectorInt32WriteJSONOpt(tctx, w, item.F02)
	if (len(item.F02) != 0) == false {
		w = w[:backupIndexF02]
	}
	backupIndexF03 := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"f03":`...)
	w = tlBuiltinVectorInt32.BuiltinVectorInt32WriteJSONOpt(tctx, w, item.F03)
	if (len(item.F03) != 0) == false {
		w = w[:backupIndexF03]
	}
	backupIndexf10 := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"f10":`...)
	w = basictl.JSONWriteInt32(w, item.f10)
	if (item.f10 != 0) == false {
		w = w[:backupIndexf10]
	}
	backupIndexF11 := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"f11":`...)
	w = basictl.JSONWriteBool(w, item.F11)
	if (item.F11) == false {
		w = w[:backupIndexF11]
	}
	backupIndexf12 := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"f12":`...)
	w = tlBuiltinVectorInt32.BuiltinVectorInt32WriteJSONOpt(tctx, w, item.f12)
	if (len(item.f12) != 0) == false {
		w = w[:backupIndexf12]
	}
	backupIndexf13 := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"f13":`...)
	w = tlBuiltinVectorInt32.BuiltinVectorInt32WriteJSONOpt(tctx, w, item.f13)
	if (len(item.f13) != 0) == false {
		w = w[:backupIndexf13]
	}
	backupIndexf20 := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"f20":`...)
	w = basictl.JSONWriteInt32(w, item.f20)
	if (item.f20 != 0) == false {
		w = w[:backupIndexf20]
	}
	backupIndexF21 := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"f21":`...)
	w = basictl.JSONWriteBool(w, item.F21)
	if (item.F21) == false {
		w = w[:backupIndexF21]
	}
	backupIndexf22 := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"f22":`...)
	w = tlBuiltinVectorInt32.BuiltinVectorInt32WriteJSONOpt(tctx, w, item.f22)
	if (len(item.f22) != 0) == false {
		w = w[:backupIndexf22]
	}
	backupIndexf23 := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"f23":`...)
	w = tlBuiltinVectorInt32.BuiltinVectorInt32WriteJSONOpt(tctx, w, item.f23)
	if (len(item.f23) != 0) == false {
		w = w[:backupIndexf23]
	}
	return append(w, '}')
}

func (item *CasesTestAllPossibleFieldConfigs) MarshalJSON() ([]byte, error) {
	return item.WriteJSON(nil), nil
}

func (item *CasesTestAllPossibleFieldConfigs) UnmarshalJSON(b []byte) error {
	if err := item.ReadJSON(true, &basictl.JsonLexer{Data: b}); err != nil {
		return internal.ErrorInvalidJSON("cases.testAllPossibleFieldConfigs", err.Error())
	}
	return nil
}

func (item *CasesTestAllPossibleFieldConfigs) CalculateLayout(sizes []int) []int {
	sizePosition := len(sizes)
	sizes = append(sizes, 0)

	currentSize := 0
	lastUsedByte := 0
	currentPosition := 0

	// calculate layout for item.Local
	if item.Local != 0 {

		lastUsedByte = 1
		currentSize += 4
	}

	// calculate layout for item.F00
	if item.F00 != 0 {

		lastUsedByte = 1
		currentSize += 4
	}

	var trueF01 tlTrue.True
	// calculate layout for trueF01
	currentPosition = len(sizes)
	sizes = trueF01.CalculateLayout(sizes)
	if sizes[currentPosition] != 0 {
		lastUsedByte = 1
		currentSize += sizes[currentPosition]
		currentSize += basictl.TL2CalculateSize(sizes[currentPosition])
	} else {
		sizes = sizes[:currentPosition+1]
	}

	// calculate layout for item.F02
	currentPosition = len(sizes)
	if len(item.F02) != 0 {
		sizes = tlBuiltinVectorInt32.BuiltinVectorInt32CalculateLayout(sizes, &item.F02)
		if sizes[currentPosition] != 0 {
			lastUsedByte = 1
			currentSize += sizes[currentPosition]
			currentSize += basictl.TL2CalculateSize(sizes[currentPosition])
		} else {
			sizes = sizes[:currentPosition+1]
		}
	}

	// calculate layout for item.F03
	currentPosition = len(sizes)
	if len(item.F03) != 0 {
		sizes = tlBuiltinVectorInt32.BuiltinVectorInt32CalculateLayout(sizes, &item.F03)
		if sizes[currentPosition] != 0 {
			lastUsedByte = 1
			currentSize += sizes[currentPosition]
			currentSize += basictl.TL2CalculateSize(sizes[currentPosition])
		} else {
			sizes = sizes[:currentPosition+1]
		}
	}

	// calculate layout for item.f10
	if item.f10 != 0 {

		lastUsedByte = 1
		currentSize += 4
	}

	// calculate layout for item.F11
	if item.F11 {

		lastUsedByte = 1
		currentSize += 0
	}

	// calculate layout for item.f12
	currentPosition = len(sizes)
	if len(item.f12) != 0 {
		sizes = tlBuiltinVectorInt32.BuiltinVectorInt32CalculateLayout(sizes, &item.f12)
		if sizes[currentPosition] != 0 {
			lastUsedByte = 2
			currentSize += sizes[currentPosition]
			currentSize += basictl.TL2CalculateSize(sizes[currentPosition])
		} else {
			sizes = sizes[:currentPosition+1]
		}
	}

	// calculate layout for item.f13
	currentPosition = len(sizes)
	if len(item.f13) != 0 {
		sizes = tlBuiltinVectorInt32.BuiltinVectorInt32CalculateLayout(sizes, &item.f13)
		if sizes[currentPosition] != 0 {
			lastUsedByte = 2
			currentSize += sizes[currentPosition]
			currentSize += basictl.TL2CalculateSize(sizes[currentPosition])
		} else {
			sizes = sizes[:currentPosition+1]
		}
	}

	// calculate layout for item.f20
	if item.f20 != 0 {

		lastUsedByte = 2
		currentSize += 4
	}

	// calculate layout for item.F21
	if item.F21 {

		lastUsedByte = 2
		currentSize += 0
	}

	// calculate layout for item.f22
	currentPosition = len(sizes)
	if len(item.f22) != 0 {
		sizes = tlBuiltinVectorInt32.BuiltinVectorInt32CalculateLayout(sizes, &item.f22)
		if sizes[currentPosition] != 0 {
			lastUsedByte = 2
			currentSize += sizes[currentPosition]
			currentSize += basictl.TL2CalculateSize(sizes[currentPosition])
		} else {
			sizes = sizes[:currentPosition+1]
		}
	}

	// calculate layout for item.f23
	currentPosition = len(sizes)
	if len(item.f23) != 0 {
		sizes = tlBuiltinVectorInt32.BuiltinVectorInt32CalculateLayout(sizes, &item.f23)
		if sizes[currentPosition] != 0 {
			lastUsedByte = 2
			currentSize += sizes[currentPosition]
			currentSize += basictl.TL2CalculateSize(sizes[currentPosition])
		} else {
			sizes = sizes[:currentPosition+1]
		}
	}

	// append byte for each section until last mentioned field
	if lastUsedByte != 0 {
		currentSize += lastUsedByte
	} else {
		// remove unused values
		sizes = sizes[:sizePosition+1]
	}
	internal.Unused(currentPosition)
	sizes[sizePosition] = currentSize
	return sizes
}

func (item *CasesTestAllPossibleFieldConfigs) InternalWriteTL2(w []byte, sizes []int) ([]byte, []int) {
	currentSize := sizes[0]
	sizes = sizes[1:]

	w = basictl.TL2WriteSize(w, currentSize)
	if currentSize == 0 {
		return w, sizes
	}
	serializedSize := 0

	var currentBlock byte
	currentBlockPosition := len(w)
	w = append(w, 0)
	serializedSize += 1

	// write item.Local
	if item.Local != 0 {
		serializedSize += 4
		if 4 != 0 {
			currentBlock |= (1 << 1)
			w = basictl.NatWrite(w, item.Local)
		}
	}

	// write item.F00
	if item.F00 != 0 {
		serializedSize += 4
		if 4 != 0 {
			currentBlock |= (1 << 2)
			w = basictl.IntWrite(w, item.F00)
		}
	}

	var trueF01 tlTrue.True
	// write trueF01
	serializedSize += sizes[0]
	if sizes[0] != 0 {
		serializedSize += basictl.TL2CalculateSize(sizes[0])
		currentBlock |= (1 << 3)
		w, sizes = trueF01.InternalWriteTL2(w, sizes)
	} else {
		sizes = sizes[1:]
	}

	// write item.F02
	if len(item.F02) != 0 {
		serializedSize += sizes[0]
		if sizes[0] != 0 {
			serializedSize += basictl.TL2CalculateSize(sizes[0])
			currentBlock |= (1 << 4)
			w, sizes = tlBuiltinVectorInt32.BuiltinVectorInt32InternalWriteTL2(w, sizes, &item.F02)
		} else {
			sizes = sizes[1:]
		}
	}

	// write item.F03
	if len(item.F03) != 0 {
		serializedSize += sizes[0]
		if sizes[0] != 0 {
			serializedSize += basictl.TL2CalculateSize(sizes[0])
			currentBlock |= (1 << 5)
			w, sizes = tlBuiltinVectorInt32.BuiltinVectorInt32InternalWriteTL2(w, sizes, &item.F03)
		} else {
			sizes = sizes[1:]
		}
	}

	// write item.f10
	if item.f10 != 0 {
		serializedSize += 4
		if 4 != 0 {
			currentBlock |= (1 << 6)
			w = basictl.IntWrite(w, item.f10)
		}
	}

	// write item.F11
	if item.F11 {
		serializedSize += 0
		currentBlock |= (1 << 7)

	}
	// add byte for fields with index 8..15
	w[currentBlockPosition] = currentBlock
	currentBlock = 0
	if serializedSize != currentSize {
		currentBlockPosition = len(w)
		w = append(w, 0)
		serializedSize += 1
	} else {
		return w, sizes
	}

	// write item.f12
	if len(item.f12) != 0 {
		serializedSize += sizes[0]
		if sizes[0] != 0 {
			serializedSize += basictl.TL2CalculateSize(sizes[0])
			currentBlock |= (1 << 0)
			w, sizes = tlBuiltinVectorInt32.BuiltinVectorInt32InternalWriteTL2(w, sizes, &item.f12)
		} else {
			sizes = sizes[1:]
		}
	}

	// write item.f13
	if len(item.f13) != 0 {
		serializedSize += sizes[0]
		if sizes[0] != 0 {
			serializedSize += basictl.TL2CalculateSize(sizes[0])
			currentBlock |= (1 << 1)
			w, sizes = tlBuiltinVectorInt32.BuiltinVectorInt32InternalWriteTL2(w, sizes, &item.f13)
		} else {
			sizes = sizes[1:]
		}
	}

	// write item.f20
	if item.f20 != 0 {
		serializedSize += 4
		if 4 != 0 {
			currentBlock |= (1 << 2)
			w = basictl.IntWrite(w, item.f20)
		}
	}

	// write item.F21
	if item.F21 {
		serializedSize += 0
		currentBlock |= (1 << 3)

	}

	// write item.f22
	if len(item.f22) != 0 {
		serializedSize += sizes[0]
		if sizes[0] != 0 {
			serializedSize += basictl.TL2CalculateSize(sizes[0])
			currentBlock |= (1 << 4)
			w, sizes = tlBuiltinVectorInt32.BuiltinVectorInt32InternalWriteTL2(w, sizes, &item.f22)
		} else {
			sizes = sizes[1:]
		}
	}

	// write item.f23
	if len(item.f23) != 0 {
		serializedSize += sizes[0]
		if sizes[0] != 0 {
			serializedSize += basictl.TL2CalculateSize(sizes[0])
			currentBlock |= (1 << 5)
			w, sizes = tlBuiltinVectorInt32.BuiltinVectorInt32InternalWriteTL2(w, sizes, &item.f23)
		} else {
			sizes = sizes[1:]
		}
	}
	w[currentBlockPosition] = currentBlock
	return w, sizes
}

func (item *CasesTestAllPossibleFieldConfigs) WriteTL2(w []byte, ctx *basictl.TL2WriteContext) []byte {
	var sizes []int
	if ctx != nil {
		sizes = ctx.SizeBuffer[:0]
	}
	sizes = item.CalculateLayout(sizes)
	w, _ = item.InternalWriteTL2(w, sizes)
	if ctx != nil {
		ctx.SizeBuffer = sizes
	}
	return w
}

func (item *CasesTestAllPossibleFieldConfigs) InternalReadTL2(r []byte) (_ []byte, err error) {
	currentSize := 0
	if r, currentSize, err = basictl.TL2ParseSize(r); err != nil {
		return r, err
	}
	if len(r) < currentSize {
		return r, basictl.TL2Error("not enough data: expected %d, got %d", currentSize, len(r))
	}

	if currentSize == 0 {
		item.Reset()
		return r, nil
	}
	currentR := r[:currentSize]
	r = r[currentSize:]

	var block byte
	if currentR, err = basictl.ByteReadTL2(currentR, &block); err != nil {
		return currentR, err
	}
	// read No of constructor
	if block&1 != 0 {
		var index int
		if currentR, err = basictl.TL2ReadSize(currentR, &index); err != nil {
			return currentR, err
		}
		if index != 0 {
			return r, internal.ErrorInvalidUnionIndex("cases.testAllPossibleFieldConfigs", index)
		}
	}
	item.tl2mask0 = 0
	if block&(1<<1) != 0 {
		if currentR, err = basictl.NatRead(currentR, &item.Local); err != nil {
			return currentR, err
		}
	} else {
		item.Local = 0
	}
	if block&(1<<2) != 0 {
		if currentR, err = basictl.IntRead(currentR, &item.F00); err != nil {
			return currentR, err
		}
	} else {
		item.F00 = 0
	}
	if block&(1<<3) != 0 {
		if currentR, err = basictl.SkipSizedValue(currentR); err != nil {
			return currentR, err
		}
	}
	if block&(1<<4) != 0 {
		if currentR, err = tlBuiltinVectorInt32.BuiltinVectorInt32InternalReadTL2(currentR, &item.F02); err != nil {
			return currentR, err
		}
	} else {
		item.F02 = item.F02[:0]
	}
	if block&(1<<5) != 0 {
		if currentR, err = tlBuiltinVectorInt32.BuiltinVectorInt32InternalReadTL2(currentR, &item.F03); err != nil {
			return currentR, err
		}
	} else {
		item.F03 = item.F03[:0]
	}
	if block&(1<<6) != 0 {
		item.tl2mask0 |= 1
	}
	if block&(1<<6) != 0 {
		if currentR, err = basictl.IntRead(currentR, &item.f10); err != nil {
			return currentR, err
		}
	} else {
		item.f10 = 0
	}

	// read next block for fields 8..15
	if len(currentR) > 0 {
		if currentR, err = basictl.ByteReadTL2(currentR, &block); err != nil {
			return currentR, err
		}
	} else {
		block = 0
	}
	if block&(1<<0) != 0 {
		item.tl2mask0 |= 2
	}
	if block&(1<<0) != 0 {
		if currentR, err = tlBuiltinVectorInt32.BuiltinVectorInt32InternalReadTL2(currentR, &item.f12); err != nil {
			return currentR, err
		}
	} else {
		item.f12 = item.f12[:0]
	}
	if block&(1<<1) != 0 {
		item.tl2mask0 |= 4
	}
	if block&(1<<1) != 0 {
		if currentR, err = tlBuiltinVectorInt32.BuiltinVectorInt32InternalReadTL2(currentR, &item.f13); err != nil {
			return currentR, err
		}
	} else {
		item.f13 = item.f13[:0]
	}
	if block&(1<<2) != 0 {
		item.tl2mask0 |= 8
	}
	if block&(1<<2) != 0 {
		if currentR, err = basictl.IntRead(currentR, &item.f20); err != nil {
			return currentR, err
		}
	} else {
		item.f20 = 0
	}
	if block&(1<<4) != 0 {
		item.tl2mask0 |= 16
	}
	if block&(1<<4) != 0 {
		if currentR, err = tlBuiltinVectorInt32.BuiltinVectorInt32InternalReadTL2(currentR, &item.f22); err != nil {
			return currentR, err
		}
	} else {
		item.f22 = item.f22[:0]
	}
	if block&(1<<5) != 0 {
		item.tl2mask0 |= 32
	}
	if block&(1<<5) != 0 {
		if currentR, err = tlBuiltinVectorInt32.BuiltinVectorInt32InternalReadTL2(currentR, &item.f23); err != nil {
			return currentR, err
		}
	} else {
		item.f23 = item.f23[:0]
	}
	internal.Unused(currentR)
	return r, nil
}

func (item *CasesTestAllPossibleFieldConfigs) ReadTL2(r []byte, ctx *basictl.TL2ReadContext) (_ []byte, err error) {
	return item.InternalReadTL2(r)
}
