// Copyright 2025 V Kontakte LLC
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Code generated by vktl/cmd/tlgen2; DO NOT EDIT.
package tlCasesTestAllPossibleFieldConfigs

import (
	"github.com/vkcom/tl/internal/tlcodegen/test/gen/casesTL2/internal"
	"github.com/vkcom/tl/internal/tlcodegen/test/gen/casesTL2/internal/tl/tlBuiltinVectorInt32"
	"github.com/vkcom/tl/internal/tlcodegen/test/gen/casesTL2/internal/tl/tlTrue"
	"github.com/vkcom/tl/pkg/basictl"
)

var _ = basictl.NatWrite
var _ = internal.ErrorInvalidEnumTag

type CasesTestAllPossibleFieldConfigs struct {
	Local uint32
	F00   int32
	F01   tlTrue.True
	F02   []int32
	F03   []int32
	f10   int32 // Conditional: item.mask1.6
	// F11 (TrueType)
	f12 []int32 // Conditional: item.mask2.0
	f13 []int32 // Conditional: item.mask2.1
	F20 int32
	// F21 (TrueType)
	F22 []int32
	F23 []int32

	mask1 byte // for fields #1 .. #7
	mask2 byte // for fields #8 .. #15
}

func (CasesTestAllPossibleFieldConfigs) TLName() string { return "cases.testAllPossibleFieldConfigs" }
func (CasesTestAllPossibleFieldConfigs) TLTag() uint32  { return 0x00000000 }

func (item *CasesTestAllPossibleFieldConfigs) GetF10() int32 {
	return item.f10
}
func (item *CasesTestAllPossibleFieldConfigs) SetF10(v int32) {
	item.f10 = v
	item.mask1 |= 1 << 6
}
func (item *CasesTestAllPossibleFieldConfigs) ClearF10() {
	item.f10 = 0
	item.mask1 &^= 1 << 6
}
func (item *CasesTestAllPossibleFieldConfigs) IsSetF10() bool { return item.mask1&(1<<6) != 0 }

func (item *CasesTestAllPossibleFieldConfigs) GetF12() []int32 {
	return item.f12
}
func (item *CasesTestAllPossibleFieldConfigs) SetF12(v []int32) {
	item.f12 = v
	item.mask2 |= 1 << 0
}
func (item *CasesTestAllPossibleFieldConfigs) ClearF12() {
	item.f12 = item.f12[:0]
	item.mask2 &^= 1 << 0
}
func (item *CasesTestAllPossibleFieldConfigs) IsSetF12() bool { return item.mask2&(1<<0) != 0 }

func (item *CasesTestAllPossibleFieldConfigs) GetF13() []int32 {
	return item.f13
}
func (item *CasesTestAllPossibleFieldConfigs) SetF13(v []int32) {
	item.f13 = v
	item.mask2 |= 1 << 1
}
func (item *CasesTestAllPossibleFieldConfigs) ClearF13() {
	item.f13 = item.f13[:0]
	item.mask2 &^= 1 << 1
}
func (item *CasesTestAllPossibleFieldConfigs) IsSetF13() bool { return item.mask2&(1<<1) != 0 }

func (item *CasesTestAllPossibleFieldConfigs) Reset() {
	item.Local = 0
	item.F00 = 0
	item.F02 = item.F02[:0]
	item.F03 = item.F03[:0]
	item.f10 = 0
	item.F11 = false
	item.f12 = item.f12[:0]
	item.f13 = item.f13[:0]
	item.F20 = 0
	item.F21 = false
	item.F22 = item.F22[:0]
	item.F23 = item.F23[:0]
}

func (item *CasesTestAllPossibleFieldConfigs) FillRandom(rg *basictl.RandGenerator) {
	item.mask1 = basictl.RandomByte(rg)
	item.mask2 = basictl.RandomByte(rg)
	item.Local = basictl.RandomUint(rg)
	item.F00 = basictl.RandomInt(rg)
	tlBuiltinVectorInt32.BuiltinVectorInt32FillRandom(rg, &item.F02)
	tlBuiltinVectorInt32.BuiltinVectorInt32FillRandom(rg, &item.F03)
	if item.mask1&(1<<6) != 0 {
		item.f10 = basictl.RandomInt(rg)
	} else {
		item.f10 = 0
	}
	item.F11 = basictl.RandomUint(rg)&1 == 1
	if item.mask2&(1<<0) != 0 {
		tlBuiltinVectorInt32.BuiltinVectorInt32FillRandom(rg, &item.f12)
	} else {
		item.f12 = item.f12[:0]
	}
	if item.mask2&(1<<1) != 0 {
		tlBuiltinVectorInt32.BuiltinVectorInt32FillRandom(rg, &item.f13)
	} else {
		item.f13 = item.f13[:0]
	}
	item.F20 = basictl.RandomInt(rg)
	item.F21 = basictl.RandomUint(rg)&1 == 1
	tlBuiltinVectorInt32.BuiltinVectorInt32FillRandom(rg, &item.F22)
	tlBuiltinVectorInt32.BuiltinVectorInt32FillRandom(rg, &item.F23)
}

func (item *CasesTestAllPossibleFieldConfigs) Read(w []byte) (_ []byte, err error) {
	return w, basictl.TL2Error("not implemented for tl2 type")
}

func (item *CasesTestAllPossibleFieldConfigs) WriteGeneral(w []byte) (_ []byte, err error) {
	return w, basictl.TL2Error("not implemented for tl2 type")
}

func (item *CasesTestAllPossibleFieldConfigs) Write(w []byte) []byte {
	return w
}

func (item *CasesTestAllPossibleFieldConfigs) ReadBoxed(w []byte) (_ []byte, err error) {
	return w, basictl.TL2Error("not implemented for tl2 type")
}

func (item *CasesTestAllPossibleFieldConfigs) WriteBoxedGeneral(w []byte) (_ []byte, err error) {
	return w, basictl.TL2Error("not implemented for tl2 type")
}

func (item *CasesTestAllPossibleFieldConfigs) WriteBoxed(w []byte) []byte {
	return w
}

func (item CasesTestAllPossibleFieldConfigs) String() string {
	return string(item.WriteJSON(nil))
}

func (item *CasesTestAllPossibleFieldConfigs) ReadJSON(legacyTypeNames bool, in *basictl.JsonLexer) error {
	tctx := basictl.JSONReadContext{LegacyTypeNames: legacyTypeNames}
	tctx.IsTL2 = true
	return item.ReadJSONGeneral(&tctx, in)
}

func (item *CasesTestAllPossibleFieldConfigs) ReadJSONGeneral(tctx *basictl.JSONReadContext, in *basictl.JsonLexer) error {
	var propLocalPresented bool
	var propF00Presented bool
	var propF02Presented bool
	var propF03Presented bool
	var propf10Presented bool
	var propF11Presented bool
	var propf12Presented bool
	var propf13Presented bool
	var propF20Presented bool
	var propF21Presented bool
	var propF22Presented bool
	var propF23Presented bool

	if in != nil {
		in.Delim('{')
		if !in.Ok() {
			return in.Error()
		}
		for !in.IsDelim('}') {
			key := in.UnsafeFieldName(true)
			in.WantColon()
			switch key {
			case "local":
				if propLocalPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "local")
				}
				if err := internal.Json2ReadUint32(in, &item.Local); err != nil {
					return err
				}
				propLocalPresented = true
			case "f00":
				if propF00Presented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "f00")
				}
				if err := internal.Json2ReadInt32(in, &item.F00); err != nil {
					return err
				}
				propF00Presented = true
			case "f01":
				var tmpF01 tlTrue.True
				if err := tmpF01.ReadJSONGeneral(tctx, in); err != nil {
					return err
				}
			case "f02":
				if propF02Presented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "f02")
				}
				if err := tlBuiltinVectorInt32.BuiltinVectorInt32ReadJSONGeneral(tctx, in, &item.F02); err != nil {
					return err
				}
				propF02Presented = true
			case "f03":
				if propF03Presented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "f03")
				}
				if err := tlBuiltinVectorInt32.BuiltinVectorInt32ReadJSONGeneral(tctx, in, &item.F03); err != nil {
					return err
				}
				propF03Presented = true
			case "f10":
				if propf10Presented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "f10")
				}
				if err := internal.Json2ReadInt32(in, &item.f10); err != nil {
					return err
				}
				propf10Presented = true
			case "f11":
				if propF11Presented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "f11")
				}
				if err := internal.Json2ReadBool(in, &item.F11); err != nil {
					return err
				}
				propF11Presented = true
			case "f12":
				if propf12Presented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "f12")
				}
				if err := tlBuiltinVectorInt32.BuiltinVectorInt32ReadJSONGeneral(tctx, in, &item.f12); err != nil {
					return err
				}
				propf12Presented = true
			case "f13":
				if propf13Presented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "f13")
				}
				if err := tlBuiltinVectorInt32.BuiltinVectorInt32ReadJSONGeneral(tctx, in, &item.f13); err != nil {
					return err
				}
				propf13Presented = true
			case "f20":
				if propF20Presented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "f20")
				}
				if err := internal.Json2ReadInt32(in, &item.F20); err != nil {
					return err
				}
				propF20Presented = true
			case "f21":
				if propF21Presented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "f21")
				}
				if err := internal.Json2ReadBool(in, &item.F21); err != nil {
					return err
				}
				propF21Presented = true
			case "f22":
				if propF22Presented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "f22")
				}
				if err := tlBuiltinVectorInt32.BuiltinVectorInt32ReadJSONGeneral(tctx, in, &item.F22); err != nil {
					return err
				}
				propF22Presented = true
			case "f23":
				if propF23Presented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "f23")
				}
				if err := tlBuiltinVectorInt32.BuiltinVectorInt32ReadJSONGeneral(tctx, in, &item.F23); err != nil {
					return err
				}
				propF23Presented = true
			default:
				return internal.ErrorInvalidJSONExcessElement("cases.testAllPossibleFieldConfigs", key)
			}
			in.WantComma()
		}
		in.Delim('}')
		if !in.Ok() {
			return in.Error()
		}
	}
	if !propLocalPresented {
		item.Local = 0
	}
	if !propF00Presented {
		item.F00 = 0
	}
	if !propF02Presented {
		item.F02 = item.F02[:0]
	}
	if !propF03Presented {
		item.F03 = item.F03[:0]
	}
	if !propf10Presented {
		item.f10 = 0
	}
	if !propF11Presented {
		item.F11 = false
	}
	if !propf12Presented {
		item.f12 = item.f12[:0]
	}
	if !propf13Presented {
		item.f13 = item.f13[:0]
	}
	if !propF20Presented {
		item.F20 = 0
	}
	if !propF21Presented {
		item.F21 = false
	}
	if !propF22Presented {
		item.F22 = item.F22[:0]
	}
	if !propF23Presented {
		item.F23 = item.F23[:0]
	}
	if propf10Presented {
		item.mask1 |= 1 << 6
	}
	if propf12Presented {
		item.mask2 |= 1 << 0
	}
	if propf13Presented {
		item.mask2 |= 1 << 1
	}
	return nil
}

// This method is general version of WriteJSON, use it instead!
func (item *CasesTestAllPossibleFieldConfigs) WriteJSONGeneral(tctx *basictl.JSONWriteContext, w []byte) (_ []byte, err error) {
	return item.WriteJSONOpt(tctx, w), nil
}

func (item *CasesTestAllPossibleFieldConfigs) WriteJSON(w []byte) []byte {
	tctx := basictl.JSONWriteContext{}
	tctx.IsTL2 = true
	return item.WriteJSONOpt(&tctx, w)
}
func (item *CasesTestAllPossibleFieldConfigs) WriteJSONOpt(tctx *basictl.JSONWriteContext, w []byte) []byte {
	w = append(w, '{')
	backupIndexLocal := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"local":`...)
	w = basictl.JSONWriteUint32(w, item.Local)
	if (item.Local != 0) == false {
		w = w[:backupIndexLocal]
	}
	backupIndexF00 := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"f00":`...)
	w = basictl.JSONWriteInt32(w, item.F00)
	if (item.F00 != 0) == false {
		w = w[:backupIndexF00]
	}
	backupIndexF02 := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"f02":`...)
	w = tlBuiltinVectorInt32.BuiltinVectorInt32WriteJSONOpt(tctx, w, item.F02)
	if (len(item.F02) != 0) == false {
		w = w[:backupIndexF02]
	}
	backupIndexF03 := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"f03":`...)
	w = tlBuiltinVectorInt32.BuiltinVectorInt32WriteJSONOpt(tctx, w, item.F03)
	if (len(item.F03) != 0) == false {
		w = w[:backupIndexF03]
	}
	if item.mask1&(1<<6) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"f10":`...)
		w = basictl.JSONWriteInt32(w, item.f10)
	}
	backupIndexF11 := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"f11":`...)
	w = basictl.JSONWriteBool(w, item.F11)
	if (item.F11) == false {
		w = w[:backupIndexF11]
	}
	if item.mask2&(1<<0) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"f12":`...)
		w = tlBuiltinVectorInt32.BuiltinVectorInt32WriteJSONOpt(tctx, w, item.f12)
	}
	if item.mask2&(1<<1) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"f13":`...)
		w = tlBuiltinVectorInt32.BuiltinVectorInt32WriteJSONOpt(tctx, w, item.f13)
	}
	backupIndexF20 := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"f20":`...)
	w = basictl.JSONWriteInt32(w, item.F20)
	if (item.F20 != 0) == false {
		w = w[:backupIndexF20]
	}
	backupIndexF21 := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"f21":`...)
	w = basictl.JSONWriteBool(w, item.F21)
	if (item.F21) == false {
		w = w[:backupIndexF21]
	}
	backupIndexF22 := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"f22":`...)
	w = tlBuiltinVectorInt32.BuiltinVectorInt32WriteJSONOpt(tctx, w, item.F22)
	if (len(item.F22) != 0) == false {
		w = w[:backupIndexF22]
	}
	backupIndexF23 := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"f23":`...)
	w = tlBuiltinVectorInt32.BuiltinVectorInt32WriteJSONOpt(tctx, w, item.F23)
	if (len(item.F23) != 0) == false {
		w = w[:backupIndexF23]
	}
	return append(w, '}')
}

func (item *CasesTestAllPossibleFieldConfigs) MarshalJSON() ([]byte, error) {
	return item.WriteJSON(nil), nil
}

func (item *CasesTestAllPossibleFieldConfigs) UnmarshalJSON(b []byte) error {
	if err := item.ReadJSON(true, &basictl.JsonLexer{Data: b}); err != nil {
		return internal.ErrorInvalidJSON("cases.testAllPossibleFieldConfigs", err.Error())
	}
	return nil
}

func (item *CasesTestAllPossibleFieldConfigs) CalculateLayout(sizes []int) []int {
	sizePosition := len(sizes)
	sizes = append(sizes, 0)

	currentSize := 0
	lastUsedByte := 0

	// calculate layout for item.Local
	if item.Local != 0 {

		lastUsedByte = 1
		currentSize += 4
	}

	// calculate layout for item.F00
	if item.F00 != 0 {

		lastUsedByte = 1
		currentSize += 4
	}

	var trueF01 tlTrue.True
	// calculate layout for trueF01
	currentPosition := len(sizes)
	sizes = trueF01.CalculateLayout(sizes)
	if sizes[currentPosition] != 0 {
		lastUsedByte = 1
		currentSize += sizes[currentPosition]
		currentSize += basictl.TL2CalculateSize(sizes[currentPosition])
	} else {
		sizes = sizes[:currentPosition+1]
	}

	// calculate layout for item.F02
	currentPosition = len(sizes)
	if len(item.F02) != 0 {
		sizes = tlBuiltinVectorInt32.BuiltinVectorInt32CalculateLayout(sizes, &item.F02)
		if sizes[currentPosition] != 0 {
			lastUsedByte = 1
			currentSize += sizes[currentPosition]
			currentSize += basictl.TL2CalculateSize(sizes[currentPosition])
		} else {
			sizes = sizes[:currentPosition+1]
		}
	}

	// calculate layout for item.F03
	currentPosition = len(sizes)
	if len(item.F03) != 0 {
		sizes = tlBuiltinVectorInt32.BuiltinVectorInt32CalculateLayout(sizes, &item.F03)
		if sizes[currentPosition] != 0 {
			lastUsedByte = 1
			currentSize += sizes[currentPosition]
			currentSize += basictl.TL2CalculateSize(sizes[currentPosition])
		} else {
			sizes = sizes[:currentPosition+1]
		}
	}

	// calculate layout for item.f10
	if item.mask1&(1<<6) != 0 {
		if item.f10 != 0 {

			lastUsedByte = 1
			currentSize += 4
		}
	}

	// calculate layout for item.F11
	if item.F11 {

		lastUsedByte = 1
		currentSize += 0
	}

	// calculate layout for item.f12
	currentPosition = len(sizes)
	if item.mask2&(1<<0) != 0 {
		if len(item.f12) != 0 {
			sizes = tlBuiltinVectorInt32.BuiltinVectorInt32CalculateLayout(sizes, &item.f12)
			if sizes[currentPosition] != 0 {
				lastUsedByte = 2
				currentSize += sizes[currentPosition]
				currentSize += basictl.TL2CalculateSize(sizes[currentPosition])
			} else {
				sizes = sizes[:currentPosition+1]
			}
		}
	}

	// calculate layout for item.f13
	currentPosition = len(sizes)
	if item.mask2&(1<<1) != 0 {
		if len(item.f13) != 0 {
			sizes = tlBuiltinVectorInt32.BuiltinVectorInt32CalculateLayout(sizes, &item.f13)
			if sizes[currentPosition] != 0 {
				lastUsedByte = 2
				currentSize += sizes[currentPosition]
				currentSize += basictl.TL2CalculateSize(sizes[currentPosition])
			} else {
				sizes = sizes[:currentPosition+1]
			}
		}
	}

	// calculate layout for item.F20
	if item.F20 != 0 {

		lastUsedByte = 2
		currentSize += 4
	}

	// calculate layout for item.F21
	if item.F21 {

		lastUsedByte = 2
		currentSize += 0
	}

	// calculate layout for item.F22
	currentPosition = len(sizes)
	if len(item.F22) != 0 {
		sizes = tlBuiltinVectorInt32.BuiltinVectorInt32CalculateLayout(sizes, &item.F22)
		if sizes[currentPosition] != 0 {
			lastUsedByte = 2
			currentSize += sizes[currentPosition]
			currentSize += basictl.TL2CalculateSize(sizes[currentPosition])
		} else {
			sizes = sizes[:currentPosition+1]
		}
	}

	// calculate layout for item.F23
	currentPosition = len(sizes)
	if len(item.F23) != 0 {
		sizes = tlBuiltinVectorInt32.BuiltinVectorInt32CalculateLayout(sizes, &item.F23)
		if sizes[currentPosition] != 0 {
			lastUsedByte = 2
			currentSize += sizes[currentPosition]
			currentSize += basictl.TL2CalculateSize(sizes[currentPosition])
		} else {
			sizes = sizes[:currentPosition+1]
		}
	}

	// append byte for each section until last mentioned field
	if lastUsedByte != 0 {
		currentSize += lastUsedByte
	} else {
		// remove unused values
		sizes = sizes[:sizePosition+1]
	}
	sizes[sizePosition] = currentSize
	return sizes
}

func (item *CasesTestAllPossibleFieldConfigs) InternalWriteTL2(w []byte, sizes []int) ([]byte, []int) {
	currentSize := sizes[0]
	sizes = sizes[1:]

	serializedSize := 0

	w = basictl.TL2WriteSize(w, currentSize)
	if currentSize == 0 {
		return w, sizes
	}

	var currentBlock byte
	currentBlockPosition := len(w)
	w = append(w, 0)
	serializedSize += 1
	// write item.Local
	if item.Local != 0 {
		serializedSize += 4
		if 4 != 0 {
			currentBlock |= (1 << 1)
			w = basictl.NatWrite(w, item.Local)
		}
	}
	// write item.F00
	if item.F00 != 0 {
		serializedSize += 4
		if 4 != 0 {
			currentBlock |= (1 << 2)
			w = basictl.IntWrite(w, item.F00)
		}
	}
	var trueF01 tlTrue.True
	// write trueF01
	serializedSize += sizes[0]
	if sizes[0] != 0 {
		serializedSize += basictl.TL2CalculateSize(sizes[0])
		currentBlock |= (1 << 3)
		w, sizes = trueF01.InternalWriteTL2(w, sizes)
	} else {
		sizes = sizes[1:]
	}
	// write item.F02
	if len(item.F02) != 0 {
		serializedSize += sizes[0]
		if sizes[0] != 0 {
			serializedSize += basictl.TL2CalculateSize(sizes[0])
			currentBlock |= (1 << 4)
			w, sizes = tlBuiltinVectorInt32.BuiltinVectorInt32InternalWriteTL2(w, sizes, &item.F02)
		} else {
			sizes = sizes[1:]
		}
	}
	// write item.F03
	if len(item.F03) != 0 {
		serializedSize += sizes[0]
		if sizes[0] != 0 {
			serializedSize += basictl.TL2CalculateSize(sizes[0])
			currentBlock |= (1 << 5)
			w, sizes = tlBuiltinVectorInt32.BuiltinVectorInt32InternalWriteTL2(w, sizes, &item.F03)
		} else {
			sizes = sizes[1:]
		}
	}
	// write item.f10
	if item.mask1&(1<<6) != 0 {
		if item.f10 != 0 {
			serializedSize += 4
			if 4 != 0 {
				currentBlock |= (1 << 6)
				w = basictl.IntWrite(w, item.f10)
			}
		}
	}
	// write item.F11
	if item.F11 {
		serializedSize += 0
		currentBlock |= (1 << 7)

	}

	// add byte for fields with index 8..15
	w[currentBlockPosition] = currentBlock
	currentBlock = 0
	if serializedSize != currentSize {
		currentBlockPosition = len(w)
		w = append(w, 0)
		serializedSize += 1
	} else {
		return w, sizes
	}
	// write item.f12
	if item.mask2&(1<<0) != 0 {
		if len(item.f12) != 0 {
			serializedSize += sizes[0]
			if sizes[0] != 0 {
				serializedSize += basictl.TL2CalculateSize(sizes[0])
				currentBlock |= (1 << 0)
				w, sizes = tlBuiltinVectorInt32.BuiltinVectorInt32InternalWriteTL2(w, sizes, &item.f12)
			} else {
				sizes = sizes[1:]
			}
		}
	}
	// write item.f13
	if item.mask2&(1<<1) != 0 {
		if len(item.f13) != 0 {
			serializedSize += sizes[0]
			if sizes[0] != 0 {
				serializedSize += basictl.TL2CalculateSize(sizes[0])
				currentBlock |= (1 << 1)
				w, sizes = tlBuiltinVectorInt32.BuiltinVectorInt32InternalWriteTL2(w, sizes, &item.f13)
			} else {
				sizes = sizes[1:]
			}
		}
	}
	// write item.F20
	if item.F20 != 0 {
		serializedSize += 4
		if 4 != 0 {
			currentBlock |= (1 << 2)
			w = basictl.IntWrite(w, item.F20)
		}
	}
	// write item.F21
	if item.F21 {
		serializedSize += 0
		currentBlock |= (1 << 3)

	}
	// write item.F22
	if len(item.F22) != 0 {
		serializedSize += sizes[0]
		if sizes[0] != 0 {
			serializedSize += basictl.TL2CalculateSize(sizes[0])
			currentBlock |= (1 << 4)
			w, sizes = tlBuiltinVectorInt32.BuiltinVectorInt32InternalWriteTL2(w, sizes, &item.F22)
		} else {
			sizes = sizes[1:]
		}
	}
	// write item.F23
	if len(item.F23) != 0 {
		serializedSize += sizes[0]
		if sizes[0] != 0 {
			serializedSize += basictl.TL2CalculateSize(sizes[0])
			currentBlock |= (1 << 5)
			w, sizes = tlBuiltinVectorInt32.BuiltinVectorInt32InternalWriteTL2(w, sizes, &item.F23)
		} else {
			sizes = sizes[1:]
		}
	}
	w[currentBlockPosition] = currentBlock
	return w, sizes
}

func (item *CasesTestAllPossibleFieldConfigs) WriteTL2(w []byte, ctx *basictl.TL2WriteContext) []byte {
	var sizes []int
	if ctx != nil {
		sizes = ctx.SizeBuffer[:0]
	}
	sizes = item.CalculateLayout(sizes)
	w, _ = item.InternalWriteTL2(w, sizes)
	if ctx != nil {
		ctx.SizeBuffer = sizes
	}
	return w
}

func (item *CasesTestAllPossibleFieldConfigs) InternalReadTL2(r []byte) (_ []byte, err error) {
	currentSize := 0
	if r, currentSize, err = basictl.TL2ParseSize(r); err != nil {
		return r, err
	}
	if len(r) < currentSize {
		return r, basictl.TL2Error("not enough data: expected %d, got %d", currentSize, len(r))
	}

	currentR := r[:currentSize]
	r = r[currentSize:]

	if currentSize == 0 {
		item.Reset()
		return r, nil
	}
	var block byte
	if currentR, err = basictl.ByteReadTL2(currentR, &block); err != nil {
		return currentR, err
	}
	// read No of constructor
	if block&1 != 0 {
		var index int
		if currentR, err = basictl.TL2ReadSize(currentR, &index); err != nil {
			return currentR, err
		}
		if index != 0 {
			// unknown cases for current type
			item.Reset()
			return r, nil
		}
	}
	item.mask1 = block

	// read item.Local
	if block&(1<<1) != 0 {
		if currentR, err = basictl.NatRead(currentR, &item.Local); err != nil {
			return currentR, err
		}
	} else {
		item.Local = 0
	}

	// read item.F00
	if block&(1<<2) != 0 {
		if currentR, err = basictl.IntRead(currentR, &item.F00); err != nil {
			return currentR, err
		}
	} else {
		item.F00 = 0
	}

	var trueF01 tlTrue.True
	// read trueF01
	if block&(1<<3) != 0 {
		if currentR, err = trueF01.InternalReadTL2(currentR); err != nil {
			return currentR, err
		}
	} else {
		trueF01.Reset()
	}

	// read item.F02
	if block&(1<<4) != 0 {
		if currentR, err = tlBuiltinVectorInt32.BuiltinVectorInt32InternalReadTL2(currentR, &item.F02); err != nil {
			return currentR, err
		}
	} else {
		item.F02 = item.F02[:0]
	}

	// read item.F03
	if block&(1<<5) != 0 {
		if currentR, err = tlBuiltinVectorInt32.BuiltinVectorInt32InternalReadTL2(currentR, &item.F03); err != nil {
			return currentR, err
		}
	} else {
		item.F03 = item.F03[:0]
	}

	// read item.f10
	if block&(1<<6) != 0 {
		if item.mask1&(1<<6) != 0 {
			if currentR, err = basictl.IntRead(currentR, &item.f10); err != nil {
				return currentR, err
			}
		} else {
			return currentR, basictl.TL2Error("field mask contradiction: field item." + "f10" + "is presented but depending bit is absent")
		}
	} else {
		item.f10 = 0
	}

	// read item.F11
	if block&(1<<7) != 0 {
		item.F11 = true
	} else {
		item.F11 = false
	}

	// read next block for fields 8..15
	if len(currentR) > 0 {
		if currentR, err = basictl.ByteReadTL2(currentR, &block); err != nil {
			return currentR, err
		}
	} else {
		block = 0
	}
	item.mask2 = block

	// read item.f12
	if block&(1<<0) != 0 {
		if item.mask2&(1<<0) != 0 {
			if currentR, err = tlBuiltinVectorInt32.BuiltinVectorInt32InternalReadTL2(currentR, &item.f12); err != nil {
				return currentR, err
			}
		} else {
			return currentR, basictl.TL2Error("field mask contradiction: field item." + "f12" + "is presented but depending bit is absent")
		}
	} else {
		item.f12 = item.f12[:0]
	}

	// read item.f13
	if block&(1<<1) != 0 {
		if item.mask2&(1<<1) != 0 {
			if currentR, err = tlBuiltinVectorInt32.BuiltinVectorInt32InternalReadTL2(currentR, &item.f13); err != nil {
				return currentR, err
			}
		} else {
			return currentR, basictl.TL2Error("field mask contradiction: field item." + "f13" + "is presented but depending bit is absent")
		}
	} else {
		item.f13 = item.f13[:0]
	}

	// read item.F20
	if block&(1<<2) != 0 {
		if currentR, err = basictl.IntRead(currentR, &item.F20); err != nil {
			return currentR, err
		}
	} else {
		item.F20 = 0
	}

	// read item.F21
	if block&(1<<3) != 0 {
		item.F21 = true
	} else {
		item.F21 = false
	}

	// read item.F22
	if block&(1<<4) != 0 {
		if currentR, err = tlBuiltinVectorInt32.BuiltinVectorInt32InternalReadTL2(currentR, &item.F22); err != nil {
			return currentR, err
		}
	} else {
		item.F22 = item.F22[:0]
	}

	// read item.F23
	if block&(1<<5) != 0 {
		if currentR, err = tlBuiltinVectorInt32.BuiltinVectorInt32InternalReadTL2(currentR, &item.F23); err != nil {
			return currentR, err
		}
	} else {
		item.F23 = item.F23[:0]
	}

	return r, nil
}

func (item *CasesTestAllPossibleFieldConfigs) ReadTL2(r []byte, ctx *basictl.TL2ReadContext) (_ []byte, err error) {
	return item.InternalReadTL2(r)
}
