// Copyright 2025 V Kontakte LLC
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Code generated by vktl/cmd/tlgen2; DO NOT EDIT.
package tlBenchmarksVruPosition

import (
	"github.com/vkcom/tl/internal/tlcodegen/test/gen/cases/internal"
	"github.com/vkcom/tl/internal/tlcodegen/test/gen/cases/internal/tlbenchmarks/tlBenchmarksVruHash"
	"github.com/vkcom/tl/pkg/basictl"
)

var _ = basictl.NatWrite
var _ = internal.ErrorInvalidEnumTag

type BenchmarksVruPosition struct {
	FieldsMask uint32
	// CommitBit (TrueType) // Conditional: item.FieldsMask.0
	// MetaBlock (TrueType) // Conditional: item.FieldsMask.1
	// SplitPayload (TrueType) // Conditional: item.FieldsMask.3
	// RotationBlock (TrueType) // Conditional: item.FieldsMask.5
	// CanonicalHash (TrueType) // Conditional: item.FieldsMask.15
	PayloadOffset int64
	BlockTimeNano int64
	Hash          tlBenchmarksVruHash.BenchmarksVruHash
	FileOffset    int64
	SeqNumber     int64 // Conditional: item.FieldsMask.14
}

func (BenchmarksVruPosition) TLName() string { return "benchmarks.vruposition" }
func (BenchmarksVruPosition) TLTag() uint32  { return 0x32792c04 }

func (item *BenchmarksVruPosition) SetCommitBit(v bool) {
	if v {
		item.FieldsMask |= 1 << 0
	} else {
		item.FieldsMask &^= 1 << 0
	}
}
func (item *BenchmarksVruPosition) IsSetCommitBit() bool { return item.FieldsMask&(1<<0) != 0 }

func (item *BenchmarksVruPosition) SetMetaBlock(v bool) {
	if v {
		item.FieldsMask |= 1 << 1
	} else {
		item.FieldsMask &^= 1 << 1
	}
}
func (item *BenchmarksVruPosition) IsSetMetaBlock() bool { return item.FieldsMask&(1<<1) != 0 }

func (item *BenchmarksVruPosition) SetSplitPayload(v bool) {
	if v {
		item.FieldsMask |= 1 << 3
	} else {
		item.FieldsMask &^= 1 << 3
	}
}
func (item *BenchmarksVruPosition) IsSetSplitPayload() bool { return item.FieldsMask&(1<<3) != 0 }

func (item *BenchmarksVruPosition) SetRotationBlock(v bool) {
	if v {
		item.FieldsMask |= 1 << 5
	} else {
		item.FieldsMask &^= 1 << 5
	}
}
func (item *BenchmarksVruPosition) IsSetRotationBlock() bool { return item.FieldsMask&(1<<5) != 0 }

func (item *BenchmarksVruPosition) SetCanonicalHash(v bool) {
	if v {
		item.FieldsMask |= 1 << 15
	} else {
		item.FieldsMask &^= 1 << 15
	}
}
func (item *BenchmarksVruPosition) IsSetCanonicalHash() bool { return item.FieldsMask&(1<<15) != 0 }

func (item *BenchmarksVruPosition) SetSeqNumber(v int64) {
	item.SeqNumber = v
	item.FieldsMask |= 1 << 14
}
func (item *BenchmarksVruPosition) ClearSeqNumber() {
	item.SeqNumber = 0
	item.FieldsMask &^= 1 << 14
}
func (item *BenchmarksVruPosition) IsSetSeqNumber() bool { return item.FieldsMask&(1<<14) != 0 }

func (item *BenchmarksVruPosition) Reset() {
	item.FieldsMask = 0
	item.PayloadOffset = 0
	item.BlockTimeNano = 0
	item.Hash.Reset()
	item.FileOffset = 0
	item.SeqNumber = 0
}

func (item *BenchmarksVruPosition) FillRandom(rg *basictl.RandGenerator) {
	var maskFieldsMask uint32
	maskFieldsMask = basictl.RandomUint(rg)
	item.FieldsMask = 0
	if maskFieldsMask&(1<<0) != 0 {
		item.FieldsMask |= (1 << 0)
	}
	if maskFieldsMask&(1<<1) != 0 {
		item.FieldsMask |= (1 << 1)
	}
	if maskFieldsMask&(1<<2) != 0 {
		item.FieldsMask |= (1 << 3)
	}
	if maskFieldsMask&(1<<3) != 0 {
		item.FieldsMask |= (1 << 5)
	}
	if maskFieldsMask&(1<<4) != 0 {
		item.FieldsMask |= (1 << 14)
	}
	if maskFieldsMask&(1<<5) != 0 {
		item.FieldsMask |= (1 << 15)
	}
	item.PayloadOffset = basictl.RandomLong(rg)
	item.BlockTimeNano = basictl.RandomLong(rg)
	item.Hash.FillRandom(rg)
	item.FileOffset = basictl.RandomLong(rg)
	if item.FieldsMask&(1<<14) != 0 {
		item.SeqNumber = basictl.RandomLong(rg)
	} else {
		item.SeqNumber = 0
	}
}

func (item *BenchmarksVruPosition) Read(w []byte) (_ []byte, err error) {
	if w, err = basictl.NatRead(w, &item.FieldsMask); err != nil {
		return w, err
	}
	if w, err = basictl.LongRead(w, &item.PayloadOffset); err != nil {
		return w, err
	}
	if w, err = basictl.LongRead(w, &item.BlockTimeNano); err != nil {
		return w, err
	}
	if w, err = item.Hash.Read(w); err != nil {
		return w, err
	}
	if w, err = basictl.LongRead(w, &item.FileOffset); err != nil {
		return w, err
	}
	if item.FieldsMask&(1<<14) != 0 {
		if w, err = basictl.LongRead(w, &item.SeqNumber); err != nil {
			return w, err
		}
	} else {
		item.SeqNumber = 0
	}
	return w, nil
}

// This method is general version of Write, use it instead!
func (item *BenchmarksVruPosition) WriteGeneral(w []byte) (_ []byte, err error) {
	return item.Write(w), nil
}

func (item *BenchmarksVruPosition) Write(w []byte) []byte {
	w = basictl.NatWrite(w, item.FieldsMask)
	w = basictl.LongWrite(w, item.PayloadOffset)
	w = basictl.LongWrite(w, item.BlockTimeNano)
	w = item.Hash.Write(w)
	w = basictl.LongWrite(w, item.FileOffset)
	if item.FieldsMask&(1<<14) != 0 {
		w = basictl.LongWrite(w, item.SeqNumber)
	}
	return w
}

func (item *BenchmarksVruPosition) ReadBoxed(w []byte) (_ []byte, err error) {
	if w, err = basictl.NatReadExactTag(w, 0x32792c04); err != nil {
		return w, err
	}
	return item.Read(w)
}

// This method is general version of WriteBoxed, use it instead!
func (item *BenchmarksVruPosition) WriteBoxedGeneral(w []byte) (_ []byte, err error) {
	return item.WriteBoxed(w), nil
}

func (item *BenchmarksVruPosition) WriteBoxed(w []byte) []byte {
	w = basictl.NatWrite(w, 0x32792c04)
	return item.Write(w)
}

func (item BenchmarksVruPosition) String() string {
	return string(item.WriteJSON(nil))
}

func (item *BenchmarksVruPosition) CalculateLayout(sizes []int) []int {
	sizePosition := len(sizes)
	sizes = append(sizes, 0)
	lastUsedBit := -1

	// calculate layout for item.FieldsMask
	currentPosition := len(sizes)
	if item.FieldsMask != 0 {
		sizes = append(sizes, 4)
		if sizes[currentPosition] != 0 {
			lastUsedBit = 1
			sizes[sizePosition] += sizes[currentPosition]
		} else {
			sizes = sizes[:currentPosition+1]
		}
	}

	// calculate layout for item.CommitBit
	currentPosition = len(sizes)
	if item.FieldsMask&(1<<0) != 0 {
		lastUsedBit = 2
	}

	// calculate layout for item.MetaBlock
	currentPosition = len(sizes)
	if item.FieldsMask&(1<<1) != 0 {
		lastUsedBit = 3
	}

	// calculate layout for item.SplitPayload
	currentPosition = len(sizes)
	if item.FieldsMask&(1<<3) != 0 {
		lastUsedBit = 4
	}

	// calculate layout for item.RotationBlock
	currentPosition = len(sizes)
	if item.FieldsMask&(1<<5) != 0 {
		lastUsedBit = 5
	}

	// calculate layout for item.CanonicalHash
	currentPosition = len(sizes)
	if item.FieldsMask&(1<<15) != 0 {
		lastUsedBit = 6
	}

	// calculate layout for item.PayloadOffset
	currentPosition = len(sizes)
	if item.PayloadOffset != 0 {
		sizes = append(sizes, 8)
		if sizes[currentPosition] != 0 {
			lastUsedBit = 7
			sizes[sizePosition] += sizes[currentPosition]
		} else {
			sizes = sizes[:currentPosition+1]
		}
	}

	// calculate layout for item.BlockTimeNano
	currentPosition = len(sizes)
	if item.BlockTimeNano != 0 {
		sizes = append(sizes, 8)
		if sizes[currentPosition] != 0 {
			lastUsedBit = 8
			sizes[sizePosition] += sizes[currentPosition]
		} else {
			sizes = sizes[:currentPosition+1]
		}
	}

	// calculate layout for item.Hash
	currentPosition = len(sizes)
	sizes = item.Hash.CalculateLayout(sizes)
	if sizes[currentPosition] != 0 {
		lastUsedBit = 9
		sizes[sizePosition] += sizes[currentPosition]
		sizes[sizePosition] += basictl.TL2CalculateSize(sizes[currentPosition])
	} else {
		sizes = sizes[:currentPosition+1]
	}

	// calculate layout for item.FileOffset
	currentPosition = len(sizes)
	if item.FileOffset != 0 {
		sizes = append(sizes, 8)
		if sizes[currentPosition] != 0 {
			lastUsedBit = 10
			sizes[sizePosition] += sizes[currentPosition]
		} else {
			sizes = sizes[:currentPosition+1]
		}
	}

	// calculate layout for item.SeqNumber
	currentPosition = len(sizes)
	if item.FieldsMask&(1<<14) != 0 {
		if item.SeqNumber != 0 {
			sizes = append(sizes, 8)
			if sizes[currentPosition] != 0 {
				lastUsedBit = 11
				sizes[sizePosition] += sizes[currentPosition]
			} else {
				sizes = sizes[:currentPosition+1]
			}
		}
	}

	// append byte for each section until last mentioned field
	if lastUsedBit != -1 {
		sizes[sizePosition] += lastUsedBit/8 + 1
	} else {
		// remove unused values
		sizes = sizes[:sizePosition+1]
	}
	return sizes
}

func (item *BenchmarksVruPosition) InternalWriteTL2(w []byte, sizes []int) ([]byte, []int) {
	currentSize := sizes[0]
	sizes = sizes[1:]

	serializedSize := 0

	w = basictl.TL2WriteSize(w, currentSize)
	if currentSize == 0 {
		return w, sizes
	}

	currentBlockPosition := len(w)
	w = append(w, 0)
	serializedSize += 1

	// calculate layout for item.FieldsMask
	if item.FieldsMask != 0 {
		serializedSize += sizes[0]
		if sizes[0] != 0 {
			w[currentBlockPosition] |= (1 << 1)
			sizes = sizes[1:]
			w = basictl.NatWrite(w, item.FieldsMask)

		} else {
			sizes = sizes[1:]
		}
	}

	// calculate layout for item.CommitBit
	if item.FieldsMask&(1<<0) != 0 {
		w[currentBlockPosition] |= (1 << 2)
	}

	// calculate layout for item.MetaBlock
	if item.FieldsMask&(1<<1) != 0 {
		w[currentBlockPosition] |= (1 << 3)
	}

	// calculate layout for item.SplitPayload
	if item.FieldsMask&(1<<3) != 0 {
		w[currentBlockPosition] |= (1 << 4)
	}

	// calculate layout for item.RotationBlock
	if item.FieldsMask&(1<<5) != 0 {
		w[currentBlockPosition] |= (1 << 5)
	}

	// calculate layout for item.CanonicalHash
	if item.FieldsMask&(1<<15) != 0 {
		w[currentBlockPosition] |= (1 << 6)
	}

	// calculate layout for item.PayloadOffset
	if item.PayloadOffset != 0 {
		serializedSize += sizes[0]
		if sizes[0] != 0 {
			w[currentBlockPosition] |= (1 << 7)
			sizes = sizes[1:]
			w = basictl.LongWrite(w, item.PayloadOffset)

		} else {
			sizes = sizes[1:]
		}
	}

	// add byte for fields with index 8..15
	if serializedSize != currentSize {
		currentBlockPosition = len(w)
		w = append(w, 0)
		serializedSize += 1
	} else {
		return w, sizes
	}

	// calculate layout for item.BlockTimeNano
	if item.BlockTimeNano != 0 {
		serializedSize += sizes[0]
		if sizes[0] != 0 {
			w[currentBlockPosition] |= (1 << 0)
			sizes = sizes[1:]
			w = basictl.LongWrite(w, item.BlockTimeNano)

		} else {
			sizes = sizes[1:]
		}
	}

	// calculate layout for item.Hash
	serializedSize += sizes[0]
	if sizes[0] != 0 {
		serializedSize += basictl.TL2CalculateSize(sizes[0])
		w[currentBlockPosition] |= (1 << 1)
		w, sizes = item.Hash.InternalWriteTL2(w, sizes)

	} else {
		sizes = sizes[1:]
	}

	// calculate layout for item.FileOffset
	if item.FileOffset != 0 {
		serializedSize += sizes[0]
		if sizes[0] != 0 {
			w[currentBlockPosition] |= (1 << 2)
			sizes = sizes[1:]
			w = basictl.LongWrite(w, item.FileOffset)

		} else {
			sizes = sizes[1:]
		}
	}

	// calculate layout for item.SeqNumber
	if item.FieldsMask&(1<<14) != 0 {
		if item.SeqNumber != 0 {
			serializedSize += sizes[0]
			if sizes[0] != 0 {
				w[currentBlockPosition] |= (1 << 3)
				sizes = sizes[1:]
				w = basictl.LongWrite(w, item.SeqNumber)

			} else {
				sizes = sizes[1:]
			}
		}
	}

	return w, sizes
}

func (item *BenchmarksVruPosition) WriteTL2(w []byte, sizes []int) ([]byte, []int) {
	sizes = item.CalculateLayout(sizes[0:0])
	return item.InternalWriteTL2(w, sizes)
}

func (item *BenchmarksVruPosition) ReadJSON(legacyTypeNames bool, in *basictl.JsonLexer) error {
	var propFieldsMaskPresented bool
	var trueTypeCommitBitPresented bool
	var trueTypeCommitBitValue bool
	var trueTypeMetaBlockPresented bool
	var trueTypeMetaBlockValue bool
	var trueTypeSplitPayloadPresented bool
	var trueTypeSplitPayloadValue bool
	var trueTypeRotationBlockPresented bool
	var trueTypeRotationBlockValue bool
	var trueTypeCanonicalHashPresented bool
	var trueTypeCanonicalHashValue bool
	var propPayloadOffsetPresented bool
	var propBlockTimeNanoPresented bool
	var propHashPresented bool
	var propFileOffsetPresented bool
	var propSeqNumberPresented bool

	if in != nil {
		in.Delim('{')
		if !in.Ok() {
			return in.Error()
		}
		for !in.IsDelim('}') {
			key := in.UnsafeFieldName(true)
			in.WantColon()
			switch key {
			case "fields_mask":
				if propFieldsMaskPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("benchmarks.vruposition", "fields_mask")
				}
				if err := internal.Json2ReadUint32(in, &item.FieldsMask); err != nil {
					return err
				}
				propFieldsMaskPresented = true
			case "commit_bit":
				if trueTypeCommitBitPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("benchmarks.vruposition", "commit_bit")
				}
				if err := internal.Json2ReadBool(in, &trueTypeCommitBitValue); err != nil {
					return err
				}
				trueTypeCommitBitPresented = true
			case "meta_block":
				if trueTypeMetaBlockPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("benchmarks.vruposition", "meta_block")
				}
				if err := internal.Json2ReadBool(in, &trueTypeMetaBlockValue); err != nil {
					return err
				}
				trueTypeMetaBlockPresented = true
			case "split_payload":
				if trueTypeSplitPayloadPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("benchmarks.vruposition", "split_payload")
				}
				if err := internal.Json2ReadBool(in, &trueTypeSplitPayloadValue); err != nil {
					return err
				}
				trueTypeSplitPayloadPresented = true
			case "rotation_block":
				if trueTypeRotationBlockPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("benchmarks.vruposition", "rotation_block")
				}
				if err := internal.Json2ReadBool(in, &trueTypeRotationBlockValue); err != nil {
					return err
				}
				trueTypeRotationBlockPresented = true
			case "canonical_hash":
				if trueTypeCanonicalHashPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("benchmarks.vruposition", "canonical_hash")
				}
				if err := internal.Json2ReadBool(in, &trueTypeCanonicalHashValue); err != nil {
					return err
				}
				trueTypeCanonicalHashPresented = true
			case "payload_offset":
				if propPayloadOffsetPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("benchmarks.vruposition", "payload_offset")
				}
				if err := internal.Json2ReadInt64(in, &item.PayloadOffset); err != nil {
					return err
				}
				propPayloadOffsetPresented = true
			case "block_time_nano":
				if propBlockTimeNanoPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("benchmarks.vruposition", "block_time_nano")
				}
				if err := internal.Json2ReadInt64(in, &item.BlockTimeNano); err != nil {
					return err
				}
				propBlockTimeNanoPresented = true
			case "hash":
				if propHashPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("benchmarks.vruposition", "hash")
				}
				if err := item.Hash.ReadJSON(legacyTypeNames, in); err != nil {
					return err
				}
				propHashPresented = true
			case "file_offset":
				if propFileOffsetPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("benchmarks.vruposition", "file_offset")
				}
				if err := internal.Json2ReadInt64(in, &item.FileOffset); err != nil {
					return err
				}
				propFileOffsetPresented = true
			case "seq_number":
				if propSeqNumberPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("benchmarks.vruposition", "seq_number")
				}
				if err := internal.Json2ReadInt64(in, &item.SeqNumber); err != nil {
					return err
				}
				propSeqNumberPresented = true
			default:
				return internal.ErrorInvalidJSONExcessElement("benchmarks.vruposition", key)
			}
			in.WantComma()
		}
		in.Delim('}')
		if !in.Ok() {
			return in.Error()
		}
	}
	if !propFieldsMaskPresented {
		item.FieldsMask = 0
	}
	if !propPayloadOffsetPresented {
		item.PayloadOffset = 0
	}
	if !propBlockTimeNanoPresented {
		item.BlockTimeNano = 0
	}
	if !propHashPresented {
		item.Hash.Reset()
	}
	if !propFileOffsetPresented {
		item.FileOffset = 0
	}
	if !propSeqNumberPresented {
		item.SeqNumber = 0
	}
	if trueTypeCommitBitPresented {
		if trueTypeCommitBitValue {
			item.FieldsMask |= 1 << 0
		}
	}
	if trueTypeMetaBlockPresented {
		if trueTypeMetaBlockValue {
			item.FieldsMask |= 1 << 1
		}
	}
	if trueTypeSplitPayloadPresented {
		if trueTypeSplitPayloadValue {
			item.FieldsMask |= 1 << 3
		}
	}
	if trueTypeRotationBlockPresented {
		if trueTypeRotationBlockValue {
			item.FieldsMask |= 1 << 5
		}
	}
	if trueTypeCanonicalHashPresented {
		if trueTypeCanonicalHashValue {
			item.FieldsMask |= 1 << 15
		}
	}
	if propSeqNumberPresented {
		item.FieldsMask |= 1 << 14
	}
	// tries to set bit to zero if it is 1
	if trueTypeCommitBitPresented && !trueTypeCommitBitValue && (item.FieldsMask&(1<<0) != 0) {
		return internal.ErrorInvalidJSON("benchmarks.vruposition", "fieldmask bit fields_mask.0 is indefinite because of the contradictions in values")
	}
	// tries to set bit to zero if it is 1
	if trueTypeMetaBlockPresented && !trueTypeMetaBlockValue && (item.FieldsMask&(1<<1) != 0) {
		return internal.ErrorInvalidJSON("benchmarks.vruposition", "fieldmask bit fields_mask.0 is indefinite because of the contradictions in values")
	}
	// tries to set bit to zero if it is 1
	if trueTypeSplitPayloadPresented && !trueTypeSplitPayloadValue && (item.FieldsMask&(1<<3) != 0) {
		return internal.ErrorInvalidJSON("benchmarks.vruposition", "fieldmask bit fields_mask.0 is indefinite because of the contradictions in values")
	}
	// tries to set bit to zero if it is 1
	if trueTypeRotationBlockPresented && !trueTypeRotationBlockValue && (item.FieldsMask&(1<<5) != 0) {
		return internal.ErrorInvalidJSON("benchmarks.vruposition", "fieldmask bit fields_mask.0 is indefinite because of the contradictions in values")
	}
	// tries to set bit to zero if it is 1
	if trueTypeCanonicalHashPresented && !trueTypeCanonicalHashValue && (item.FieldsMask&(1<<15) != 0) {
		return internal.ErrorInvalidJSON("benchmarks.vruposition", "fieldmask bit fields_mask.0 is indefinite because of the contradictions in values")
	}
	return nil
}

// This method is general version of WriteJSON, use it instead!
func (item *BenchmarksVruPosition) WriteJSONGeneral(w []byte) (_ []byte, err error) {
	return item.WriteJSONOpt(true, false, w), nil
}

func (item *BenchmarksVruPosition) WriteJSON(w []byte) []byte {
	return item.WriteJSONOpt(true, false, w)
}
func (item *BenchmarksVruPosition) WriteJSONOpt(newTypeNames bool, short bool, w []byte) []byte {
	w = append(w, '{')
	backupIndexFieldsMask := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"fields_mask":`...)
	w = basictl.JSONWriteUint32(w, item.FieldsMask)
	if (item.FieldsMask != 0) == false {
		w = w[:backupIndexFieldsMask]
	}
	if item.FieldsMask&(1<<0) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"commit_bit":true`...)
	}
	if item.FieldsMask&(1<<1) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"meta_block":true`...)
	}
	if item.FieldsMask&(1<<3) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"split_payload":true`...)
	}
	if item.FieldsMask&(1<<5) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"rotation_block":true`...)
	}
	if item.FieldsMask&(1<<15) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"canonical_hash":true`...)
	}
	backupIndexPayloadOffset := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"payload_offset":`...)
	w = basictl.JSONWriteInt64(w, item.PayloadOffset)
	if (item.PayloadOffset != 0) == false {
		w = w[:backupIndexPayloadOffset]
	}
	backupIndexBlockTimeNano := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"block_time_nano":`...)
	w = basictl.JSONWriteInt64(w, item.BlockTimeNano)
	if (item.BlockTimeNano != 0) == false {
		w = w[:backupIndexBlockTimeNano]
	}
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"hash":`...)
	w = item.Hash.WriteJSONOpt(newTypeNames, short, w)
	backupIndexFileOffset := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"file_offset":`...)
	w = basictl.JSONWriteInt64(w, item.FileOffset)
	if (item.FileOffset != 0) == false {
		w = w[:backupIndexFileOffset]
	}
	if item.FieldsMask&(1<<14) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"seq_number":`...)
		w = basictl.JSONWriteInt64(w, item.SeqNumber)
	}
	return append(w, '}')
}

func (item *BenchmarksVruPosition) MarshalJSON() ([]byte, error) {
	return item.WriteJSON(nil), nil
}

func (item *BenchmarksVruPosition) UnmarshalJSON(b []byte) error {
	if err := item.ReadJSON(true, &basictl.JsonLexer{Data: b}); err != nil {
		return internal.ErrorInvalidJSON("benchmarks.vruposition", err.Error())
	}
	return nil
}
