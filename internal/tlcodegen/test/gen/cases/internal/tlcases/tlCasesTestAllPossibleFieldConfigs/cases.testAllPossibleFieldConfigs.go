// Copyright 2025 V Kontakte LLC
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Code generated by vktl/cmd/tlgen2; DO NOT EDIT.
package tlCasesTestAllPossibleFieldConfigs

import (
	"github.com/vkcom/tl/internal/tlcodegen/test/gen/cases/internal"
	"github.com/vkcom/tl/internal/tlcodegen/test/gen/cases/internal/tl/tlBuiltinTupleInt"
	"github.com/vkcom/tl/internal/tlcodegen/test/gen/cases/internal/tl/tlTrue"
	"github.com/vkcom/tl/pkg/basictl"
)

var _ = basictl.NatWrite
var _ = internal.ErrorInvalidEnumTag

type CasesTestAllPossibleFieldConfigs struct {
	Local uint32
	F00   int32
	// F01 (TrueType)
	F02 []int32
	F03 []int32
	F10 int32 // Conditional: item.Local.0
	// F11 (TrueType) // Conditional: item.Local.1
	F12 []int32 // Conditional: item.Local.2
	F13 []int32 // Conditional: item.Local.3
	F20 int32   // Conditional: nat_outer.0
	// F21 (TrueType) // Conditional: nat_outer.1
	F22 []int32 // Conditional: nat_outer.2
	F23 []int32 // Conditional: nat_outer.3
}

func (CasesTestAllPossibleFieldConfigs) TLName() string { return "cases.testAllPossibleFieldConfigs" }
func (CasesTestAllPossibleFieldConfigs) TLTag() uint32  { return 0xfb6836d3 }

func (item *CasesTestAllPossibleFieldConfigs) SetF10(v int32) {
	item.F10 = v
	item.Local |= 1 << 0
}
func (item *CasesTestAllPossibleFieldConfigs) ClearF10() {
	item.F10 = 0
	item.Local &^= 1 << 0
}
func (item *CasesTestAllPossibleFieldConfigs) IsSetF10() bool { return item.Local&(1<<0) != 0 }

func (item *CasesTestAllPossibleFieldConfigs) SetF11(v bool) {
	if v {
		item.Local |= 1 << 1
	} else {
		item.Local &^= 1 << 1
	}
}
func (item *CasesTestAllPossibleFieldConfigs) IsSetF11() bool { return item.Local&(1<<1) != 0 }

func (item *CasesTestAllPossibleFieldConfigs) SetF12(v []int32) {
	item.F12 = v
	item.Local |= 1 << 2
}
func (item *CasesTestAllPossibleFieldConfigs) ClearF12() {
	item.F12 = item.F12[:0]
	item.Local &^= 1 << 2
}
func (item *CasesTestAllPossibleFieldConfigs) IsSetF12() bool { return item.Local&(1<<2) != 0 }

func (item *CasesTestAllPossibleFieldConfigs) SetF13(v []int32) {
	item.F13 = v
	item.Local |= 1 << 3
}
func (item *CasesTestAllPossibleFieldConfigs) ClearF13() {
	item.F13 = item.F13[:0]
	item.Local &^= 1 << 3
}
func (item *CasesTestAllPossibleFieldConfigs) IsSetF13() bool { return item.Local&(1<<3) != 0 }

func (item *CasesTestAllPossibleFieldConfigs) SetF20(v int32, nat_outer *uint32) {
	item.F20 = v
	if nat_outer != nil {
		*nat_outer |= 1 << 0
	}
}
func (item *CasesTestAllPossibleFieldConfigs) ClearF20(nat_outer *uint32) {
	item.F20 = 0
	if nat_outer != nil {
		*nat_outer &^= 1 << 0
	}
}
func (item *CasesTestAllPossibleFieldConfigs) IsSetF20(nat_outer uint32) bool {
	return nat_outer&(1<<0) != 0
}

func (item *CasesTestAllPossibleFieldConfigs) SetF21(v bool, nat_outer *uint32) {
	if nat_outer != nil {
		if v {
			*nat_outer |= 1 << 1
		} else {
			*nat_outer &^= 1 << 1
		}
	}
}
func (item *CasesTestAllPossibleFieldConfigs) IsSetF21(nat_outer uint32) bool {
	return nat_outer&(1<<1) != 0
}

func (item *CasesTestAllPossibleFieldConfigs) SetF22(v []int32, nat_outer *uint32) {
	item.F22 = v
	if nat_outer != nil {
		*nat_outer |= 1 << 2
	}
}
func (item *CasesTestAllPossibleFieldConfigs) ClearF22(nat_outer *uint32) {
	item.F22 = item.F22[:0]
	if nat_outer != nil {
		*nat_outer &^= 1 << 2
	}
}
func (item *CasesTestAllPossibleFieldConfigs) IsSetF22(nat_outer uint32) bool {
	return nat_outer&(1<<2) != 0
}

func (item *CasesTestAllPossibleFieldConfigs) SetF23(v []int32, nat_outer *uint32) {
	item.F23 = v
	if nat_outer != nil {
		*nat_outer |= 1 << 3
	}
}
func (item *CasesTestAllPossibleFieldConfigs) ClearF23(nat_outer *uint32) {
	item.F23 = item.F23[:0]
	if nat_outer != nil {
		*nat_outer &^= 1 << 3
	}
}
func (item *CasesTestAllPossibleFieldConfigs) IsSetF23(nat_outer uint32) bool {
	return nat_outer&(1<<3) != 0
}

func (item *CasesTestAllPossibleFieldConfigs) Reset() {
	item.Local = 0
	item.F00 = 0
	item.F02 = item.F02[:0]
	item.F03 = item.F03[:0]
	item.F10 = 0
	item.F12 = item.F12[:0]
	item.F13 = item.F13[:0]
	item.F20 = 0
	item.F22 = item.F22[:0]
	item.F23 = item.F23[:0]
}

func (item *CasesTestAllPossibleFieldConfigs) FillRandom(rg *basictl.RandGenerator, nat_outer uint32) {
	var maskLocal uint32
	maskLocal = basictl.RandomUint(rg)
	maskLocal = rg.LimitValue(maskLocal)
	item.Local = 0
	if maskLocal&(1<<0) != 0 {
		item.Local |= (1 << 0)
	}
	if maskLocal&(1<<1) != 0 {
		item.Local |= (1 << 1)
	}
	if maskLocal&(1<<2) != 0 {
		item.Local |= (1 << 2)
	}
	if maskLocal&(1<<3) != 0 {
		item.Local |= (1 << 3)
	}
	item.F00 = basictl.RandomInt(rg)
	tlBuiltinTupleInt.BuiltinTupleIntFillRandom(rg, &item.F02, item.Local)
	tlBuiltinTupleInt.BuiltinTupleIntFillRandom(rg, &item.F03, nat_outer)
	if item.Local&(1<<0) != 0 {
		item.F10 = basictl.RandomInt(rg)
	} else {
		item.F10 = 0
	}
	if item.Local&(1<<2) != 0 {
		tlBuiltinTupleInt.BuiltinTupleIntFillRandom(rg, &item.F12, item.Local)
	} else {
		item.F12 = item.F12[:0]
	}
	if item.Local&(1<<3) != 0 {
		tlBuiltinTupleInt.BuiltinTupleIntFillRandom(rg, &item.F13, nat_outer)
	} else {
		item.F13 = item.F13[:0]
	}
	if nat_outer&(1<<0) != 0 {
		item.F20 = basictl.RandomInt(rg)
	} else {
		item.F20 = 0
	}
	if nat_outer&(1<<2) != 0 {
		tlBuiltinTupleInt.BuiltinTupleIntFillRandom(rg, &item.F22, item.Local)
	} else {
		item.F22 = item.F22[:0]
	}
	if nat_outer&(1<<3) != 0 {
		tlBuiltinTupleInt.BuiltinTupleIntFillRandom(rg, &item.F23, nat_outer)
	} else {
		item.F23 = item.F23[:0]
	}
}

func (item *CasesTestAllPossibleFieldConfigs) Read(w []byte, nat_outer uint32) (_ []byte, err error) {
	if w, err = basictl.NatRead(w, &item.Local); err != nil {
		return w, err
	}
	if w, err = basictl.IntRead(w, &item.F00); err != nil {
		return w, err
	}
	if w, err = tlBuiltinTupleInt.BuiltinTupleIntRead(w, &item.F02, item.Local); err != nil {
		return w, err
	}
	if w, err = tlBuiltinTupleInt.BuiltinTupleIntRead(w, &item.F03, nat_outer); err != nil {
		return w, err
	}
	if item.Local&(1<<0) != 0 {
		if w, err = basictl.IntRead(w, &item.F10); err != nil {
			return w, err
		}
	} else {
		item.F10 = 0
	}
	if item.Local&(1<<2) != 0 {
		if w, err = tlBuiltinTupleInt.BuiltinTupleIntRead(w, &item.F12, item.Local); err != nil {
			return w, err
		}
	} else {
		item.F12 = item.F12[:0]
	}
	if item.Local&(1<<3) != 0 {
		if w, err = tlBuiltinTupleInt.BuiltinTupleIntRead(w, &item.F13, nat_outer); err != nil {
			return w, err
		}
	} else {
		item.F13 = item.F13[:0]
	}
	if nat_outer&(1<<0) != 0 {
		if w, err = basictl.IntRead(w, &item.F20); err != nil {
			return w, err
		}
	} else {
		item.F20 = 0
	}
	if nat_outer&(1<<2) != 0 {
		if w, err = tlBuiltinTupleInt.BuiltinTupleIntRead(w, &item.F22, item.Local); err != nil {
			return w, err
		}
	} else {
		item.F22 = item.F22[:0]
	}
	if nat_outer&(1<<3) != 0 {
		if w, err = tlBuiltinTupleInt.BuiltinTupleIntRead(w, &item.F23, nat_outer); err != nil {
			return w, err
		}
	} else {
		item.F23 = item.F23[:0]
	}
	return w, nil
}

func (item *CasesTestAllPossibleFieldConfigs) WriteGeneral(w []byte, nat_outer uint32) (_ []byte, err error) {
	return item.Write(w, nat_outer)
}

func (item *CasesTestAllPossibleFieldConfigs) Write(w []byte, nat_outer uint32) (_ []byte, err error) {
	w = basictl.NatWrite(w, item.Local)
	w = basictl.IntWrite(w, item.F00)
	if w, err = tlBuiltinTupleInt.BuiltinTupleIntWrite(w, item.F02, item.Local); err != nil {
		return w, err
	}
	if w, err = tlBuiltinTupleInt.BuiltinTupleIntWrite(w, item.F03, nat_outer); err != nil {
		return w, err
	}
	if item.Local&(1<<0) != 0 {
		w = basictl.IntWrite(w, item.F10)
	}
	if item.Local&(1<<2) != 0 {
		if w, err = tlBuiltinTupleInt.BuiltinTupleIntWrite(w, item.F12, item.Local); err != nil {
			return w, err
		}
	}
	if item.Local&(1<<3) != 0 {
		if w, err = tlBuiltinTupleInt.BuiltinTupleIntWrite(w, item.F13, nat_outer); err != nil {
			return w, err
		}
	}
	if nat_outer&(1<<0) != 0 {
		w = basictl.IntWrite(w, item.F20)
	}
	if nat_outer&(1<<2) != 0 {
		if w, err = tlBuiltinTupleInt.BuiltinTupleIntWrite(w, item.F22, item.Local); err != nil {
			return w, err
		}
	}
	if nat_outer&(1<<3) != 0 {
		if w, err = tlBuiltinTupleInt.BuiltinTupleIntWrite(w, item.F23, nat_outer); err != nil {
			return w, err
		}
	}
	return w, nil
}

func (item *CasesTestAllPossibleFieldConfigs) ReadBoxed(w []byte, nat_outer uint32) (_ []byte, err error) {
	if w, err = basictl.NatReadExactTag(w, 0xfb6836d3); err != nil {
		return w, err
	}
	return item.Read(w, nat_outer)
}

func (item *CasesTestAllPossibleFieldConfigs) WriteBoxedGeneral(w []byte, nat_outer uint32) (_ []byte, err error) {
	return item.WriteBoxed(w, nat_outer)
}

func (item *CasesTestAllPossibleFieldConfigs) WriteBoxed(w []byte, nat_outer uint32) (_ []byte, err error) {
	w = basictl.NatWrite(w, 0xfb6836d3)
	return item.Write(w, nat_outer)
}

func (item *CasesTestAllPossibleFieldConfigs) ReadJSON(legacyTypeNames bool, in *basictl.JsonLexer, nat_outer uint32) error {
	var propLocalPresented bool
	var propF00Presented bool
	var rawF02 []byte
	var rawF03 []byte
	var propF10Presented bool
	var trueTypeF11Presented bool
	var trueTypeF11Value bool
	var rawF12 []byte
	var rawF13 []byte
	var propF20Presented bool
	var rawF22 []byte
	var rawF23 []byte

	if in != nil {
		in.Delim('{')
		if !in.Ok() {
			return in.Error()
		}
		for !in.IsDelim('}') {
			key := in.UnsafeFieldName(true)
			in.WantColon()
			switch key {
			case "local":
				if propLocalPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "local")
				}
				if err := internal.Json2ReadUint32(in, &item.Local); err != nil {
					return err
				}
				propLocalPresented = true
			case "f00":
				if propF00Presented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "f00")
				}
				if err := internal.Json2ReadInt32(in, &item.F00); err != nil {
					return err
				}
				propF00Presented = true
			case "f01":
				var tmpF01 tlTrue.True
				if err := tmpF01.ReadJSON(legacyTypeNames, in); err != nil {
					return err
				}
			case "f02":
				if rawF02 != nil {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "f02")
				}
				rawF02 = in.Raw()
				if !in.Ok() {
					return in.Error()
				}
			case "f03":
				if rawF03 != nil {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "f03")
				}
				rawF03 = in.Raw()
				if !in.Ok() {
					return in.Error()
				}
			case "f10":
				if propF10Presented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "f10")
				}
				if err := internal.Json2ReadInt32(in, &item.F10); err != nil {
					return err
				}
				propF10Presented = true
			case "f11":
				if trueTypeF11Presented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "f11")
				}
				if err := internal.Json2ReadBool(in, &trueTypeF11Value); err != nil {
					return err
				}
				trueTypeF11Presented = true
			case "f12":
				if rawF12 != nil {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "f12")
				}
				rawF12 = in.Raw()
				if !in.Ok() {
					return in.Error()
				}
			case "f13":
				if rawF13 != nil {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "f13")
				}
				rawF13 = in.Raw()
				if !in.Ok() {
					return in.Error()
				}
			case "f20":
				if propF20Presented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "f20")
				}
				if nat_outer&(1<<0) == 0 {
					return internal.ErrorInvalidJSON("cases.testAllPossibleFieldConfigs", "field 'f20' is defined, while corresponding implicit fieldmask bit is 0")
				}
				if err := internal.Json2ReadInt32(in, &item.F20); err != nil {
					return err
				}
				propF20Presented = true
			case "f21":
				return internal.ErrorInvalidJSON("cases.testAllPossibleFieldConfigs", "implicit true field 'f21' cannot be defined, set fieldmask instead")
			case "f22":
				if rawF22 != nil {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "f22")
				}
				rawF22 = in.Raw()
				if !in.Ok() {
					return in.Error()
				}
			case "f23":
				if rawF23 != nil {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "f23")
				}
				rawF23 = in.Raw()
				if !in.Ok() {
					return in.Error()
				}
			default:
				return internal.ErrorInvalidJSONExcessElement("cases.testAllPossibleFieldConfigs", key)
			}
			in.WantComma()
		}
		in.Delim('}')
		if !in.Ok() {
			return in.Error()
		}
	}
	if !propLocalPresented {
		item.Local = 0
	}
	if !propF00Presented {
		item.F00 = 0
	}
	if !propF10Presented {
		item.F10 = 0
	}
	if !propF20Presented {
		item.F20 = 0
	}
	if propF10Presented {
		item.Local |= 1 << 0
	}
	if trueTypeF11Presented {
		if trueTypeF11Value {
			item.Local |= 1 << 1
		}
	}
	if rawF12 != nil {
		item.Local |= 1 << 2
	}
	if rawF13 != nil {
		item.Local |= 1 << 3
	}
	var inF02Pointer *basictl.JsonLexer
	inF02 := basictl.JsonLexer{Data: rawF02}
	if rawF02 != nil {
		inF02Pointer = &inF02
	}
	if err := tlBuiltinTupleInt.BuiltinTupleIntReadJSON(legacyTypeNames, inF02Pointer, &item.F02, item.Local); err != nil {
		return err
	}

	var inF03Pointer *basictl.JsonLexer
	inF03 := basictl.JsonLexer{Data: rawF03}
	if rawF03 != nil {
		inF03Pointer = &inF03
	}
	if err := tlBuiltinTupleInt.BuiltinTupleIntReadJSON(legacyTypeNames, inF03Pointer, &item.F03, nat_outer); err != nil {
		return err
	}

	if item.Local&(1<<2) == 0 {
		item.F12 = item.F12[:0]
	} else {
		var inF12Pointer *basictl.JsonLexer
		inF12 := basictl.JsonLexer{Data: rawF12}
		if rawF12 != nil {
			inF12Pointer = &inF12
		}
		if err := tlBuiltinTupleInt.BuiltinTupleIntReadJSON(legacyTypeNames, inF12Pointer, &item.F12, item.Local); err != nil {
			return err
		}

	}
	if item.Local&(1<<3) == 0 {
		item.F13 = item.F13[:0]
	} else {
		var inF13Pointer *basictl.JsonLexer
		inF13 := basictl.JsonLexer{Data: rawF13}
		if rawF13 != nil {
			inF13Pointer = &inF13
		}
		if err := tlBuiltinTupleInt.BuiltinTupleIntReadJSON(legacyTypeNames, inF13Pointer, &item.F13, nat_outer); err != nil {
			return err
		}

	}
	if nat_outer&(1<<2) == 0 {
		if rawF22 != nil {
			return internal.ErrorInvalidJSON("cases.testAllPossibleFieldConfigs", "field 'f22' is defined, while corresponding implicit fieldmask bit is 0")
		}
		item.F22 = item.F22[:0]
	} else {
		var inF22Pointer *basictl.JsonLexer
		inF22 := basictl.JsonLexer{Data: rawF22}
		if rawF22 != nil {
			inF22Pointer = &inF22
		}
		if err := tlBuiltinTupleInt.BuiltinTupleIntReadJSON(legacyTypeNames, inF22Pointer, &item.F22, item.Local); err != nil {
			return err
		}

	}
	if nat_outer&(1<<3) == 0 {
		if rawF23 != nil {
			return internal.ErrorInvalidJSON("cases.testAllPossibleFieldConfigs", "field 'f23' is defined, while corresponding implicit fieldmask bit is 0")
		}
		item.F23 = item.F23[:0]
	} else {
		var inF23Pointer *basictl.JsonLexer
		inF23 := basictl.JsonLexer{Data: rawF23}
		if rawF23 != nil {
			inF23Pointer = &inF23
		}
		if err := tlBuiltinTupleInt.BuiltinTupleIntReadJSON(legacyTypeNames, inF23Pointer, &item.F23, nat_outer); err != nil {
			return err
		}

	}
	// tries to set bit to zero if it is 1
	if trueTypeF11Presented && !trueTypeF11Value && (item.Local&(1<<1) != 0) {
		return internal.ErrorInvalidJSON("cases.testAllPossibleFieldConfigs", "fieldmask bit local.0 is indefinite because of the contradictions in values")
	}
	return nil
}

// This method is general version of WriteJSON, use it instead!
func (item *CasesTestAllPossibleFieldConfigs) WriteJSONGeneral(tctx *basictl.JSONWriteContext, w []byte, nat_outer uint32) (_ []byte, err error) {
	return item.WriteJSONOpt(tctx, w, nat_outer)
}

func (item *CasesTestAllPossibleFieldConfigs) WriteJSON(w []byte, nat_outer uint32) (_ []byte, err error) {
	tctx := basictl.JSONWriteContext{}
	return item.WriteJSONOpt(&tctx, w, nat_outer)
}
func (item *CasesTestAllPossibleFieldConfigs) WriteJSONOpt(tctx *basictl.JSONWriteContext, w []byte, nat_outer uint32) (_ []byte, err error) {
	w = append(w, '{')
	backupIndexLocal := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"local":`...)
	w = basictl.JSONWriteUint32(w, item.Local)
	if (item.Local != 0) == false {
		w = w[:backupIndexLocal]
	}
	backupIndexF00 := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"f00":`...)
	w = basictl.JSONWriteInt32(w, item.F00)
	if (item.F00 != 0) == false {
		w = w[:backupIndexF00]
	}
	backupIndexF02 := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"f02":`...)
	if w, err = tlBuiltinTupleInt.BuiltinTupleIntWriteJSONOpt(tctx, w, item.F02, item.Local); err != nil {
		return w, err
	}
	if (len(item.F02) != 0) == false {
		w = w[:backupIndexF02]
	}
	backupIndexF03 := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"f03":`...)
	if w, err = tlBuiltinTupleInt.BuiltinTupleIntWriteJSONOpt(tctx, w, item.F03, nat_outer); err != nil {
		return w, err
	}
	if (len(item.F03) != 0) == false {
		w = w[:backupIndexF03]
	}
	if item.Local&(1<<0) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"f10":`...)
		w = basictl.JSONWriteInt32(w, item.F10)
	}
	if item.Local&(1<<1) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"f11":true`...)
	}
	if item.Local&(1<<2) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"f12":`...)
		if w, err = tlBuiltinTupleInt.BuiltinTupleIntWriteJSONOpt(tctx, w, item.F12, item.Local); err != nil {
			return w, err
		}
	}
	if item.Local&(1<<3) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"f13":`...)
		if w, err = tlBuiltinTupleInt.BuiltinTupleIntWriteJSONOpt(tctx, w, item.F13, nat_outer); err != nil {
			return w, err
		}
	}
	if nat_outer&(1<<0) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"f20":`...)
		w = basictl.JSONWriteInt32(w, item.F20)
	}
	if nat_outer&(1<<2) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"f22":`...)
		if w, err = tlBuiltinTupleInt.BuiltinTupleIntWriteJSONOpt(tctx, w, item.F22, item.Local); err != nil {
			return w, err
		}
	}
	if nat_outer&(1<<3) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"f23":`...)
		if w, err = tlBuiltinTupleInt.BuiltinTupleIntWriteJSONOpt(tctx, w, item.F23, nat_outer); err != nil {
			return w, err
		}
	}
	return append(w, '}'), nil
}

func (item *CasesTestAllPossibleFieldConfigs) CalculateLayout(sizes []int, nat_outer uint32) []int {
	sizePosition := len(sizes)
	sizes = append(sizes, 0)

	currentSize := 0
	lastUsedByte := 0

	// calculate layout for item.Local
	if item.Local != 0 {

		lastUsedByte = 1
		currentSize += 4
	}

	// calculate layout for item.F00
	if item.F00 != 0 {

		lastUsedByte = 1
		currentSize += 4
	}

	var trueF01 tlTrue.True
	// calculate layout for trueF01
	currentPosition := len(sizes)
	sizes = trueF01.CalculateLayout(sizes)
	if sizes[currentPosition] != 0 {
		lastUsedByte = 1
		currentSize += sizes[currentPosition]
		currentSize += basictl.TL2CalculateSize(sizes[currentPosition])
	} else {
		sizes = sizes[:currentPosition+1]
	}

	// calculate layout for item.F02
	currentPosition = len(sizes)
	if len(item.F02) != 0 {
		sizes = tlBuiltinTupleInt.BuiltinTupleIntCalculateLayout(sizes, &item.F02, item.Local)
		if sizes[currentPosition] != 0 {
			lastUsedByte = 1
			currentSize += sizes[currentPosition]
			currentSize += basictl.TL2CalculateSize(sizes[currentPosition])
		} else {
			sizes = sizes[:currentPosition+1]
		}
	}

	// calculate layout for item.F03
	currentPosition = len(sizes)
	if len(item.F03) != 0 {
		sizes = tlBuiltinTupleInt.BuiltinTupleIntCalculateLayout(sizes, &item.F03, nat_outer)
		if sizes[currentPosition] != 0 {
			lastUsedByte = 1
			currentSize += sizes[currentPosition]
			currentSize += basictl.TL2CalculateSize(sizes[currentPosition])
		} else {
			sizes = sizes[:currentPosition+1]
		}
	}

	// calculate layout for item.F10
	if item.Local&(1<<0) != 0 {
		if item.F10 != 0 {

			lastUsedByte = 1
			currentSize += 4
		}
	}

	var trueF11 tlTrue.True
	// calculate layout for trueF11
	currentPosition = len(sizes)
	if item.Local&(1<<1) != 0 {
		sizes = trueF11.CalculateLayout(sizes)
		if sizes[currentPosition] != 0 {
			lastUsedByte = 1
			currentSize += sizes[currentPosition]
			currentSize += basictl.TL2CalculateSize(sizes[currentPosition])
		} else {
			sizes = sizes[:currentPosition+1]
		}
	}

	// calculate layout for item.F12
	currentPosition = len(sizes)
	if item.Local&(1<<2) != 0 {
		if len(item.F12) != 0 {
			sizes = tlBuiltinTupleInt.BuiltinTupleIntCalculateLayout(sizes, &item.F12, item.Local)
			if sizes[currentPosition] != 0 {
				lastUsedByte = 2
				currentSize += sizes[currentPosition]
				currentSize += basictl.TL2CalculateSize(sizes[currentPosition])
			} else {
				sizes = sizes[:currentPosition+1]
			}
		}
	}

	// calculate layout for item.F13
	currentPosition = len(sizes)
	if item.Local&(1<<3) != 0 {
		if len(item.F13) != 0 {
			sizes = tlBuiltinTupleInt.BuiltinTupleIntCalculateLayout(sizes, &item.F13, nat_outer)
			if sizes[currentPosition] != 0 {
				lastUsedByte = 2
				currentSize += sizes[currentPosition]
				currentSize += basictl.TL2CalculateSize(sizes[currentPosition])
			} else {
				sizes = sizes[:currentPosition+1]
			}
		}
	}

	// calculate layout for item.F20
	if nat_outer&(1<<0) != 0 {
		if item.F20 != 0 {

			lastUsedByte = 2
			currentSize += 4
		}
	}

	var trueF21 tlTrue.True
	// calculate layout for trueF21
	currentPosition = len(sizes)
	if nat_outer&(1<<1) != 0 {
		sizes = trueF21.CalculateLayout(sizes)
		if sizes[currentPosition] != 0 {
			lastUsedByte = 2
			currentSize += sizes[currentPosition]
			currentSize += basictl.TL2CalculateSize(sizes[currentPosition])
		} else {
			sizes = sizes[:currentPosition+1]
		}
	}

	// calculate layout for item.F22
	currentPosition = len(sizes)
	if nat_outer&(1<<2) != 0 {
		if len(item.F22) != 0 {
			sizes = tlBuiltinTupleInt.BuiltinTupleIntCalculateLayout(sizes, &item.F22, item.Local)
			if sizes[currentPosition] != 0 {
				lastUsedByte = 2
				currentSize += sizes[currentPosition]
				currentSize += basictl.TL2CalculateSize(sizes[currentPosition])
			} else {
				sizes = sizes[:currentPosition+1]
			}
		}
	}

	// calculate layout for item.F23
	currentPosition = len(sizes)
	if nat_outer&(1<<3) != 0 {
		if len(item.F23) != 0 {
			sizes = tlBuiltinTupleInt.BuiltinTupleIntCalculateLayout(sizes, &item.F23, nat_outer)
			if sizes[currentPosition] != 0 {
				lastUsedByte = 2
				currentSize += sizes[currentPosition]
				currentSize += basictl.TL2CalculateSize(sizes[currentPosition])
			} else {
				sizes = sizes[:currentPosition+1]
			}
		}
	}

	// append byte for each section until last mentioned field
	if lastUsedByte != 0 {
		currentSize += lastUsedByte
	} else {
		// remove unused values
		sizes = sizes[:sizePosition+1]
	}
	sizes[sizePosition] = currentSize
	return sizes
}

func (item *CasesTestAllPossibleFieldConfigs) InternalWriteTL2(w []byte, sizes []int, nat_outer uint32) ([]byte, []int) {
	currentSize := sizes[0]
	sizes = sizes[1:]

	serializedSize := 0

	w = basictl.TL2WriteSize(w, currentSize)
	if currentSize == 0 {
		return w, sizes
	}

	var currentBlock byte
	currentBlockPosition := len(w)
	w = append(w, 0)
	serializedSize += 1
	// write item.Local
	if item.Local != 0 {
		serializedSize += 4
		if 4 != 0 {
			currentBlock |= (1 << 1)
			w = basictl.NatWrite(w, item.Local)
		}
	}
	// write item.F00
	if item.F00 != 0 {
		serializedSize += 4
		if 4 != 0 {
			currentBlock |= (1 << 2)
			w = basictl.IntWrite(w, item.F00)
		}
	}
	var trueF01 tlTrue.True
	// write trueF01
	serializedSize += sizes[0]
	if sizes[0] != 0 {
		serializedSize += basictl.TL2CalculateSize(sizes[0])
		currentBlock |= (1 << 3)
		w, sizes = trueF01.InternalWriteTL2(w, sizes)
	} else {
		sizes = sizes[1:]
	}
	// write item.F02
	if len(item.F02) != 0 {
		serializedSize += sizes[0]
		if sizes[0] != 0 {
			serializedSize += basictl.TL2CalculateSize(sizes[0])
			currentBlock |= (1 << 4)
			w, sizes = tlBuiltinTupleInt.BuiltinTupleIntInternalWriteTL2(w, sizes, &item.F02, item.Local)
		} else {
			sizes = sizes[1:]
		}
	}
	// write item.F03
	if len(item.F03) != 0 {
		serializedSize += sizes[0]
		if sizes[0] != 0 {
			serializedSize += basictl.TL2CalculateSize(sizes[0])
			currentBlock |= (1 << 5)
			w, sizes = tlBuiltinTupleInt.BuiltinTupleIntInternalWriteTL2(w, sizes, &item.F03, nat_outer)
		} else {
			sizes = sizes[1:]
		}
	}
	// write item.F10
	if item.Local&(1<<0) != 0 {
		if item.F10 != 0 {
			serializedSize += 4
			if 4 != 0 {
				currentBlock |= (1 << 6)
				w = basictl.IntWrite(w, item.F10)
			}
		}
	}
	var trueF11 tlTrue.True
	// write trueF11
	if item.Local&(1<<1) != 0 {
		serializedSize += sizes[0]
		if sizes[0] != 0 {
			serializedSize += basictl.TL2CalculateSize(sizes[0])
			currentBlock |= (1 << 7)
			w, sizes = trueF11.InternalWriteTL2(w, sizes)
		} else {
			sizes = sizes[1:]
		}
	}

	// add byte for fields with index 8..15
	w[currentBlockPosition] = currentBlock
	currentBlock = 0
	if serializedSize != currentSize {
		currentBlockPosition = len(w)
		w = append(w, 0)
		serializedSize += 1
	} else {
		return w, sizes
	}
	// write item.F12
	if item.Local&(1<<2) != 0 {
		if len(item.F12) != 0 {
			serializedSize += sizes[0]
			if sizes[0] != 0 {
				serializedSize += basictl.TL2CalculateSize(sizes[0])
				currentBlock |= (1 << 0)
				w, sizes = tlBuiltinTupleInt.BuiltinTupleIntInternalWriteTL2(w, sizes, &item.F12, item.Local)
			} else {
				sizes = sizes[1:]
			}
		}
	}
	// write item.F13
	if item.Local&(1<<3) != 0 {
		if len(item.F13) != 0 {
			serializedSize += sizes[0]
			if sizes[0] != 0 {
				serializedSize += basictl.TL2CalculateSize(sizes[0])
				currentBlock |= (1 << 1)
				w, sizes = tlBuiltinTupleInt.BuiltinTupleIntInternalWriteTL2(w, sizes, &item.F13, nat_outer)
			} else {
				sizes = sizes[1:]
			}
		}
	}
	// write item.F20
	if nat_outer&(1<<0) != 0 {
		if item.F20 != 0 {
			serializedSize += 4
			if 4 != 0 {
				currentBlock |= (1 << 2)
				w = basictl.IntWrite(w, item.F20)
			}
		}
	}
	var trueF21 tlTrue.True
	// write trueF21
	if nat_outer&(1<<1) != 0 {
		serializedSize += sizes[0]
		if sizes[0] != 0 {
			serializedSize += basictl.TL2CalculateSize(sizes[0])
			currentBlock |= (1 << 3)
			w, sizes = trueF21.InternalWriteTL2(w, sizes)
		} else {
			sizes = sizes[1:]
		}
	}
	// write item.F22
	if nat_outer&(1<<2) != 0 {
		if len(item.F22) != 0 {
			serializedSize += sizes[0]
			if sizes[0] != 0 {
				serializedSize += basictl.TL2CalculateSize(sizes[0])
				currentBlock |= (1 << 4)
				w, sizes = tlBuiltinTupleInt.BuiltinTupleIntInternalWriteTL2(w, sizes, &item.F22, item.Local)
			} else {
				sizes = sizes[1:]
			}
		}
	}
	// write item.F23
	if nat_outer&(1<<3) != 0 {
		if len(item.F23) != 0 {
			serializedSize += sizes[0]
			if sizes[0] != 0 {
				serializedSize += basictl.TL2CalculateSize(sizes[0])
				currentBlock |= (1 << 5)
				w, sizes = tlBuiltinTupleInt.BuiltinTupleIntInternalWriteTL2(w, sizes, &item.F23, nat_outer)
			} else {
				sizes = sizes[1:]
			}
		}
	}
	w[currentBlockPosition] = currentBlock
	return w, sizes
}

func (item *CasesTestAllPossibleFieldConfigs) WriteTL2(w []byte, ctx *basictl.TL2WriteContext, nat_outer uint32) []byte {
	var sizes []int
	if ctx != nil {
		sizes = ctx.SizeBuffer
	}
	sizes = item.CalculateLayout(sizes[:0], nat_outer)
	w, _ = item.InternalWriteTL2(w, sizes, nat_outer)
	if ctx != nil {
		ctx.SizeBuffer = sizes[:0]
	}
	return w
}

func (item *CasesTestAllPossibleFieldConfigs) InternalReadTL2(r []byte, nat_outer uint32) (_ []byte, err error) {
	currentSize := 0
	if r, currentSize, err = basictl.TL2ParseSize(r); err != nil {
		return r, err
	}
	if len(r) < currentSize {
		return r, basictl.TL2Error("not enough data: expected %d, got %d", currentSize, len(r))
	}

	currentR := r[:currentSize]
	r = r[currentSize:]

	if currentSize == 0 {
		item.Reset()
		return r, nil
	}
	var block byte
	if currentR, err = basictl.ByteReadTL2(currentR, &block); err != nil {
		return currentR, err
	}
	// read No of constructor
	if block&1 != 0 {
		var index int
		if currentR, err = basictl.TL2ReadSize(currentR, &index); err != nil {
			return currentR, err
		}
		if index != 0 {
			// unknown cases for current type
			item.Reset()
			return r, nil
		}
	}

	// read item.Local
	if block&(1<<1) != 0 {
		if currentR, err = basictl.NatRead(currentR, &item.Local); err != nil {
			return currentR, err
		}
	} else {
		item.Local = 0
	}

	// read item.F00
	if block&(1<<2) != 0 {
		if currentR, err = basictl.IntRead(currentR, &item.F00); err != nil {
			return currentR, err
		}
	} else {
		item.F00 = 0
	}

	var trueF01 tlTrue.True
	// read trueF01
	if block&(1<<3) != 0 {
		if currentR, err = trueF01.InternalReadTL2(currentR); err != nil {
			return currentR, err
		}
	} else {
		trueF01.Reset()
	}

	// read item.F02
	if block&(1<<4) != 0 {
		if currentR, err = tlBuiltinTupleInt.BuiltinTupleIntInternalReadTL2(currentR, &item.F02, item.Local); err != nil {
			return currentR, err
		}
	} else {
		item.F02 = item.F02[:0]
	}

	// read item.F03
	if block&(1<<5) != 0 {
		if currentR, err = tlBuiltinTupleInt.BuiltinTupleIntInternalReadTL2(currentR, &item.F03, nat_outer); err != nil {
			return currentR, err
		}
	} else {
		item.F03 = item.F03[:0]
	}

	// read item.F10
	if block&(1<<6) != 0 {
		if item.Local&(1<<0) != 0 {
			if currentR, err = basictl.IntRead(currentR, &item.F10); err != nil {
				return currentR, err
			}
		} else {
			return currentR, basictl.TL2Error("field mask contradiction: field item." + "F10" + "is presented but depending bit is absent")
		}
	} else {
		item.F10 = 0
	}

	var trueF11 tlTrue.True
	// read trueF11
	if block&(1<<7) != 0 {
		if item.Local&(1<<1) != 0 {
			if currentR, err = trueF11.InternalReadTL2(currentR); err != nil {
				return currentR, err
			}
		} else {
			return currentR, basictl.TL2Error("field mask contradiction: field item." + "F11" + "is presented but depending bit is absent")
		}
	} else {
		trueF11.Reset()
	}

	// read next block for fields 8..15
	if len(currentR) > 0 {
		if currentR, err = basictl.ByteReadTL2(currentR, &block); err != nil {
			return currentR, err
		}
	} else {
		block = 0
	}

	// read item.F12
	if block&(1<<0) != 0 {
		if item.Local&(1<<2) != 0 {
			if currentR, err = tlBuiltinTupleInt.BuiltinTupleIntInternalReadTL2(currentR, &item.F12, item.Local); err != nil {
				return currentR, err
			}
		} else {
			return currentR, basictl.TL2Error("field mask contradiction: field item." + "F12" + "is presented but depending bit is absent")
		}
	} else {
		item.F12 = item.F12[:0]
	}

	// read item.F13
	if block&(1<<1) != 0 {
		if item.Local&(1<<3) != 0 {
			if currentR, err = tlBuiltinTupleInt.BuiltinTupleIntInternalReadTL2(currentR, &item.F13, nat_outer); err != nil {
				return currentR, err
			}
		} else {
			return currentR, basictl.TL2Error("field mask contradiction: field item." + "F13" + "is presented but depending bit is absent")
		}
	} else {
		item.F13 = item.F13[:0]
	}

	// read item.F20
	if block&(1<<2) != 0 {
		if nat_outer&(1<<0) != 0 {
			if currentR, err = basictl.IntRead(currentR, &item.F20); err != nil {
				return currentR, err
			}
		} else {
			return currentR, basictl.TL2Error("field mask contradiction: field item." + "F20" + "is presented but depending bit is absent")
		}
	} else {
		item.F20 = 0
	}

	var trueF21 tlTrue.True
	// read trueF21
	if block&(1<<3) != 0 {
		if nat_outer&(1<<1) != 0 {
			if currentR, err = trueF21.InternalReadTL2(currentR); err != nil {
				return currentR, err
			}
		} else {
			return currentR, basictl.TL2Error("field mask contradiction: field item." + "F21" + "is presented but depending bit is absent")
		}
	} else {
		trueF21.Reset()
	}

	// read item.F22
	if block&(1<<4) != 0 {
		if nat_outer&(1<<2) != 0 {
			if currentR, err = tlBuiltinTupleInt.BuiltinTupleIntInternalReadTL2(currentR, &item.F22, item.Local); err != nil {
				return currentR, err
			}
		} else {
			return currentR, basictl.TL2Error("field mask contradiction: field item." + "F22" + "is presented but depending bit is absent")
		}
	} else {
		item.F22 = item.F22[:0]
	}

	// read item.F23
	if block&(1<<5) != 0 {
		if nat_outer&(1<<3) != 0 {
			if currentR, err = tlBuiltinTupleInt.BuiltinTupleIntInternalReadTL2(currentR, &item.F23, nat_outer); err != nil {
				return currentR, err
			}
		} else {
			return currentR, basictl.TL2Error("field mask contradiction: field item." + "F23" + "is presented but depending bit is absent")
		}
	} else {
		item.F23 = item.F23[:0]
	}

	return r, nil
}

func (item *CasesTestAllPossibleFieldConfigs) ReadTL2(r []byte, ctx *basictl.TL2ReadContext, nat_outer uint32) (_ []byte, err error) {
	return item.InternalReadTL2(r, nat_outer)
}
