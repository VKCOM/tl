// Copyright 2025 V Kontakte LLC
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Code generated by vktl/cmd/tlgen2; DO NOT EDIT.
package tlCasesTestAllPossibleFieldConfigs

import (
	"github.com/vkcom/tl/internal/tlcodegen/test/gen/cases/internal"
	"github.com/vkcom/tl/internal/tlcodegen/test/gen/cases/internal/tl/tlBuiltinTupleInt"
	"github.com/vkcom/tl/internal/tlcodegen/test/gen/cases/internal/tl/tlTrue"
	"github.com/vkcom/tl/pkg/basictl"
)

var _ = basictl.NatWrite
var _ = internal.ErrorInvalidEnumTag

type CasesTestAllPossibleFieldConfigs struct {
	Local uint32
	F00   int32
	F01   tlTrue.True
	F02   []int32
	F03   []int32
	F10   int32 // Conditional: item.Local.0
	// F11 (TrueType) // Conditional: item.Local.1
	F12 []int32 // Conditional: item.Local.2
	F13 []int32 // Conditional: item.Local.3
	F20 int32   // Conditional: nat_outer.0
	// F21 (TrueType) // Conditional: nat_outer.1
	F22      []int32 // Conditional: nat_outer.2
	F23      []int32 // Conditional: nat_outer.3
	tl2mask0 byte
}

func (CasesTestAllPossibleFieldConfigs) TLName() string { return "cases.testAllPossibleFieldConfigs" }
func (CasesTestAllPossibleFieldConfigs) TLTag() uint32  { return 0xfb6836d3 }

func (item *CasesTestAllPossibleFieldConfigs) SetF10(v int32) {
	item.F10 = v
	item.Local |= 1 << 0
	item.tl2mask0 |= 1
}
func (item *CasesTestAllPossibleFieldConfigs) ClearF10() {
	item.F10 = 0
	item.Local &^= 1 << 0
	item.tl2mask0 &^= 1
}
func (item *CasesTestAllPossibleFieldConfigs) IsSetF10() bool { return item.tl2mask0&1 != 0 }

func (item *CasesTestAllPossibleFieldConfigs) SetF11(v bool) {
	if v {
		item.Local |= 1 << 1
	} else {
		item.Local &^= 1 << 1
	}
	if v {
		item.tl2mask0 |= 2
	} else {
		item.tl2mask0 &^= 2
	}
}
func (item *CasesTestAllPossibleFieldConfigs) IsSetF11() bool { return item.tl2mask0&2 != 0 }

func (item *CasesTestAllPossibleFieldConfigs) SetF12(v []int32) {
	item.F12 = v
	item.Local |= 1 << 2
	item.tl2mask0 |= 4
}
func (item *CasesTestAllPossibleFieldConfigs) ClearF12() {
	item.F12 = item.F12[:0]
	item.Local &^= 1 << 2
	item.tl2mask0 &^= 4
}
func (item *CasesTestAllPossibleFieldConfigs) IsSetF12() bool { return item.tl2mask0&4 != 0 }

func (item *CasesTestAllPossibleFieldConfigs) SetF13(v []int32) {
	item.F13 = v
	item.Local |= 1 << 3
	item.tl2mask0 |= 8
}
func (item *CasesTestAllPossibleFieldConfigs) ClearF13() {
	item.F13 = item.F13[:0]
	item.Local &^= 1 << 3
	item.tl2mask0 &^= 8
}
func (item *CasesTestAllPossibleFieldConfigs) IsSetF13() bool { return item.tl2mask0&8 != 0 }

func (item *CasesTestAllPossibleFieldConfigs) SetF20(v int32, nat_outer *uint32) {
	item.F20 = v
	if nat_outer != nil {
		*nat_outer |= 1 << 0
	}
	item.tl2mask0 |= 16
}
func (item *CasesTestAllPossibleFieldConfigs) ClearF20(nat_outer *uint32) {
	item.F20 = 0
	if nat_outer != nil {
		*nat_outer &^= 1 << 0
	}
	item.tl2mask0 &^= 16
}
func (item *CasesTestAllPossibleFieldConfigs) IsSetF20() bool { return item.tl2mask0&16 != 0 }

func (item *CasesTestAllPossibleFieldConfigs) SetF21(v bool, nat_outer *uint32) {
	if nat_outer != nil {
		if v {
			*nat_outer |= 1 << 1
		} else {
			*nat_outer &^= 1 << 1
		}
	}
	if v {
		item.tl2mask0 |= 32
	} else {
		item.tl2mask0 &^= 32
	}
}
func (item *CasesTestAllPossibleFieldConfigs) IsSetF21() bool { return item.tl2mask0&32 != 0 }

func (item *CasesTestAllPossibleFieldConfigs) SetF22(v []int32, nat_outer *uint32) {
	item.F22 = v
	if nat_outer != nil {
		*nat_outer |= 1 << 2
	}
	item.tl2mask0 |= 64
}
func (item *CasesTestAllPossibleFieldConfigs) ClearF22(nat_outer *uint32) {
	item.F22 = item.F22[:0]
	if nat_outer != nil {
		*nat_outer &^= 1 << 2
	}
	item.tl2mask0 &^= 64
}
func (item *CasesTestAllPossibleFieldConfigs) IsSetF22() bool { return item.tl2mask0&64 != 0 }

func (item *CasesTestAllPossibleFieldConfigs) SetF23(v []int32, nat_outer *uint32) {
	item.F23 = v
	if nat_outer != nil {
		*nat_outer |= 1 << 3
	}
	item.tl2mask0 |= 128
}
func (item *CasesTestAllPossibleFieldConfigs) ClearF23(nat_outer *uint32) {
	item.F23 = item.F23[:0]
	if nat_outer != nil {
		*nat_outer &^= 1 << 3
	}
	item.tl2mask0 &^= 128
}
func (item *CasesTestAllPossibleFieldConfigs) IsSetF23() bool { return item.tl2mask0&128 != 0 }

func (item *CasesTestAllPossibleFieldConfigs) Reset() {
	item.Local = 0
	item.F00 = 0
	item.F02 = item.F02[:0]
	item.F03 = item.F03[:0]
	item.F10 = 0
	item.F12 = item.F12[:0]
	item.F13 = item.F13[:0]
	item.F20 = 0
	item.F22 = item.F22[:0]
	item.F23 = item.F23[:0]
	item.tl2mask0 = 0
}

func (item *CasesTestAllPossibleFieldConfigs) FillRandom(rg *basictl.RandGenerator, nat_outer uint32) {
	item.tl2mask0 = 0
	item.Local = basictl.RandomFieldMask(rg, 0b1111)
	item.Local = rg.LimitValue(item.Local)
	item.F00 = basictl.RandomInt(rg)
	item.F01.FillRandom(rg)
	tlBuiltinTupleInt.BuiltinTupleIntFillRandom(rg, &item.F02, item.Local)
	tlBuiltinTupleInt.BuiltinTupleIntFillRandom(rg, &item.F03, nat_outer)
	if item.Local&(1<<0) != 0 {
		item.tl2mask0 |= 1
		item.F10 = basictl.RandomInt(rg)
	} else {
		item.F10 = 0
	}
	if item.Local&(1<<1) != 0 {
		item.tl2mask0 |= 2
	}
	if item.Local&(1<<2) != 0 {
		item.tl2mask0 |= 4
		tlBuiltinTupleInt.BuiltinTupleIntFillRandom(rg, &item.F12, item.Local)
	} else {
		item.F12 = item.F12[:0]
	}
	if item.Local&(1<<3) != 0 {
		item.tl2mask0 |= 8
		tlBuiltinTupleInt.BuiltinTupleIntFillRandom(rg, &item.F13, nat_outer)
	} else {
		item.F13 = item.F13[:0]
	}
	if nat_outer&(1<<0) != 0 {
		item.tl2mask0 |= 16
		item.F20 = basictl.RandomInt(rg)
	} else {
		item.F20 = 0
	}
	if nat_outer&(1<<1) != 0 {
		item.tl2mask0 |= 32
	}
	if nat_outer&(1<<2) != 0 {
		item.tl2mask0 |= 64
		tlBuiltinTupleInt.BuiltinTupleIntFillRandom(rg, &item.F22, item.Local)
	} else {
		item.F22 = item.F22[:0]
	}
	if nat_outer&(1<<3) != 0 {
		item.tl2mask0 |= 128
		tlBuiltinTupleInt.BuiltinTupleIntFillRandom(rg, &item.F23, nat_outer)
	} else {
		item.F23 = item.F23[:0]
	}
}

func (item *CasesTestAllPossibleFieldConfigs) Read(w []byte, nat_outer uint32) (_ []byte, err error) {
	item.tl2mask0 = 0
	if w, err = basictl.NatRead(w, &item.Local); err != nil {
		return w, err
	}
	if w, err = basictl.IntRead(w, &item.F00); err != nil {
		return w, err
	}
	if w, err = item.F01.Read(w); err != nil {
		return w, err
	}
	if w, err = tlBuiltinTupleInt.BuiltinTupleIntRead(w, &item.F02, item.Local); err != nil {
		return w, err
	}
	if w, err = tlBuiltinTupleInt.BuiltinTupleIntRead(w, &item.F03, nat_outer); err != nil {
		return w, err
	}
	if item.Local&(1<<0) != 0 {
		item.tl2mask0 |= 1
		if w, err = basictl.IntRead(w, &item.F10); err != nil {
			return w, err
		}
	} else {
		item.F10 = 0
	}
	if item.Local&(1<<1) != 0 {
		item.tl2mask0 |= 2
	}
	if item.Local&(1<<2) != 0 {
		item.tl2mask0 |= 4
		if w, err = tlBuiltinTupleInt.BuiltinTupleIntRead(w, &item.F12, item.Local); err != nil {
			return w, err
		}
	} else {
		item.F12 = item.F12[:0]
	}
	if item.Local&(1<<3) != 0 {
		item.tl2mask0 |= 8
		if w, err = tlBuiltinTupleInt.BuiltinTupleIntRead(w, &item.F13, nat_outer); err != nil {
			return w, err
		}
	} else {
		item.F13 = item.F13[:0]
	}
	if nat_outer&(1<<0) != 0 {
		item.tl2mask0 |= 16
		if w, err = basictl.IntRead(w, &item.F20); err != nil {
			return w, err
		}
	} else {
		item.F20 = 0
	}
	if nat_outer&(1<<1) != 0 {
		item.tl2mask0 |= 32
	}
	if nat_outer&(1<<2) != 0 {
		item.tl2mask0 |= 64
		if w, err = tlBuiltinTupleInt.BuiltinTupleIntRead(w, &item.F22, item.Local); err != nil {
			return w, err
		}
	} else {
		item.F22 = item.F22[:0]
	}
	if nat_outer&(1<<3) != 0 {
		item.tl2mask0 |= 128
		if w, err = tlBuiltinTupleInt.BuiltinTupleIntRead(w, &item.F23, nat_outer); err != nil {
			return w, err
		}
	} else {
		item.F23 = item.F23[:0]
	}
	return w, nil
}

func (item *CasesTestAllPossibleFieldConfigs) WriteGeneral(w []byte, nat_outer uint32) (_ []byte, err error) {
	return item.Write(w, nat_outer)
}

func (item *CasesTestAllPossibleFieldConfigs) Write(w []byte, nat_outer uint32) (_ []byte, err error) {
	w = basictl.NatWrite(w, item.Local)
	w = basictl.IntWrite(w, item.F00)
	w = item.F01.Write(w)
	if w, err = tlBuiltinTupleInt.BuiltinTupleIntWrite(w, item.F02, item.Local); err != nil {
		return w, err
	}
	if w, err = tlBuiltinTupleInt.BuiltinTupleIntWrite(w, item.F03, nat_outer); err != nil {
		return w, err
	}
	if item.Local&(1<<0) != 0 {
		w = basictl.IntWrite(w, item.F10)
	}
	if item.Local&(1<<2) != 0 {
		if w, err = tlBuiltinTupleInt.BuiltinTupleIntWrite(w, item.F12, item.Local); err != nil {
			return w, err
		}
	}
	if item.Local&(1<<3) != 0 {
		if w, err = tlBuiltinTupleInt.BuiltinTupleIntWrite(w, item.F13, nat_outer); err != nil {
			return w, err
		}
	}
	if nat_outer&(1<<0) != 0 {
		w = basictl.IntWrite(w, item.F20)
	}
	if nat_outer&(1<<2) != 0 {
		if w, err = tlBuiltinTupleInt.BuiltinTupleIntWrite(w, item.F22, item.Local); err != nil {
			return w, err
		}
	}
	if nat_outer&(1<<3) != 0 {
		if w, err = tlBuiltinTupleInt.BuiltinTupleIntWrite(w, item.F23, nat_outer); err != nil {
			return w, err
		}
	}
	return w, nil
}

func (item *CasesTestAllPossibleFieldConfigs) ReadBoxed(w []byte, nat_outer uint32) (_ []byte, err error) {
	if w, err = basictl.NatReadExactTag(w, 0xfb6836d3); err != nil {
		return w, err
	}
	return item.Read(w, nat_outer)
}

func (item *CasesTestAllPossibleFieldConfigs) WriteBoxedGeneral(w []byte, nat_outer uint32) (_ []byte, err error) {
	return item.WriteBoxed(w, nat_outer)
}

func (item *CasesTestAllPossibleFieldConfigs) WriteBoxed(w []byte, nat_outer uint32) (_ []byte, err error) {
	w = basictl.NatWrite(w, 0xfb6836d3)
	return item.Write(w, nat_outer)
}

func (item *CasesTestAllPossibleFieldConfigs) ReadJSONGeneral(tctx *basictl.JSONReadContext, in *basictl.JsonLexer, nat_outer uint32) error {
	var propLocalPresented bool
	var propF00Presented bool
	var propF01Presented bool
	var rawF02 []byte
	var rawF03 []byte
	var propF10Presented bool
	var trueTypeF11Presented bool
	var trueTypeF11Value bool
	var rawF12 []byte
	var rawF13 []byte
	var propF20Presented bool
	var rawF22 []byte
	var rawF23 []byte

	if in != nil {
		in.Delim('{')
		if !in.Ok() {
			return in.Error()
		}
		for !in.IsDelim('}') {
			key := in.UnsafeFieldName(true)
			in.WantColon()
			switch key {
			case "local":
				if propLocalPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "local")
				}
				if err := internal.Json2ReadUint32(in, &item.Local); err != nil {
					return err
				}
				propLocalPresented = true
			case "f00":
				if propF00Presented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "f00")
				}
				if err := internal.Json2ReadInt32(in, &item.F00); err != nil {
					return err
				}
				propF00Presented = true
			case "f01":
				if propF01Presented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "f01")
				}
				if err := item.F01.ReadJSONGeneral(tctx, in); err != nil {
					return err
				}
				propF01Presented = true
			case "f02":
				if rawF02 != nil {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "f02")
				}
				rawF02 = in.Raw()
				if !in.Ok() {
					return in.Error()
				}
			case "f03":
				if rawF03 != nil {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "f03")
				}
				rawF03 = in.Raw()
				if !in.Ok() {
					return in.Error()
				}
			case "f10":
				if propF10Presented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "f10")
				}
				if err := internal.Json2ReadInt32(in, &item.F10); err != nil {
					return err
				}
				propF10Presented = true
			case "f11":
				if trueTypeF11Presented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "f11")
				}
				if err := internal.Json2ReadBool(in, &trueTypeF11Value); err != nil {
					return err
				}
				trueTypeF11Presented = true
			case "f12":
				if rawF12 != nil {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "f12")
				}
				rawF12 = in.Raw()
				if !in.Ok() {
					return in.Error()
				}
			case "f13":
				if rawF13 != nil {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "f13")
				}
				rawF13 = in.Raw()
				if !in.Ok() {
					return in.Error()
				}
			case "f20":
				if propF20Presented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "f20")
				}
				if nat_outer&(1<<0) == 0 {
					return internal.ErrorInvalidJSON("cases.testAllPossibleFieldConfigs", "field 'f20' is defined, while corresponding implicit fieldmask bit is 0")
				}
				if err := internal.Json2ReadInt32(in, &item.F20); err != nil {
					return err
				}
				propF20Presented = true
			case "f21":
				return internal.ErrorInvalidJSON("cases.testAllPossibleFieldConfigs", "implicit true field 'f21' cannot be defined, set fieldmask instead")
			case "f22":
				if rawF22 != nil {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "f22")
				}
				rawF22 = in.Raw()
				if !in.Ok() {
					return in.Error()
				}
			case "f23":
				if rawF23 != nil {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("cases.testAllPossibleFieldConfigs", "f23")
				}
				rawF23 = in.Raw()
				if !in.Ok() {
					return in.Error()
				}
			default:
				return internal.ErrorInvalidJSONExcessElement("cases.testAllPossibleFieldConfigs", key)
			}
			in.WantComma()
		}
		in.Delim('}')
		if !in.Ok() {
			return in.Error()
		}
	}
	if !propLocalPresented {
		item.Local = 0
	}
	if !propF00Presented {
		item.F00 = 0
	}
	if !propF01Presented {
		item.F01.Reset()
	}
	if !propF10Presented {
		item.F10 = 0
	}
	if !propF20Presented {
		item.F20 = 0
	}
	if propF10Presented {
		item.Local |= 1 << 0
	}
	if trueTypeF11Presented {
		if trueTypeF11Value {
			item.Local |= 1 << 1
		}
	}
	if rawF12 != nil {
		item.Local |= 1 << 2
	}
	if rawF13 != nil {
		item.Local |= 1 << 3
	}
	var inF02Pointer *basictl.JsonLexer
	inF02 := basictl.JsonLexer{Data: rawF02}
	if rawF02 != nil {
		inF02Pointer = &inF02
	}
	if err := tlBuiltinTupleInt.BuiltinTupleIntReadJSONGeneral(tctx, inF02Pointer, &item.F02, item.Local); err != nil {
		return err
	}

	var inF03Pointer *basictl.JsonLexer
	inF03 := basictl.JsonLexer{Data: rawF03}
	if rawF03 != nil {
		inF03Pointer = &inF03
	}
	if err := tlBuiltinTupleInt.BuiltinTupleIntReadJSONGeneral(tctx, inF03Pointer, &item.F03, nat_outer); err != nil {
		return err
	}

	if item.Local&(1<<2) == 0 {
		item.F12 = item.F12[:0]
	} else {
		var inF12Pointer *basictl.JsonLexer
		inF12 := basictl.JsonLexer{Data: rawF12}
		if rawF12 != nil {
			inF12Pointer = &inF12
		}
		if err := tlBuiltinTupleInt.BuiltinTupleIntReadJSONGeneral(tctx, inF12Pointer, &item.F12, item.Local); err != nil {
			return err
		}

	}
	if item.Local&(1<<3) == 0 {
		item.F13 = item.F13[:0]
	} else {
		var inF13Pointer *basictl.JsonLexer
		inF13 := basictl.JsonLexer{Data: rawF13}
		if rawF13 != nil {
			inF13Pointer = &inF13
		}
		if err := tlBuiltinTupleInt.BuiltinTupleIntReadJSONGeneral(tctx, inF13Pointer, &item.F13, nat_outer); err != nil {
			return err
		}

	}
	if nat_outer&(1<<2) == 0 {
		if rawF22 != nil {
			return internal.ErrorInvalidJSON("cases.testAllPossibleFieldConfigs", "field 'f22' is defined, while corresponding implicit fieldmask bit is 0")
		}
		item.F22 = item.F22[:0]
	} else {
		var inF22Pointer *basictl.JsonLexer
		inF22 := basictl.JsonLexer{Data: rawF22}
		if rawF22 != nil {
			inF22Pointer = &inF22
		}
		if err := tlBuiltinTupleInt.BuiltinTupleIntReadJSONGeneral(tctx, inF22Pointer, &item.F22, item.Local); err != nil {
			return err
		}

	}
	if nat_outer&(1<<3) == 0 {
		if rawF23 != nil {
			return internal.ErrorInvalidJSON("cases.testAllPossibleFieldConfigs", "field 'f23' is defined, while corresponding implicit fieldmask bit is 0")
		}
		item.F23 = item.F23[:0]
	} else {
		var inF23Pointer *basictl.JsonLexer
		inF23 := basictl.JsonLexer{Data: rawF23}
		if rawF23 != nil {
			inF23Pointer = &inF23
		}
		if err := tlBuiltinTupleInt.BuiltinTupleIntReadJSONGeneral(tctx, inF23Pointer, &item.F23, nat_outer); err != nil {
			return err
		}

	}
	// tries to set bit to zero if it is 1
	if trueTypeF11Presented && !trueTypeF11Value && (item.Local&(1<<1) != 0) {
		return internal.ErrorInvalidJSON("cases.testAllPossibleFieldConfigs", "fieldmask bit item.Local.1 is indefinite because of the contradictions in values")
	}
	if item.Local&(1<<0) != 0 {
		item.tl2mask0 |= 1
	}
	if item.Local&(1<<1) != 0 {
		item.tl2mask0 |= 2
	}
	if item.Local&(1<<2) != 0 {
		item.tl2mask0 |= 4
	}
	if item.Local&(1<<3) != 0 {
		item.tl2mask0 |= 8
	}
	if nat_outer&(1<<0) != 0 {
		item.tl2mask0 |= 16
	}
	if nat_outer&(1<<1) != 0 {
		item.tl2mask0 |= 32
	}
	if nat_outer&(1<<2) != 0 {
		item.tl2mask0 |= 64
	}
	if nat_outer&(1<<3) != 0 {
		item.tl2mask0 |= 128
	}
	return nil
}

// This method is general version of WriteJSON, use it instead!
func (item *CasesTestAllPossibleFieldConfigs) WriteJSONGeneral(tctx *basictl.JSONWriteContext, w []byte, nat_outer uint32) (_ []byte, err error) {
	return item.WriteJSONOpt(tctx, w, nat_outer)
}

func (item *CasesTestAllPossibleFieldConfigs) WriteJSON(w []byte, nat_outer uint32) (_ []byte, err error) {
	tctx := basictl.JSONWriteContext{}
	return item.WriteJSONOpt(&tctx, w, nat_outer)
}
func (item *CasesTestAllPossibleFieldConfigs) WriteJSONOpt(tctx *basictl.JSONWriteContext, w []byte, nat_outer uint32) (_ []byte, err error) {
	w = append(w, '{')
	backupIndexLocal := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"local":`...)
	w = basictl.JSONWriteUint32(w, item.Local)
	if (item.Local != 0) == false {
		w = w[:backupIndexLocal]
	}
	backupIndexF00 := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"f00":`...)
	w = basictl.JSONWriteInt32(w, item.F00)
	if (item.F00 != 0) == false {
		w = w[:backupIndexF00]
	}
	backupIndexF02 := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"f02":`...)
	if w, err = tlBuiltinTupleInt.BuiltinTupleIntWriteJSONOpt(tctx, w, item.F02, item.Local); err != nil {
		return w, err
	}
	if (len(item.F02) != 0) == false {
		w = w[:backupIndexF02]
	}
	backupIndexF03 := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"f03":`...)
	if w, err = tlBuiltinTupleInt.BuiltinTupleIntWriteJSONOpt(tctx, w, item.F03, nat_outer); err != nil {
		return w, err
	}
	if (len(item.F03) != 0) == false {
		w = w[:backupIndexF03]
	}
	if item.Local&(1<<0) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"f10":`...)
		w = basictl.JSONWriteInt32(w, item.F10)
	}
	if item.Local&(1<<1) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"f11":true`...)
	}
	if item.Local&(1<<2) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"f12":`...)
		if w, err = tlBuiltinTupleInt.BuiltinTupleIntWriteJSONOpt(tctx, w, item.F12, item.Local); err != nil {
			return w, err
		}
	}
	if item.Local&(1<<3) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"f13":`...)
		if w, err = tlBuiltinTupleInt.BuiltinTupleIntWriteJSONOpt(tctx, w, item.F13, nat_outer); err != nil {
			return w, err
		}
	}
	if nat_outer&(1<<0) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"f20":`...)
		w = basictl.JSONWriteInt32(w, item.F20)
	}
	if nat_outer&(1<<2) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"f22":`...)
		if w, err = tlBuiltinTupleInt.BuiltinTupleIntWriteJSONOpt(tctx, w, item.F22, item.Local); err != nil {
			return w, err
		}
	}
	if nat_outer&(1<<3) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"f23":`...)
		if w, err = tlBuiltinTupleInt.BuiltinTupleIntWriteJSONOpt(tctx, w, item.F23, nat_outer); err != nil {
			return w, err
		}
	}
	return append(w, '}'), nil
}

func (item *CasesTestAllPossibleFieldConfigs) CalculateLayout(sizes []int, optimizeEmpty bool) ([]int, int) {
	sizes = append(sizes, 4217910995)
	sizePosition := len(sizes)
	sizes = append(sizes, 0)

	currentSize := 1
	lastUsedByte := 0
	var sz int

	if item.Local != 0 {
		currentSize += 4
		lastUsedByte = currentSize
	}
	if item.F00 != 0 {
		currentSize += 4
		lastUsedByte = currentSize
	}
	if false {
		lastUsedByte = currentSize
	}
	if sizes, sz = tlBuiltinTupleInt.BuiltinTupleIntCalculateLayout(sizes, true, &item.F02); sz != 0 {
		currentSize += sz
		lastUsedByte = currentSize
	}
	if sizes, sz = tlBuiltinTupleInt.BuiltinTupleIntCalculateLayout(sizes, true, &item.F03); sz != 0 {
		currentSize += sz
		lastUsedByte = currentSize
	}
	if item.tl2mask0&1 != 0 {
		currentSize += 4
		lastUsedByte = currentSize
	}
	if item.tl2mask0&2 != 0 {
		lastUsedByte = currentSize
	}
	currentSize++
	if item.tl2mask0&4 != 0 {
		sizes, sz = tlBuiltinTupleInt.BuiltinTupleIntCalculateLayout(sizes, false, &item.F12)
		currentSize += sz
		lastUsedByte = currentSize
	}
	if item.tl2mask0&8 != 0 {
		sizes, sz = tlBuiltinTupleInt.BuiltinTupleIntCalculateLayout(sizes, false, &item.F13)
		currentSize += sz
		lastUsedByte = currentSize
	}
	if item.tl2mask0&16 != 0 {
		currentSize += 4
		lastUsedByte = currentSize
	}
	if item.tl2mask0&32 != 0 {
		lastUsedByte = currentSize
	}
	if item.tl2mask0&64 != 0 {
		sizes, sz = tlBuiltinTupleInt.BuiltinTupleIntCalculateLayout(sizes, false, &item.F22)
		currentSize += sz
		lastUsedByte = currentSize
	}
	if item.tl2mask0&128 != 0 {
		sizes, sz = tlBuiltinTupleInt.BuiltinTupleIntCalculateLayout(sizes, false, &item.F23)
		currentSize += sz
		lastUsedByte = currentSize
	}

	if lastUsedByte < currentSize {
		currentSize = lastUsedByte
	}
	sizes[sizePosition] = currentSize
	if currentSize == 0 {
		sizes = sizes[:sizePosition+1]
	}
	if !optimizeEmpty || currentSize != 0 {
		currentSize += basictl.TL2CalculateSize(currentSize)
	}
	internal.Unused(sz)
	return sizes, currentSize
}

func (item *CasesTestAllPossibleFieldConfigs) InternalWriteTL2(w []byte, sizes []int, optimizeEmpty bool) ([]byte, []int, int) {
	if sizes[0] != 4217910995 {
		panic("tl2: tag mismatch between calculate and write")
	}
	currentSize := sizes[1]
	sizes = sizes[2:]
	if optimizeEmpty && currentSize == 0 {
		return w, sizes, 0
	}
	w = basictl.TL2WriteSize(w, currentSize)
	if currentSize == 0 {
		return w, sizes, 1
	}
	oldLen := len(w)
	var sz int
	var currentBlock byte
	currentBlockPosition := len(w)
	w = append(w, 0)
	if item.Local != 0 {
		w = basictl.NatWrite(w, item.Local)
		currentBlock |= 2
	}
	if item.F00 != 0 {
		w = basictl.IntWrite(w, item.F00)
		currentBlock |= 4
	}
	if false {
		currentBlock |= 8
	}
	if w, sizes, sz = tlBuiltinTupleInt.BuiltinTupleIntInternalWriteTL2(w, sizes, true, &item.F02); sz != 0 {
		currentBlock |= 16
	}
	if w, sizes, sz = tlBuiltinTupleInt.BuiltinTupleIntInternalWriteTL2(w, sizes, true, &item.F03); sz != 0 {
		currentBlock |= 32
	}
	if item.tl2mask0&1 != 0 {
		w = basictl.IntWrite(w, item.F10)
		currentBlock |= 64
	}
	if item.tl2mask0&2 != 0 {
		currentBlock |= 128
	}
	if currentBlockPosition < len(w) {
		w[currentBlockPosition] = currentBlock
	}
	currentBlock = 0
	// start the next block
	currentBlockPosition = len(w)
	if len(w)-oldLen < currentSize {
		w = append(w, 0)
	}
	if item.tl2mask0&4 != 0 {
		w, sizes, _ = tlBuiltinTupleInt.BuiltinTupleIntInternalWriteTL2(w, sizes, false, &item.F12)
		currentBlock |= 1
	}
	if item.tl2mask0&8 != 0 {
		w, sizes, _ = tlBuiltinTupleInt.BuiltinTupleIntInternalWriteTL2(w, sizes, false, &item.F13)
		currentBlock |= 2
	}
	if item.tl2mask0&16 != 0 {
		w = basictl.IntWrite(w, item.F20)
		currentBlock |= 4
	}
	if item.tl2mask0&32 != 0 {
		currentBlock |= 8
	}
	if item.tl2mask0&64 != 0 {
		w, sizes, _ = tlBuiltinTupleInt.BuiltinTupleIntInternalWriteTL2(w, sizes, false, &item.F22)
		currentBlock |= 16
	}
	if item.tl2mask0&128 != 0 {
		w, sizes, _ = tlBuiltinTupleInt.BuiltinTupleIntInternalWriteTL2(w, sizes, false, &item.F23)
		currentBlock |= 32
	}
	if currentBlockPosition < len(w) {
		w[currentBlockPosition] = currentBlock
	}
	if len(w)-oldLen != currentSize {
		panic("tl2: mismatch between calculate and write")
	}
	internal.Unused(sz)
	return w, sizes, 1
}

func (item *CasesTestAllPossibleFieldConfigs) WriteTL2(w []byte, ctx *basictl.TL2WriteContext) []byte {
	var sizes, sizes2 []int
	if ctx != nil {
		sizes = ctx.SizeBuffer[:0]
	}
	sizes, _ = item.CalculateLayout(sizes, false)
	w, sizes2, _ = item.InternalWriteTL2(w, sizes, false)
	if len(sizes2) != 0 {
		panic("tl2: internal write did not consume all size data")
	}
	if ctx != nil {
		ctx.SizeBuffer = sizes
	}
	return w
}

func (item *CasesTestAllPossibleFieldConfigs) InternalReadTL2(r []byte) (_ []byte, err error) {
	currentSize := 0
	if r, currentSize, err = basictl.TL2ParseSize(r); err != nil {
		return r, err
	}
	if currentSize == 0 {
		item.Reset()
		return r, nil
	}
	if len(r) < currentSize {
		return r, basictl.TL2Error("not enough data: expected %d, got %d", currentSize, len(r))
	}

	currentR := r[:currentSize]
	r = r[currentSize:]

	var block byte
	if currentR, err = basictl.ByteReadTL2(currentR, &block); err != nil {
		return currentR, err
	}
	// read No of constructor
	if block&1 != 0 {
		var index int
		if currentR, index, err = basictl.TL2ParseSize(currentR); err != nil {
			return currentR, err
		}
		if index != 0 {
			return r, internal.ErrorInvalidUnionIndex("cases.testAllPossibleFieldConfigs", index)
		}
	}
	item.tl2mask0 = 0
	if block&2 != 0 {
		if currentR, err = basictl.NatRead(currentR, &item.Local); err != nil {
			return currentR, err
		}
	} else {
		item.Local = 0
	}
	if block&4 != 0 {
		if currentR, err = basictl.IntRead(currentR, &item.F00); err != nil {
			return currentR, err
		}
	} else {
		item.F00 = 0
	}
	if block&8 != 0 {
		if currentR, err = basictl.SkipSizedValue(currentR); err != nil {
			return currentR, err
		}
	}
	if block&16 != 0 {
		if currentR, err = tlBuiltinTupleInt.BuiltinTupleIntInternalReadTL2(currentR, &item.F02); err != nil {
			return currentR, err
		}
	} else {
		item.F02 = item.F02[:0]
	}
	if block&32 != 0 {
		if currentR, err = tlBuiltinTupleInt.BuiltinTupleIntInternalReadTL2(currentR, &item.F03); err != nil {
			return currentR, err
		}
	} else {
		item.F03 = item.F03[:0]
	}
	if block&64 != 0 {
		item.tl2mask0 |= 1
		if currentR, err = basictl.IntRead(currentR, &item.F10); err != nil {
			return currentR, err
		}
	} else {
		item.F10 = 0
	}
	if block&128 != 0 {
		item.tl2mask0 |= 2
	}
	// start the next block
	if len(currentR) > 0 {
		if currentR, err = basictl.ByteReadTL2(currentR, &block); err != nil {
			return currentR, err
		}
	} else {
		block = 0
	}
	if block&1 != 0 {
		item.tl2mask0 |= 4
		if currentR, err = tlBuiltinTupleInt.BuiltinTupleIntInternalReadTL2(currentR, &item.F12); err != nil {
			return currentR, err
		}
	} else {
		item.F12 = item.F12[:0]
	}
	if block&2 != 0 {
		item.tl2mask0 |= 8
		if currentR, err = tlBuiltinTupleInt.BuiltinTupleIntInternalReadTL2(currentR, &item.F13); err != nil {
			return currentR, err
		}
	} else {
		item.F13 = item.F13[:0]
	}
	if block&4 != 0 {
		item.tl2mask0 |= 16
		if currentR, err = basictl.IntRead(currentR, &item.F20); err != nil {
			return currentR, err
		}
	} else {
		item.F20 = 0
	}
	if block&8 != 0 {
		item.tl2mask0 |= 32
	}
	if block&16 != 0 {
		item.tl2mask0 |= 64
		if currentR, err = tlBuiltinTupleInt.BuiltinTupleIntInternalReadTL2(currentR, &item.F22); err != nil {
			return currentR, err
		}
	} else {
		item.F22 = item.F22[:0]
	}
	if block&32 != 0 {
		item.tl2mask0 |= 128
		if currentR, err = tlBuiltinTupleInt.BuiltinTupleIntInternalReadTL2(currentR, &item.F23); err != nil {
			return currentR, err
		}
	} else {
		item.F23 = item.F23[:0]
	}
	internal.Unused(currentR)
	return r, nil
}

func (item *CasesTestAllPossibleFieldConfigs) ReadTL2(r []byte, ctx *basictl.TL2ReadContext) (_ []byte, err error) {
	return item.InternalReadTL2(r)
}
