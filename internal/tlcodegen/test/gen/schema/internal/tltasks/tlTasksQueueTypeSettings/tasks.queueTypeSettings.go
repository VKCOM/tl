// Copyright 2022 V Kontakte LLC
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Code generated by vktl/cmd/tlgen2; DO NOT EDIT.
package tlTasksQueueTypeSettings

import (
	"github.com/vkcom/tl/internal/tlcodegen/test/gen/schema/internal"
	"github.com/vkcom/tl/internal/tlcodegen/test/gen/schema/internal/tl/tlBool"
	"github.com/vkcom/tl/pkg/basictl"
)

var _ = basictl.NatWrite
var _ = internal.ErrorInvalidEnumTag

type TasksQueueTypeSettings struct {
	FieldsMask             uint32
	IsEnabled              bool   // Conditional: item.FieldsMask.0
	IsPersistent           bool   // Conditional: item.FieldsMask.1
	Priority               int32  // Conditional: item.FieldsMask.2
	DefaultRetryTime       int32  // Conditional: item.FieldsMask.3
	DefaultRetryNum        int32  // Conditional: item.FieldsMask.3
	MoveToQueueTypeOnError string // Conditional: item.FieldsMask.4
	IsBlocking             bool   // Conditional: item.FieldsMask.5
	Timelimit              int32  // Conditional: item.FieldsMask.6
	MaxQueueSize           int32  // Conditional: item.FieldsMask.7
}

func (TasksQueueTypeSettings) TLName() string { return "tasks.queueTypeSettings" }
func (TasksQueueTypeSettings) TLTag() uint32  { return 0x561fbc09 }

func (item *TasksQueueTypeSettings) SetIsEnabled(v bool) {
	item.IsEnabled = v
	item.FieldsMask |= 1 << 0
}
func (item *TasksQueueTypeSettings) ClearIsEnabled() {
	item.IsEnabled = false
	item.FieldsMask &^= 1 << 0
}
func (item *TasksQueueTypeSettings) IsSetIsEnabled() bool { return item.FieldsMask&(1<<0) != 0 }

func (item *TasksQueueTypeSettings) SetIsPersistent(v bool) {
	item.IsPersistent = v
	item.FieldsMask |= 1 << 1
}
func (item *TasksQueueTypeSettings) ClearIsPersistent() {
	item.IsPersistent = false
	item.FieldsMask &^= 1 << 1
}
func (item *TasksQueueTypeSettings) IsSetIsPersistent() bool { return item.FieldsMask&(1<<1) != 0 }

func (item *TasksQueueTypeSettings) SetPriority(v int32) {
	item.Priority = v
	item.FieldsMask |= 1 << 2
}
func (item *TasksQueueTypeSettings) ClearPriority() {
	item.Priority = 0
	item.FieldsMask &^= 1 << 2
}
func (item *TasksQueueTypeSettings) IsSetPriority() bool { return item.FieldsMask&(1<<2) != 0 }

func (item *TasksQueueTypeSettings) SetDefaultRetryTime(v int32) {
	item.DefaultRetryTime = v
	item.FieldsMask |= 1 << 3
}
func (item *TasksQueueTypeSettings) ClearDefaultRetryTime() {
	item.DefaultRetryTime = 0
	item.FieldsMask &^= 1 << 3
}
func (item *TasksQueueTypeSettings) IsSetDefaultRetryTime() bool { return item.FieldsMask&(1<<3) != 0 }

func (item *TasksQueueTypeSettings) SetDefaultRetryNum(v int32) {
	item.DefaultRetryNum = v
	item.FieldsMask |= 1 << 3
}
func (item *TasksQueueTypeSettings) ClearDefaultRetryNum() {
	item.DefaultRetryNum = 0
	item.FieldsMask &^= 1 << 3
}
func (item *TasksQueueTypeSettings) IsSetDefaultRetryNum() bool { return item.FieldsMask&(1<<3) != 0 }

func (item *TasksQueueTypeSettings) SetMoveToQueueTypeOnError(v string) {
	item.MoveToQueueTypeOnError = v
	item.FieldsMask |= 1 << 4
}
func (item *TasksQueueTypeSettings) ClearMoveToQueueTypeOnError() {
	item.MoveToQueueTypeOnError = ""
	item.FieldsMask &^= 1 << 4
}
func (item *TasksQueueTypeSettings) IsSetMoveToQueueTypeOnError() bool {
	return item.FieldsMask&(1<<4) != 0
}

func (item *TasksQueueTypeSettings) SetIsBlocking(v bool) {
	item.IsBlocking = v
	item.FieldsMask |= 1 << 5
}
func (item *TasksQueueTypeSettings) ClearIsBlocking() {
	item.IsBlocking = false
	item.FieldsMask &^= 1 << 5
}
func (item *TasksQueueTypeSettings) IsSetIsBlocking() bool { return item.FieldsMask&(1<<5) != 0 }

func (item *TasksQueueTypeSettings) SetTimelimit(v int32) {
	item.Timelimit = v
	item.FieldsMask |= 1 << 6
}
func (item *TasksQueueTypeSettings) ClearTimelimit() {
	item.Timelimit = 0
	item.FieldsMask &^= 1 << 6
}
func (item *TasksQueueTypeSettings) IsSetTimelimit() bool { return item.FieldsMask&(1<<6) != 0 }

func (item *TasksQueueTypeSettings) SetMaxQueueSize(v int32) {
	item.MaxQueueSize = v
	item.FieldsMask |= 1 << 7
}
func (item *TasksQueueTypeSettings) ClearMaxQueueSize() {
	item.MaxQueueSize = 0
	item.FieldsMask &^= 1 << 7
}
func (item *TasksQueueTypeSettings) IsSetMaxQueueSize() bool { return item.FieldsMask&(1<<7) != 0 }

func (item *TasksQueueTypeSettings) Reset() {
	item.FieldsMask = 0
	item.IsEnabled = false
	item.IsPersistent = false
	item.Priority = 0
	item.DefaultRetryTime = 0
	item.DefaultRetryNum = 0
	item.MoveToQueueTypeOnError = ""
	item.IsBlocking = false
	item.Timelimit = 0
	item.MaxQueueSize = 0
}

func (item *TasksQueueTypeSettings) Read(w []byte) (_ []byte, err error) {
	if w, err = basictl.NatRead(w, &item.FieldsMask); err != nil {
		return w, err
	}
	if item.FieldsMask&(1<<0) != 0 {
		if w, err = tlBool.BoolReadBoxed(w, &item.IsEnabled); err != nil {
			return w, err
		}
	} else {
		item.IsEnabled = false
	}
	if item.FieldsMask&(1<<1) != 0 {
		if w, err = tlBool.BoolReadBoxed(w, &item.IsPersistent); err != nil {
			return w, err
		}
	} else {
		item.IsPersistent = false
	}
	if item.FieldsMask&(1<<2) != 0 {
		if w, err = basictl.IntRead(w, &item.Priority); err != nil {
			return w, err
		}
	} else {
		item.Priority = 0
	}
	if item.FieldsMask&(1<<3) != 0 {
		if w, err = basictl.IntRead(w, &item.DefaultRetryTime); err != nil {
			return w, err
		}
	} else {
		item.DefaultRetryTime = 0
	}
	if item.FieldsMask&(1<<3) != 0 {
		if w, err = basictl.IntRead(w, &item.DefaultRetryNum); err != nil {
			return w, err
		}
	} else {
		item.DefaultRetryNum = 0
	}
	if item.FieldsMask&(1<<4) != 0 {
		if w, err = basictl.StringRead(w, &item.MoveToQueueTypeOnError); err != nil {
			return w, err
		}
	} else {
		item.MoveToQueueTypeOnError = ""
	}
	if item.FieldsMask&(1<<5) != 0 {
		if w, err = tlBool.BoolReadBoxed(w, &item.IsBlocking); err != nil {
			return w, err
		}
	} else {
		item.IsBlocking = false
	}
	if item.FieldsMask&(1<<6) != 0 {
		if w, err = basictl.IntRead(w, &item.Timelimit); err != nil {
			return w, err
		}
	} else {
		item.Timelimit = 0
	}
	if item.FieldsMask&(1<<7) != 0 {
		if w, err = basictl.IntRead(w, &item.MaxQueueSize); err != nil {
			return w, err
		}
	} else {
		item.MaxQueueSize = 0
	}
	return w, nil
}

// This method is general version of Write, use it instead!
func (item *TasksQueueTypeSettings) WriteGeneral(w []byte) (_ []byte, err error) {
	return item.Write(w), nil
}

func (item *TasksQueueTypeSettings) Write(w []byte) []byte {
	w = basictl.NatWrite(w, item.FieldsMask)
	if item.FieldsMask&(1<<0) != 0 {
		w = tlBool.BoolWriteBoxed(w, item.IsEnabled)
	}
	if item.FieldsMask&(1<<1) != 0 {
		w = tlBool.BoolWriteBoxed(w, item.IsPersistent)
	}
	if item.FieldsMask&(1<<2) != 0 {
		w = basictl.IntWrite(w, item.Priority)
	}
	if item.FieldsMask&(1<<3) != 0 {
		w = basictl.IntWrite(w, item.DefaultRetryTime)
	}
	if item.FieldsMask&(1<<3) != 0 {
		w = basictl.IntWrite(w, item.DefaultRetryNum)
	}
	if item.FieldsMask&(1<<4) != 0 {
		w = basictl.StringWrite(w, item.MoveToQueueTypeOnError)
	}
	if item.FieldsMask&(1<<5) != 0 {
		w = tlBool.BoolWriteBoxed(w, item.IsBlocking)
	}
	if item.FieldsMask&(1<<6) != 0 {
		w = basictl.IntWrite(w, item.Timelimit)
	}
	if item.FieldsMask&(1<<7) != 0 {
		w = basictl.IntWrite(w, item.MaxQueueSize)
	}
	return w
}

func (item *TasksQueueTypeSettings) ReadBoxed(w []byte) (_ []byte, err error) {
	if w, err = basictl.NatReadExactTag(w, 0x561fbc09); err != nil {
		return w, err
	}
	return item.Read(w)
}

// This method is general version of WriteBoxed, use it instead!
func (item *TasksQueueTypeSettings) WriteBoxedGeneral(w []byte) (_ []byte, err error) {
	return item.WriteBoxed(w), nil
}

func (item *TasksQueueTypeSettings) WriteBoxed(w []byte) []byte {
	w = basictl.NatWrite(w, 0x561fbc09)
	return item.Write(w)
}

func (item TasksQueueTypeSettings) String() string {
	return string(item.WriteJSON(nil))
}

func (item *TasksQueueTypeSettings) ReadJSON(legacyTypeNames bool, in *basictl.JsonLexer) error {
	var propFieldsMaskPresented bool
	var propIsEnabledPresented bool
	var propIsPersistentPresented bool
	var propPriorityPresented bool
	var propDefaultRetryTimePresented bool
	var propDefaultRetryNumPresented bool
	var propMoveToQueueTypeOnErrorPresented bool
	var propIsBlockingPresented bool
	var propTimelimitPresented bool
	var propMaxQueueSizePresented bool

	if in != nil {
		in.Delim('{')
		if !in.Ok() {
			return in.Error()
		}
		for !in.IsDelim('}') {
			key := in.UnsafeFieldName(true)
			in.WantColon()
			switch key {
			case "fields_mask":
				if propFieldsMaskPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("tasks.queueTypeSettings", "fields_mask")
				}
				if err := internal.Json2ReadUint32(in, &item.FieldsMask); err != nil {
					return err
				}
				propFieldsMaskPresented = true
			case "is_enabled":
				if propIsEnabledPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("tasks.queueTypeSettings", "is_enabled")
				}
				if err := internal.Json2ReadBool(in, &item.IsEnabled); err != nil {
					return err
				}
				propIsEnabledPresented = true
			case "is_persistent":
				if propIsPersistentPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("tasks.queueTypeSettings", "is_persistent")
				}
				if err := internal.Json2ReadBool(in, &item.IsPersistent); err != nil {
					return err
				}
				propIsPersistentPresented = true
			case "priority":
				if propPriorityPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("tasks.queueTypeSettings", "priority")
				}
				if err := internal.Json2ReadInt32(in, &item.Priority); err != nil {
					return err
				}
				propPriorityPresented = true
			case "default_retry_time":
				if propDefaultRetryTimePresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("tasks.queueTypeSettings", "default_retry_time")
				}
				if err := internal.Json2ReadInt32(in, &item.DefaultRetryTime); err != nil {
					return err
				}
				propDefaultRetryTimePresented = true
			case "default_retry_num":
				if propDefaultRetryNumPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("tasks.queueTypeSettings", "default_retry_num")
				}
				if err := internal.Json2ReadInt32(in, &item.DefaultRetryNum); err != nil {
					return err
				}
				propDefaultRetryNumPresented = true
			case "move_to_queue_type_on_error":
				if propMoveToQueueTypeOnErrorPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("tasks.queueTypeSettings", "move_to_queue_type_on_error")
				}
				if err := internal.Json2ReadString(in, &item.MoveToQueueTypeOnError); err != nil {
					return err
				}
				propMoveToQueueTypeOnErrorPresented = true
			case "is_blocking":
				if propIsBlockingPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("tasks.queueTypeSettings", "is_blocking")
				}
				if err := internal.Json2ReadBool(in, &item.IsBlocking); err != nil {
					return err
				}
				propIsBlockingPresented = true
			case "timelimit":
				if propTimelimitPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("tasks.queueTypeSettings", "timelimit")
				}
				if err := internal.Json2ReadInt32(in, &item.Timelimit); err != nil {
					return err
				}
				propTimelimitPresented = true
			case "max_queue_size":
				if propMaxQueueSizePresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("tasks.queueTypeSettings", "max_queue_size")
				}
				if err := internal.Json2ReadInt32(in, &item.MaxQueueSize); err != nil {
					return err
				}
				propMaxQueueSizePresented = true
			default:
				return internal.ErrorInvalidJSONExcessElement("tasks.queueTypeSettings", key)
			}
			in.WantComma()
		}
		in.Delim('}')
		if !in.Ok() {
			return in.Error()
		}
	}
	if !propFieldsMaskPresented {
		item.FieldsMask = 0
	}
	if !propIsEnabledPresented {
		item.IsEnabled = false
	}
	if !propIsPersistentPresented {
		item.IsPersistent = false
	}
	if !propPriorityPresented {
		item.Priority = 0
	}
	if !propDefaultRetryTimePresented {
		item.DefaultRetryTime = 0
	}
	if !propDefaultRetryNumPresented {
		item.DefaultRetryNum = 0
	}
	if !propMoveToQueueTypeOnErrorPresented {
		item.MoveToQueueTypeOnError = ""
	}
	if !propIsBlockingPresented {
		item.IsBlocking = false
	}
	if !propTimelimitPresented {
		item.Timelimit = 0
	}
	if !propMaxQueueSizePresented {
		item.MaxQueueSize = 0
	}
	if propIsEnabledPresented {
		item.FieldsMask |= 1 << 0
	}
	if propIsPersistentPresented {
		item.FieldsMask |= 1 << 1
	}
	if propPriorityPresented {
		item.FieldsMask |= 1 << 2
	}
	if propDefaultRetryTimePresented {
		item.FieldsMask |= 1 << 3
	}
	if propDefaultRetryNumPresented {
		item.FieldsMask |= 1 << 3
	}
	if propMoveToQueueTypeOnErrorPresented {
		item.FieldsMask |= 1 << 4
	}
	if propIsBlockingPresented {
		item.FieldsMask |= 1 << 5
	}
	if propTimelimitPresented {
		item.FieldsMask |= 1 << 6
	}
	if propMaxQueueSizePresented {
		item.FieldsMask |= 1 << 7
	}
	return nil
}

// This method is general version of WriteJSON, use it instead!
func (item *TasksQueueTypeSettings) WriteJSONGeneral(w []byte) (_ []byte, err error) {
	return item.WriteJSONOpt(true, false, w), nil
}

func (item *TasksQueueTypeSettings) WriteJSON(w []byte) []byte {
	return item.WriteJSONOpt(true, false, w)
}
func (item *TasksQueueTypeSettings) WriteJSONOpt(newTypeNames bool, short bool, w []byte) []byte {
	w = append(w, '{')
	backupIndexFieldsMask := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"fields_mask":`...)
	w = basictl.JSONWriteUint32(w, item.FieldsMask)
	if (item.FieldsMask != 0) == false {
		w = w[:backupIndexFieldsMask]
	}
	if item.FieldsMask&(1<<0) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"is_enabled":`...)
		w = basictl.JSONWriteBool(w, item.IsEnabled)
	}
	if item.FieldsMask&(1<<1) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"is_persistent":`...)
		w = basictl.JSONWriteBool(w, item.IsPersistent)
	}
	if item.FieldsMask&(1<<2) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"priority":`...)
		w = basictl.JSONWriteInt32(w, item.Priority)
	}
	if item.FieldsMask&(1<<3) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"default_retry_time":`...)
		w = basictl.JSONWriteInt32(w, item.DefaultRetryTime)
	}
	if item.FieldsMask&(1<<3) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"default_retry_num":`...)
		w = basictl.JSONWriteInt32(w, item.DefaultRetryNum)
	}
	if item.FieldsMask&(1<<4) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"move_to_queue_type_on_error":`...)
		w = basictl.JSONWriteString(w, item.MoveToQueueTypeOnError)
	}
	if item.FieldsMask&(1<<5) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"is_blocking":`...)
		w = basictl.JSONWriteBool(w, item.IsBlocking)
	}
	if item.FieldsMask&(1<<6) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"timelimit":`...)
		w = basictl.JSONWriteInt32(w, item.Timelimit)
	}
	if item.FieldsMask&(1<<7) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"max_queue_size":`...)
		w = basictl.JSONWriteInt32(w, item.MaxQueueSize)
	}
	return append(w, '}')
}

func (item *TasksQueueTypeSettings) MarshalJSON() ([]byte, error) {
	return item.WriteJSON(nil), nil
}

func (item *TasksQueueTypeSettings) UnmarshalJSON(b []byte) error {
	if err := item.ReadJSON(true, &basictl.JsonLexer{Data: b}); err != nil {
		return internal.ErrorInvalidJSON("tasks.queueTypeSettings", err.Error())
	}
	return nil
}
