// Copyright 2022 V Kontakte LLC
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Code generated by vktl/cmd/tlgen2; DO NOT EDIT.
package tlTasksCronTime

import (
	"github.com/vkcom/tl/internal/tlcodegen/test/gen/schema/internal"
	"github.com/vkcom/tl/internal/tlcodegen/test/gen/schema/internal/tl/tlBuiltinVectorInt"
	"github.com/vkcom/tl/pkg/basictl"
)

var _ = basictl.NatWrite
var _ = internal.ErrorInvalidEnumTag

type TasksCronTime struct {
	FieldsMask uint32
	Seconds    []int32 // Conditional: item.FieldsMask.0
	Minutes    []int32 // Conditional: item.FieldsMask.1
	Hours      []int32 // Conditional: item.FieldsMask.2
	DaysOfWeek []int32 // Conditional: item.FieldsMask.3
	Days       []int32 // Conditional: item.FieldsMask.4
	Months     []int32 // Conditional: item.FieldsMask.5
}

func (TasksCronTime) TLName() string { return "tasks.cronTime" }
func (TasksCronTime) TLTag() uint32  { return 0xd4177d7f }

func (item *TasksCronTime) SetSeconds(v []int32) {
	item.Seconds = v
	item.FieldsMask |= 1 << 0
}
func (item *TasksCronTime) ClearSeconds() {
	item.Seconds = item.Seconds[:0]
	item.FieldsMask &^= 1 << 0
}
func (item TasksCronTime) IsSetSeconds() bool { return item.FieldsMask&(1<<0) != 0 }

func (item *TasksCronTime) SetMinutes(v []int32) {
	item.Minutes = v
	item.FieldsMask |= 1 << 1
}
func (item *TasksCronTime) ClearMinutes() {
	item.Minutes = item.Minutes[:0]
	item.FieldsMask &^= 1 << 1
}
func (item TasksCronTime) IsSetMinutes() bool { return item.FieldsMask&(1<<1) != 0 }

func (item *TasksCronTime) SetHours(v []int32) {
	item.Hours = v
	item.FieldsMask |= 1 << 2
}
func (item *TasksCronTime) ClearHours() {
	item.Hours = item.Hours[:0]
	item.FieldsMask &^= 1 << 2
}
func (item TasksCronTime) IsSetHours() bool { return item.FieldsMask&(1<<2) != 0 }

func (item *TasksCronTime) SetDaysOfWeek(v []int32) {
	item.DaysOfWeek = v
	item.FieldsMask |= 1 << 3
}
func (item *TasksCronTime) ClearDaysOfWeek() {
	item.DaysOfWeek = item.DaysOfWeek[:0]
	item.FieldsMask &^= 1 << 3
}
func (item TasksCronTime) IsSetDaysOfWeek() bool { return item.FieldsMask&(1<<3) != 0 }

func (item *TasksCronTime) SetDays(v []int32) {
	item.Days = v
	item.FieldsMask |= 1 << 4
}
func (item *TasksCronTime) ClearDays() {
	item.Days = item.Days[:0]
	item.FieldsMask &^= 1 << 4
}
func (item TasksCronTime) IsSetDays() bool { return item.FieldsMask&(1<<4) != 0 }

func (item *TasksCronTime) SetMonths(v []int32) {
	item.Months = v
	item.FieldsMask |= 1 << 5
}
func (item *TasksCronTime) ClearMonths() {
	item.Months = item.Months[:0]
	item.FieldsMask &^= 1 << 5
}
func (item TasksCronTime) IsSetMonths() bool { return item.FieldsMask&(1<<5) != 0 }

func (item *TasksCronTime) Reset() {
	item.FieldsMask = 0
	item.Seconds = item.Seconds[:0]
	item.Minutes = item.Minutes[:0]
	item.Hours = item.Hours[:0]
	item.DaysOfWeek = item.DaysOfWeek[:0]
	item.Days = item.Days[:0]
	item.Months = item.Months[:0]
}

func (item *TasksCronTime) Read(w []byte) (_ []byte, err error) {
	if w, err = basictl.NatRead(w, &item.FieldsMask); err != nil {
		return w, err
	}
	if item.FieldsMask&(1<<0) != 0 {
		if w, err = tlBuiltinVectorInt.BuiltinVectorIntRead(w, &item.Seconds); err != nil {
			return w, err
		}
	} else {
		item.Seconds = item.Seconds[:0]
	}
	if item.FieldsMask&(1<<1) != 0 {
		if w, err = tlBuiltinVectorInt.BuiltinVectorIntRead(w, &item.Minutes); err != nil {
			return w, err
		}
	} else {
		item.Minutes = item.Minutes[:0]
	}
	if item.FieldsMask&(1<<2) != 0 {
		if w, err = tlBuiltinVectorInt.BuiltinVectorIntRead(w, &item.Hours); err != nil {
			return w, err
		}
	} else {
		item.Hours = item.Hours[:0]
	}
	if item.FieldsMask&(1<<3) != 0 {
		if w, err = tlBuiltinVectorInt.BuiltinVectorIntRead(w, &item.DaysOfWeek); err != nil {
			return w, err
		}
	} else {
		item.DaysOfWeek = item.DaysOfWeek[:0]
	}
	if item.FieldsMask&(1<<4) != 0 {
		if w, err = tlBuiltinVectorInt.BuiltinVectorIntRead(w, &item.Days); err != nil {
			return w, err
		}
	} else {
		item.Days = item.Days[:0]
	}
	if item.FieldsMask&(1<<5) != 0 {
		if w, err = tlBuiltinVectorInt.BuiltinVectorIntRead(w, &item.Months); err != nil {
			return w, err
		}
	} else {
		item.Months = item.Months[:0]
	}
	return w, nil
}

// This method is general version of Write, use it instead!
func (item *TasksCronTime) WriteGeneral(w []byte) (_ []byte, err error) {
	return item.Write(w), nil
}

func (item *TasksCronTime) Write(w []byte) []byte {
	w = basictl.NatWrite(w, item.FieldsMask)
	if item.FieldsMask&(1<<0) != 0 {
		w = tlBuiltinVectorInt.BuiltinVectorIntWrite(w, item.Seconds)
	}
	if item.FieldsMask&(1<<1) != 0 {
		w = tlBuiltinVectorInt.BuiltinVectorIntWrite(w, item.Minutes)
	}
	if item.FieldsMask&(1<<2) != 0 {
		w = tlBuiltinVectorInt.BuiltinVectorIntWrite(w, item.Hours)
	}
	if item.FieldsMask&(1<<3) != 0 {
		w = tlBuiltinVectorInt.BuiltinVectorIntWrite(w, item.DaysOfWeek)
	}
	if item.FieldsMask&(1<<4) != 0 {
		w = tlBuiltinVectorInt.BuiltinVectorIntWrite(w, item.Days)
	}
	if item.FieldsMask&(1<<5) != 0 {
		w = tlBuiltinVectorInt.BuiltinVectorIntWrite(w, item.Months)
	}
	return w
}

func (item *TasksCronTime) ReadBoxed(w []byte) (_ []byte, err error) {
	if w, err = basictl.NatReadExactTag(w, 0xd4177d7f); err != nil {
		return w, err
	}
	return item.Read(w)
}

// This method is general version of WriteBoxed, use it instead!
func (item *TasksCronTime) WriteBoxedGeneral(w []byte) (_ []byte, err error) {
	return item.WriteBoxed(w), nil
}

func (item *TasksCronTime) WriteBoxed(w []byte) []byte {
	w = basictl.NatWrite(w, 0xd4177d7f)
	return item.Write(w)
}

func (item TasksCronTime) String() string {
	return string(item.WriteJSON(nil))
}

func (item *TasksCronTime) ReadJSON(legacyTypeNames bool, in *basictl.JsonLexer) error {
	var propFieldsMaskPresented bool
	var propSecondsPresented bool
	var propMinutesPresented bool
	var propHoursPresented bool
	var propDaysOfWeekPresented bool
	var propDaysPresented bool
	var propMonthsPresented bool

	if in != nil {
		in.Delim('{')
		if !in.Ok() {
			return in.Error()
		}
		for !in.IsDelim('}') {
			key := in.UnsafeFieldName(true)
			in.WantColon()
			switch key {
			case "fields_mask":
				if propFieldsMaskPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("tasks.cronTime", "fields_mask")
				}
				if err := internal.Json2ReadUint32(in, &item.FieldsMask); err != nil {
					return err
				}
				propFieldsMaskPresented = true
			case "seconds":
				if propSecondsPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("tasks.cronTime", "seconds")
				}
				if err := tlBuiltinVectorInt.BuiltinVectorIntReadJSON(legacyTypeNames, in, &item.Seconds); err != nil {
					return err
				}
				propSecondsPresented = true
			case "minutes":
				if propMinutesPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("tasks.cronTime", "minutes")
				}
				if err := tlBuiltinVectorInt.BuiltinVectorIntReadJSON(legacyTypeNames, in, &item.Minutes); err != nil {
					return err
				}
				propMinutesPresented = true
			case "hours":
				if propHoursPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("tasks.cronTime", "hours")
				}
				if err := tlBuiltinVectorInt.BuiltinVectorIntReadJSON(legacyTypeNames, in, &item.Hours); err != nil {
					return err
				}
				propHoursPresented = true
			case "days_of_week":
				if propDaysOfWeekPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("tasks.cronTime", "days_of_week")
				}
				if err := tlBuiltinVectorInt.BuiltinVectorIntReadJSON(legacyTypeNames, in, &item.DaysOfWeek); err != nil {
					return err
				}
				propDaysOfWeekPresented = true
			case "days":
				if propDaysPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("tasks.cronTime", "days")
				}
				if err := tlBuiltinVectorInt.BuiltinVectorIntReadJSON(legacyTypeNames, in, &item.Days); err != nil {
					return err
				}
				propDaysPresented = true
			case "months":
				if propMonthsPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("tasks.cronTime", "months")
				}
				if err := tlBuiltinVectorInt.BuiltinVectorIntReadJSON(legacyTypeNames, in, &item.Months); err != nil {
					return err
				}
				propMonthsPresented = true
			default:
				return internal.ErrorInvalidJSONExcessElement("tasks.cronTime", key)
			}
			in.WantComma()
		}
		in.Delim('}')
		if !in.Ok() {
			return in.Error()
		}
	}
	if !propFieldsMaskPresented {
		item.FieldsMask = 0
	}
	if !propSecondsPresented {
		item.Seconds = item.Seconds[:0]
	}
	if !propMinutesPresented {
		item.Minutes = item.Minutes[:0]
	}
	if !propHoursPresented {
		item.Hours = item.Hours[:0]
	}
	if !propDaysOfWeekPresented {
		item.DaysOfWeek = item.DaysOfWeek[:0]
	}
	if !propDaysPresented {
		item.Days = item.Days[:0]
	}
	if !propMonthsPresented {
		item.Months = item.Months[:0]
	}
	if propSecondsPresented {
		item.FieldsMask |= 1 << 0
	}
	if propMinutesPresented {
		item.FieldsMask |= 1 << 1
	}
	if propHoursPresented {
		item.FieldsMask |= 1 << 2
	}
	if propDaysOfWeekPresented {
		item.FieldsMask |= 1 << 3
	}
	if propDaysPresented {
		item.FieldsMask |= 1 << 4
	}
	if propMonthsPresented {
		item.FieldsMask |= 1 << 5
	}
	return nil
}

// This method is general version of WriteJSON, use it instead!
func (item *TasksCronTime) WriteJSONGeneral(w []byte) (_ []byte, err error) {
	return item.WriteJSONOpt(true, false, w), nil
}

func (item *TasksCronTime) WriteJSON(w []byte) []byte {
	return item.WriteJSONOpt(true, false, w)
}
func (item *TasksCronTime) WriteJSONOpt(newTypeNames bool, short bool, w []byte) []byte {
	w = append(w, '{')
	backupIndexFieldsMask := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"fields_mask":`...)
	w = basictl.JSONWriteUint32(w, item.FieldsMask)
	if (item.FieldsMask != 0) == false {
		w = w[:backupIndexFieldsMask]
	}
	if item.FieldsMask&(1<<0) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"seconds":`...)
		w = tlBuiltinVectorInt.BuiltinVectorIntWriteJSONOpt(newTypeNames, short, w, item.Seconds)
	}
	if item.FieldsMask&(1<<1) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"minutes":`...)
		w = tlBuiltinVectorInt.BuiltinVectorIntWriteJSONOpt(newTypeNames, short, w, item.Minutes)
	}
	if item.FieldsMask&(1<<2) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"hours":`...)
		w = tlBuiltinVectorInt.BuiltinVectorIntWriteJSONOpt(newTypeNames, short, w, item.Hours)
	}
	if item.FieldsMask&(1<<3) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"days_of_week":`...)
		w = tlBuiltinVectorInt.BuiltinVectorIntWriteJSONOpt(newTypeNames, short, w, item.DaysOfWeek)
	}
	if item.FieldsMask&(1<<4) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"days":`...)
		w = tlBuiltinVectorInt.BuiltinVectorIntWriteJSONOpt(newTypeNames, short, w, item.Days)
	}
	if item.FieldsMask&(1<<5) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"months":`...)
		w = tlBuiltinVectorInt.BuiltinVectorIntWriteJSONOpt(newTypeNames, short, w, item.Months)
	}
	return append(w, '}')
}

func (item *TasksCronTime) MarshalJSON() ([]byte, error) {
	return item.WriteJSON(nil), nil
}

func (item *TasksCronTime) UnmarshalJSON(b []byte) error {
	if err := item.ReadJSON(true, &basictl.JsonLexer{Data: b}); err != nil {
		return internal.ErrorInvalidJSON("tasks.cronTime", err.Error())
	}
	return nil
}
