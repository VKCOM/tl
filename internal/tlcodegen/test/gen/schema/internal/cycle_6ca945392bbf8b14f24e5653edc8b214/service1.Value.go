// Copyright 2022 V Kontakte LLC
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Code generated by vktl/cmd/tlgen2; DO NOT EDIT.
package cycle_6ca945392bbf8b14f24e5653edc8b214

import (
	"github.com/vkcom/tl/internal/tlcodegen/test/gen/schema/internal"
	"github.com/vkcom/tl/pkg/basictl"
)

var _ = basictl.NatWrite
var _ = internal.ErrorInvalidEnumTag

func (item Service1Longvalue) AsUnion() Service1Value {
	var ret Service1Value
	ret.SetLongvalue(item)
	return ret
}

type Service1Longvalue struct {
	Value int64
	Flags int32
}

func (Service1Longvalue) TLName() string { return "service1.longvalue" }
func (Service1Longvalue) TLTag() uint32  { return 0x082e0945 }

func (item *Service1Longvalue) Reset() {
	item.Value = 0
	item.Flags = 0
}

func (item *Service1Longvalue) Read(w []byte) (_ []byte, err error) {
	if w, err = basictl.LongRead(w, &item.Value); err != nil {
		return w, err
	}
	return basictl.IntRead(w, &item.Flags)
}

// This method is general version of Write, use it instead!
func (item *Service1Longvalue) WriteGeneral(w []byte) (_ []byte, err error) {
	return item.Write(w), nil
}

func (item *Service1Longvalue) Write(w []byte) []byte {
	w = basictl.LongWrite(w, item.Value)
	w = basictl.IntWrite(w, item.Flags)
	return w
}

func (item *Service1Longvalue) ReadBoxed(w []byte) (_ []byte, err error) {
	if w, err = basictl.NatReadExactTag(w, 0x082e0945); err != nil {
		return w, err
	}
	return item.Read(w)
}

// This method is general version of WriteBoxed, use it instead!
func (item *Service1Longvalue) WriteBoxedGeneral(w []byte) (_ []byte, err error) {
	return item.WriteBoxed(w), nil
}

func (item *Service1Longvalue) WriteBoxed(w []byte) []byte {
	w = basictl.NatWrite(w, 0x082e0945)
	return item.Write(w)
}

func (item Service1Longvalue) String() string {
	return string(item.WriteJSON(nil))
}

func (item *Service1Longvalue) ReadJSON(legacyTypeNames bool, in *basictl.JsonLexer) error {
	var propValuePresented bool
	var propFlagsPresented bool

	if in != nil {
		in.Delim('{')
		if !in.Ok() {
			return in.Error()
		}
		for !in.IsDelim('}') {
			key := in.UnsafeFieldName(true)
			in.WantColon()
			switch key {
			case "value":
				if propValuePresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("service1.longvalue", "value")
				}
				if err := internal.Json2ReadInt64(in, &item.Value); err != nil {
					return err
				}
				propValuePresented = true
			case "flags":
				if propFlagsPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("service1.longvalue", "flags")
				}
				if err := internal.Json2ReadInt32(in, &item.Flags); err != nil {
					return err
				}
				propFlagsPresented = true
			default:
				return internal.ErrorInvalidJSONExcessElement("service1.longvalue", key)
			}
			in.WantComma()
		}
		in.Delim('}')
		if !in.Ok() {
			return in.Error()
		}
	}
	if !propValuePresented {
		item.Value = 0
	}
	if !propFlagsPresented {
		item.Flags = 0
	}
	return nil
}

// This method is general version of WriteJSON, use it instead!
func (item *Service1Longvalue) WriteJSONGeneral(w []byte) (_ []byte, err error) {
	return item.WriteJSONOpt(true, false, w), nil
}

func (item *Service1Longvalue) WriteJSON(w []byte) []byte {
	return item.WriteJSONOpt(true, false, w)
}
func (item *Service1Longvalue) WriteJSONOpt(newTypeNames bool, short bool, w []byte) []byte {
	w = append(w, '{')
	backupIndexValue := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"value":`...)
	w = basictl.JSONWriteInt64(w, item.Value)
	if (item.Value != 0) == false {
		w = w[:backupIndexValue]
	}
	backupIndexFlags := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"flags":`...)
	w = basictl.JSONWriteInt32(w, item.Flags)
	if (item.Flags != 0) == false {
		w = w[:backupIndexFlags]
	}
	return append(w, '}')
}

func (item *Service1Longvalue) MarshalJSON() ([]byte, error) {
	return item.WriteJSON(nil), nil
}

func (item *Service1Longvalue) UnmarshalJSON(b []byte) error {
	if err := item.ReadJSON(true, &basictl.JsonLexer{Data: b}); err != nil {
		return internal.ErrorInvalidJSON("service1.longvalue", err.Error())
	}
	return nil
}

func (item Service1LongvalueWithTime) AsUnion() Service1Value {
	var ret Service1Value
	ret.SetLongvalueWithTime(item)
	return ret
}

type Service1LongvalueWithTime struct {
	Value            int64
	Flags            int32
	ModificationTime int32
}

func (Service1LongvalueWithTime) TLName() string { return "service1.longvalueWithTime" }
func (Service1LongvalueWithTime) TLTag() uint32  { return 0xa04606ec }

func (item *Service1LongvalueWithTime) Reset() {
	item.Value = 0
	item.Flags = 0
	item.ModificationTime = 0
}

func (item *Service1LongvalueWithTime) Read(w []byte) (_ []byte, err error) {
	if w, err = basictl.LongRead(w, &item.Value); err != nil {
		return w, err
	}
	if w, err = basictl.IntRead(w, &item.Flags); err != nil {
		return w, err
	}
	return basictl.IntRead(w, &item.ModificationTime)
}

// This method is general version of Write, use it instead!
func (item *Service1LongvalueWithTime) WriteGeneral(w []byte) (_ []byte, err error) {
	return item.Write(w), nil
}

func (item *Service1LongvalueWithTime) Write(w []byte) []byte {
	w = basictl.LongWrite(w, item.Value)
	w = basictl.IntWrite(w, item.Flags)
	w = basictl.IntWrite(w, item.ModificationTime)
	return w
}

func (item *Service1LongvalueWithTime) ReadBoxed(w []byte) (_ []byte, err error) {
	if w, err = basictl.NatReadExactTag(w, 0xa04606ec); err != nil {
		return w, err
	}
	return item.Read(w)
}

// This method is general version of WriteBoxed, use it instead!
func (item *Service1LongvalueWithTime) WriteBoxedGeneral(w []byte) (_ []byte, err error) {
	return item.WriteBoxed(w), nil
}

func (item *Service1LongvalueWithTime) WriteBoxed(w []byte) []byte {
	w = basictl.NatWrite(w, 0xa04606ec)
	return item.Write(w)
}

func (item Service1LongvalueWithTime) String() string {
	return string(item.WriteJSON(nil))
}

func (item *Service1LongvalueWithTime) ReadJSON(legacyTypeNames bool, in *basictl.JsonLexer) error {
	var propValuePresented bool
	var propFlagsPresented bool
	var propModificationTimePresented bool

	if in != nil {
		in.Delim('{')
		if !in.Ok() {
			return in.Error()
		}
		for !in.IsDelim('}') {
			key := in.UnsafeFieldName(true)
			in.WantColon()
			switch key {
			case "value":
				if propValuePresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("service1.longvalueWithTime", "value")
				}
				if err := internal.Json2ReadInt64(in, &item.Value); err != nil {
					return err
				}
				propValuePresented = true
			case "flags":
				if propFlagsPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("service1.longvalueWithTime", "flags")
				}
				if err := internal.Json2ReadInt32(in, &item.Flags); err != nil {
					return err
				}
				propFlagsPresented = true
			case "modificationTime":
				if propModificationTimePresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("service1.longvalueWithTime", "modificationTime")
				}
				if err := internal.Json2ReadInt32(in, &item.ModificationTime); err != nil {
					return err
				}
				propModificationTimePresented = true
			default:
				return internal.ErrorInvalidJSONExcessElement("service1.longvalueWithTime", key)
			}
			in.WantComma()
		}
		in.Delim('}')
		if !in.Ok() {
			return in.Error()
		}
	}
	if !propValuePresented {
		item.Value = 0
	}
	if !propFlagsPresented {
		item.Flags = 0
	}
	if !propModificationTimePresented {
		item.ModificationTime = 0
	}
	return nil
}

// This method is general version of WriteJSON, use it instead!
func (item *Service1LongvalueWithTime) WriteJSONGeneral(w []byte) (_ []byte, err error) {
	return item.WriteJSONOpt(true, false, w), nil
}

func (item *Service1LongvalueWithTime) WriteJSON(w []byte) []byte {
	return item.WriteJSONOpt(true, false, w)
}
func (item *Service1LongvalueWithTime) WriteJSONOpt(newTypeNames bool, short bool, w []byte) []byte {
	w = append(w, '{')
	backupIndexValue := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"value":`...)
	w = basictl.JSONWriteInt64(w, item.Value)
	if (item.Value != 0) == false {
		w = w[:backupIndexValue]
	}
	backupIndexFlags := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"flags":`...)
	w = basictl.JSONWriteInt32(w, item.Flags)
	if (item.Flags != 0) == false {
		w = w[:backupIndexFlags]
	}
	backupIndexModificationTime := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"modificationTime":`...)
	w = basictl.JSONWriteInt32(w, item.ModificationTime)
	if (item.ModificationTime != 0) == false {
		w = w[:backupIndexModificationTime]
	}
	return append(w, '}')
}

func (item *Service1LongvalueWithTime) MarshalJSON() ([]byte, error) {
	return item.WriteJSON(nil), nil
}

func (item *Service1LongvalueWithTime) UnmarshalJSON(b []byte) error {
	if err := item.ReadJSON(true, &basictl.JsonLexer{Data: b}); err != nil {
		return internal.ErrorInvalidJSON("service1.longvalueWithTime", err.Error())
	}
	return nil
}

func (item Service1NotFound) AsUnion() Service1Value {
	var ret Service1Value
	ret.SetNotFound()
	return ret
}

type Service1NotFound struct {
}

func (Service1NotFound) TLName() string { return "service1.not_found" }
func (Service1NotFound) TLTag() uint32  { return 0x1d670b96 }

func (item *Service1NotFound) Reset() {}

func (item *Service1NotFound) Read(w []byte) (_ []byte, err error) { return w, nil }

// This method is general version of Write, use it instead!
func (item *Service1NotFound) WriteGeneral(w []byte) (_ []byte, err error) {
	return item.Write(w), nil
}

func (item *Service1NotFound) Write(w []byte) []byte {
	return w
}

func (item *Service1NotFound) ReadBoxed(w []byte) (_ []byte, err error) {
	if w, err = basictl.NatReadExactTag(w, 0x1d670b96); err != nil {
		return w, err
	}
	return item.Read(w)
}

// This method is general version of WriteBoxed, use it instead!
func (item *Service1NotFound) WriteBoxedGeneral(w []byte) (_ []byte, err error) {
	return item.WriteBoxed(w), nil
}

func (item *Service1NotFound) WriteBoxed(w []byte) []byte {
	w = basictl.NatWrite(w, 0x1d670b96)
	return item.Write(w)
}

func (item Service1NotFound) String() string {
	return string(item.WriteJSON(nil))
}

func (item *Service1NotFound) ReadJSON(legacyTypeNames bool, in *basictl.JsonLexer) error {
	if in != nil {
		in.Delim('{')
		if !in.Ok() {
			return in.Error()
		}
		for !in.IsDelim('}') {
			return internal.ErrorInvalidJSON("service1.not_found", "this object can't have properties")
		}
		in.Delim('}')
		if !in.Ok() {
			return in.Error()
		}
	}
	return nil
}

// This method is general version of WriteJSON, use it instead!
func (item *Service1NotFound) WriteJSONGeneral(w []byte) (_ []byte, err error) {
	return item.WriteJSONOpt(true, false, w), nil
}

func (item *Service1NotFound) WriteJSON(w []byte) []byte {
	return item.WriteJSONOpt(true, false, w)
}
func (item *Service1NotFound) WriteJSONOpt(newTypeNames bool, short bool, w []byte) []byte {
	w = append(w, '{')
	return append(w, '}')
}

func (item *Service1NotFound) MarshalJSON() ([]byte, error) {
	return item.WriteJSON(nil), nil
}

func (item *Service1NotFound) UnmarshalJSON(b []byte) error {
	if err := item.ReadJSON(true, &basictl.JsonLexer{Data: b}); err != nil {
		return internal.ErrorInvalidJSON("service1.not_found", err.Error())
	}
	return nil
}

func (item Service1Strvalue) AsUnion() Service1Value {
	var ret Service1Value
	ret.SetStrvalue(item)
	return ret
}

type Service1Strvalue struct {
	Value string
	Flags int32
}

func (Service1Strvalue) TLName() string { return "service1.strvalue" }
func (Service1Strvalue) TLTag() uint32  { return 0x5faa0c52 }

func (item *Service1Strvalue) Reset() {
	item.Value = ""
	item.Flags = 0
}

func (item *Service1Strvalue) Read(w []byte) (_ []byte, err error) {
	if w, err = basictl.StringRead(w, &item.Value); err != nil {
		return w, err
	}
	return basictl.IntRead(w, &item.Flags)
}

// This method is general version of Write, use it instead!
func (item *Service1Strvalue) WriteGeneral(w []byte) (_ []byte, err error) {
	return item.Write(w), nil
}

func (item *Service1Strvalue) Write(w []byte) []byte {
	w = basictl.StringWrite(w, item.Value)
	w = basictl.IntWrite(w, item.Flags)
	return w
}

func (item *Service1Strvalue) ReadBoxed(w []byte) (_ []byte, err error) {
	if w, err = basictl.NatReadExactTag(w, 0x5faa0c52); err != nil {
		return w, err
	}
	return item.Read(w)
}

// This method is general version of WriteBoxed, use it instead!
func (item *Service1Strvalue) WriteBoxedGeneral(w []byte) (_ []byte, err error) {
	return item.WriteBoxed(w), nil
}

func (item *Service1Strvalue) WriteBoxed(w []byte) []byte {
	w = basictl.NatWrite(w, 0x5faa0c52)
	return item.Write(w)
}

func (item Service1Strvalue) String() string {
	return string(item.WriteJSON(nil))
}

func (item *Service1Strvalue) ReadJSON(legacyTypeNames bool, in *basictl.JsonLexer) error {
	var propValuePresented bool
	var propFlagsPresented bool

	if in != nil {
		in.Delim('{')
		if !in.Ok() {
			return in.Error()
		}
		for !in.IsDelim('}') {
			key := in.UnsafeFieldName(true)
			in.WantColon()
			switch key {
			case "value":
				if propValuePresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("service1.strvalue", "value")
				}
				if err := internal.Json2ReadString(in, &item.Value); err != nil {
					return err
				}
				propValuePresented = true
			case "flags":
				if propFlagsPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("service1.strvalue", "flags")
				}
				if err := internal.Json2ReadInt32(in, &item.Flags); err != nil {
					return err
				}
				propFlagsPresented = true
			default:
				return internal.ErrorInvalidJSONExcessElement("service1.strvalue", key)
			}
			in.WantComma()
		}
		in.Delim('}')
		if !in.Ok() {
			return in.Error()
		}
	}
	if !propValuePresented {
		item.Value = ""
	}
	if !propFlagsPresented {
		item.Flags = 0
	}
	return nil
}

// This method is general version of WriteJSON, use it instead!
func (item *Service1Strvalue) WriteJSONGeneral(w []byte) (_ []byte, err error) {
	return item.WriteJSONOpt(true, false, w), nil
}

func (item *Service1Strvalue) WriteJSON(w []byte) []byte {
	return item.WriteJSONOpt(true, false, w)
}
func (item *Service1Strvalue) WriteJSONOpt(newTypeNames bool, short bool, w []byte) []byte {
	w = append(w, '{')
	backupIndexValue := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"value":`...)
	w = basictl.JSONWriteString(w, item.Value)
	if (len(item.Value) != 0) == false {
		w = w[:backupIndexValue]
	}
	backupIndexFlags := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"flags":`...)
	w = basictl.JSONWriteInt32(w, item.Flags)
	if (item.Flags != 0) == false {
		w = w[:backupIndexFlags]
	}
	return append(w, '}')
}

func (item *Service1Strvalue) MarshalJSON() ([]byte, error) {
	return item.WriteJSON(nil), nil
}

func (item *Service1Strvalue) UnmarshalJSON(b []byte) error {
	if err := item.ReadJSON(true, &basictl.JsonLexer{Data: b}); err != nil {
		return internal.ErrorInvalidJSON("service1.strvalue", err.Error())
	}
	return nil
}

func (item Service1StrvalueWithTime) AsUnion() Service1Value {
	var ret Service1Value
	ret.SetStrvalueWithTime(item)
	return ret
}

type Service1StrvalueWithTime struct {
	Value            string
	Flags            int32
	ModificationTime int32
}

func (Service1StrvalueWithTime) TLName() string { return "service1.strvalueWithTime" }
func (Service1StrvalueWithTime) TLTag() uint32  { return 0x98b1a484 }

func (item *Service1StrvalueWithTime) Reset() {
	item.Value = ""
	item.Flags = 0
	item.ModificationTime = 0
}

func (item *Service1StrvalueWithTime) Read(w []byte) (_ []byte, err error) {
	if w, err = basictl.StringRead(w, &item.Value); err != nil {
		return w, err
	}
	if w, err = basictl.IntRead(w, &item.Flags); err != nil {
		return w, err
	}
	return basictl.IntRead(w, &item.ModificationTime)
}

// This method is general version of Write, use it instead!
func (item *Service1StrvalueWithTime) WriteGeneral(w []byte) (_ []byte, err error) {
	return item.Write(w), nil
}

func (item *Service1StrvalueWithTime) Write(w []byte) []byte {
	w = basictl.StringWrite(w, item.Value)
	w = basictl.IntWrite(w, item.Flags)
	w = basictl.IntWrite(w, item.ModificationTime)
	return w
}

func (item *Service1StrvalueWithTime) ReadBoxed(w []byte) (_ []byte, err error) {
	if w, err = basictl.NatReadExactTag(w, 0x98b1a484); err != nil {
		return w, err
	}
	return item.Read(w)
}

// This method is general version of WriteBoxed, use it instead!
func (item *Service1StrvalueWithTime) WriteBoxedGeneral(w []byte) (_ []byte, err error) {
	return item.WriteBoxed(w), nil
}

func (item *Service1StrvalueWithTime) WriteBoxed(w []byte) []byte {
	w = basictl.NatWrite(w, 0x98b1a484)
	return item.Write(w)
}

func (item Service1StrvalueWithTime) String() string {
	return string(item.WriteJSON(nil))
}

func (item *Service1StrvalueWithTime) ReadJSON(legacyTypeNames bool, in *basictl.JsonLexer) error {
	var propValuePresented bool
	var propFlagsPresented bool
	var propModificationTimePresented bool

	if in != nil {
		in.Delim('{')
		if !in.Ok() {
			return in.Error()
		}
		for !in.IsDelim('}') {
			key := in.UnsafeFieldName(true)
			in.WantColon()
			switch key {
			case "value":
				if propValuePresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("service1.strvalueWithTime", "value")
				}
				if err := internal.Json2ReadString(in, &item.Value); err != nil {
					return err
				}
				propValuePresented = true
			case "flags":
				if propFlagsPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("service1.strvalueWithTime", "flags")
				}
				if err := internal.Json2ReadInt32(in, &item.Flags); err != nil {
					return err
				}
				propFlagsPresented = true
			case "modificationTime":
				if propModificationTimePresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("service1.strvalueWithTime", "modificationTime")
				}
				if err := internal.Json2ReadInt32(in, &item.ModificationTime); err != nil {
					return err
				}
				propModificationTimePresented = true
			default:
				return internal.ErrorInvalidJSONExcessElement("service1.strvalueWithTime", key)
			}
			in.WantComma()
		}
		in.Delim('}')
		if !in.Ok() {
			return in.Error()
		}
	}
	if !propValuePresented {
		item.Value = ""
	}
	if !propFlagsPresented {
		item.Flags = 0
	}
	if !propModificationTimePresented {
		item.ModificationTime = 0
	}
	return nil
}

// This method is general version of WriteJSON, use it instead!
func (item *Service1StrvalueWithTime) WriteJSONGeneral(w []byte) (_ []byte, err error) {
	return item.WriteJSONOpt(true, false, w), nil
}

func (item *Service1StrvalueWithTime) WriteJSON(w []byte) []byte {
	return item.WriteJSONOpt(true, false, w)
}
func (item *Service1StrvalueWithTime) WriteJSONOpt(newTypeNames bool, short bool, w []byte) []byte {
	w = append(w, '{')
	backupIndexValue := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"value":`...)
	w = basictl.JSONWriteString(w, item.Value)
	if (len(item.Value) != 0) == false {
		w = w[:backupIndexValue]
	}
	backupIndexFlags := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"flags":`...)
	w = basictl.JSONWriteInt32(w, item.Flags)
	if (item.Flags != 0) == false {
		w = w[:backupIndexFlags]
	}
	backupIndexModificationTime := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"modificationTime":`...)
	w = basictl.JSONWriteInt32(w, item.ModificationTime)
	if (item.ModificationTime != 0) == false {
		w = w[:backupIndexModificationTime]
	}
	return append(w, '}')
}

func (item *Service1StrvalueWithTime) MarshalJSON() ([]byte, error) {
	return item.WriteJSON(nil), nil
}

func (item *Service1StrvalueWithTime) UnmarshalJSON(b []byte) error {
	if err := item.ReadJSON(true, &basictl.JsonLexer{Data: b}); err != nil {
		return internal.ErrorInvalidJSON("service1.strvalueWithTime", err.Error())
	}
	return nil
}

var _Service1Value = [5]internal.UnionElement{
	{TLTag: 0x1d670b96, TLName: "service1.not_found", TLString: "service1.not_found#1d670b96"},
	{TLTag: 0x5faa0c52, TLName: "service1.strvalue", TLString: "service1.strvalue#5faa0c52"},
	{TLTag: 0x082e0945, TLName: "service1.longvalue", TLString: "service1.longvalue#082e0945"},
	{TLTag: 0x98b1a484, TLName: "service1.strvalueWithTime", TLString: "service1.strvalueWithTime#98b1a484"},
	{TLTag: 0xa04606ec, TLName: "service1.longvalueWithTime", TLString: "service1.longvalueWithTime#a04606ec"},
}

type Service1Value struct {
	valueStrvalue          Service1Strvalue
	valueLongvalue         Service1Longvalue
	valueStrvalueWithTime  Service1StrvalueWithTime
	valueLongvalueWithTime Service1LongvalueWithTime
	index                  int
}

func (item Service1Value) TLName() string { return _Service1Value[item.index].TLName }
func (item Service1Value) TLTag() uint32  { return _Service1Value[item.index].TLTag }

func (item *Service1Value) Reset() { item.index = 0 }

func (item *Service1Value) IsNotFound() bool { return item.index == 0 }

func (item *Service1Value) AsNotFound() (Service1NotFound, bool) {
	var value Service1NotFound
	return value, item.index == 0
}
func (item *Service1Value) ResetToNotFound() { item.index = 0 }
func (item *Service1Value) SetNotFound()     { item.index = 0 }

func (item *Service1Value) IsStrvalue() bool { return item.index == 1 }

func (item *Service1Value) AsStrvalue() (*Service1Strvalue, bool) {
	if item.index != 1 {
		return nil, false
	}
	return &item.valueStrvalue, true
}
func (item *Service1Value) ResetToStrvalue() *Service1Strvalue {
	item.index = 1
	item.valueStrvalue.Reset()
	return &item.valueStrvalue
}
func (item *Service1Value) SetStrvalue(value Service1Strvalue) {
	item.index = 1
	item.valueStrvalue = value
}

func (item *Service1Value) IsLongvalue() bool { return item.index == 2 }

func (item *Service1Value) AsLongvalue() (*Service1Longvalue, bool) {
	if item.index != 2 {
		return nil, false
	}
	return &item.valueLongvalue, true
}
func (item *Service1Value) ResetToLongvalue() *Service1Longvalue {
	item.index = 2
	item.valueLongvalue.Reset()
	return &item.valueLongvalue
}
func (item *Service1Value) SetLongvalue(value Service1Longvalue) {
	item.index = 2
	item.valueLongvalue = value
}

func (item *Service1Value) IsStrvalueWithTime() bool { return item.index == 3 }

func (item *Service1Value) AsStrvalueWithTime() (*Service1StrvalueWithTime, bool) {
	if item.index != 3 {
		return nil, false
	}
	return &item.valueStrvalueWithTime, true
}
func (item *Service1Value) ResetToStrvalueWithTime() *Service1StrvalueWithTime {
	item.index = 3
	item.valueStrvalueWithTime.Reset()
	return &item.valueStrvalueWithTime
}
func (item *Service1Value) SetStrvalueWithTime(value Service1StrvalueWithTime) {
	item.index = 3
	item.valueStrvalueWithTime = value
}

func (item *Service1Value) IsLongvalueWithTime() bool { return item.index == 4 }

func (item *Service1Value) AsLongvalueWithTime() (*Service1LongvalueWithTime, bool) {
	if item.index != 4 {
		return nil, false
	}
	return &item.valueLongvalueWithTime, true
}
func (item *Service1Value) ResetToLongvalueWithTime() *Service1LongvalueWithTime {
	item.index = 4
	item.valueLongvalueWithTime.Reset()
	return &item.valueLongvalueWithTime
}
func (item *Service1Value) SetLongvalueWithTime(value Service1LongvalueWithTime) {
	item.index = 4
	item.valueLongvalueWithTime = value
}

func (item *Service1Value) ReadBoxed(w []byte) (_ []byte, err error) {
	var tag uint32
	if w, err = basictl.NatRead(w, &tag); err != nil {
		return w, err
	}
	switch tag {
	case 0x1d670b96:
		item.index = 0
		return w, nil
	case 0x5faa0c52:
		item.index = 1
		return item.valueStrvalue.Read(w)
	case 0x082e0945:
		item.index = 2
		return item.valueLongvalue.Read(w)
	case 0x98b1a484:
		item.index = 3
		return item.valueStrvalueWithTime.Read(w)
	case 0xa04606ec:
		item.index = 4
		return item.valueLongvalueWithTime.Read(w)
	default:
		return w, internal.ErrorInvalidUnionTag("service1.Value", tag)
	}
}

// This method is general version of WriteBoxed, use it instead!
func (item *Service1Value) WriteBoxedGeneral(w []byte) (_ []byte, err error) {
	return item.WriteBoxed(w), nil
}

func (item *Service1Value) WriteBoxed(w []byte) []byte {
	w = basictl.NatWrite(w, _Service1Value[item.index].TLTag)
	switch item.index {
	case 0:
		return w
	case 1:
		w = item.valueStrvalue.Write(w)
	case 2:
		w = item.valueLongvalue.Write(w)
	case 3:
		w = item.valueStrvalueWithTime.Write(w)
	case 4:
		w = item.valueLongvalueWithTime.Write(w)
	}
	return w
}

func (item *Service1Value) ReadJSON(legacyTypeNames bool, in *basictl.JsonLexer) error {
	_tag, _value, err := internal.Json2ReadUnion("service1.Value", in)
	if err != nil {
		return err
	}
	switch _tag {
	case "service1.not_found#1d670b96", "service1.not_found", "#1d670b96":
		if !legacyTypeNames && _tag == "service1.not_found#1d670b96" {
			return internal.ErrorInvalidUnionLegacyTagJSON("service1.Value", "service1.not_found#1d670b96")
		}
		item.index = 0
	case "service1.strvalue#5faa0c52", "service1.strvalue", "#5faa0c52":
		if !legacyTypeNames && _tag == "service1.strvalue#5faa0c52" {
			return internal.ErrorInvalidUnionLegacyTagJSON("service1.Value", "service1.strvalue#5faa0c52")
		}
		item.index = 1
		var in2Pointer *basictl.JsonLexer
		if _value != nil {
			in2 := basictl.JsonLexer{Data: _value}
			in2Pointer = &in2
		}
		if err := item.valueStrvalue.ReadJSON(legacyTypeNames, in2Pointer); err != nil {
			return err
		}
	case "service1.longvalue#082e0945", "service1.longvalue", "#082e0945":
		if !legacyTypeNames && _tag == "service1.longvalue#082e0945" {
			return internal.ErrorInvalidUnionLegacyTagJSON("service1.Value", "service1.longvalue#082e0945")
		}
		item.index = 2
		var in2Pointer *basictl.JsonLexer
		if _value != nil {
			in2 := basictl.JsonLexer{Data: _value}
			in2Pointer = &in2
		}
		if err := item.valueLongvalue.ReadJSON(legacyTypeNames, in2Pointer); err != nil {
			return err
		}
	case "service1.strvalueWithTime#98b1a484", "service1.strvalueWithTime", "#98b1a484":
		if !legacyTypeNames && _tag == "service1.strvalueWithTime#98b1a484" {
			return internal.ErrorInvalidUnionLegacyTagJSON("service1.Value", "service1.strvalueWithTime#98b1a484")
		}
		item.index = 3
		var in2Pointer *basictl.JsonLexer
		if _value != nil {
			in2 := basictl.JsonLexer{Data: _value}
			in2Pointer = &in2
		}
		if err := item.valueStrvalueWithTime.ReadJSON(legacyTypeNames, in2Pointer); err != nil {
			return err
		}
	case "service1.longvalueWithTime#a04606ec", "service1.longvalueWithTime", "#a04606ec":
		if !legacyTypeNames && _tag == "service1.longvalueWithTime#a04606ec" {
			return internal.ErrorInvalidUnionLegacyTagJSON("service1.Value", "service1.longvalueWithTime#a04606ec")
		}
		item.index = 4
		var in2Pointer *basictl.JsonLexer
		if _value != nil {
			in2 := basictl.JsonLexer{Data: _value}
			in2Pointer = &in2
		}
		if err := item.valueLongvalueWithTime.ReadJSON(legacyTypeNames, in2Pointer); err != nil {
			return err
		}
	default:
		return internal.ErrorInvalidUnionTagJSON("service1.Value", _tag)
	}
	return nil
}

// This method is general version of WriteJSON, use it instead!
func (item *Service1Value) WriteJSONGeneral(w []byte) ([]byte, error) {
	return item.WriteJSONOpt(true, false, w), nil
}

func (item *Service1Value) WriteJSON(w []byte) []byte {
	return item.WriteJSONOpt(true, false, w)
}
func (item *Service1Value) WriteJSONOpt(newTypeNames bool, short bool, w []byte) []byte {
	switch item.index {
	case 0:
		if newTypeNames {
			w = append(w, `{"type":"service1.not_found"`...)
		} else {
			w = append(w, `{"type":"service1.not_found#1d670b96"`...)
		}
		return append(w, '}')
	case 1:
		if newTypeNames {
			w = append(w, `{"type":"service1.strvalue"`...)
		} else {
			w = append(w, `{"type":"service1.strvalue#5faa0c52"`...)
		}
		w = append(w, `,"value":`...)
		w = item.valueStrvalue.WriteJSONOpt(newTypeNames, short, w)
		return append(w, '}')
	case 2:
		if newTypeNames {
			w = append(w, `{"type":"service1.longvalue"`...)
		} else {
			w = append(w, `{"type":"service1.longvalue#082e0945"`...)
		}
		w = append(w, `,"value":`...)
		w = item.valueLongvalue.WriteJSONOpt(newTypeNames, short, w)
		return append(w, '}')
	case 3:
		if newTypeNames {
			w = append(w, `{"type":"service1.strvalueWithTime"`...)
		} else {
			w = append(w, `{"type":"service1.strvalueWithTime#98b1a484"`...)
		}
		w = append(w, `,"value":`...)
		w = item.valueStrvalueWithTime.WriteJSONOpt(newTypeNames, short, w)
		return append(w, '}')
	case 4:
		if newTypeNames {
			w = append(w, `{"type":"service1.longvalueWithTime"`...)
		} else {
			w = append(w, `{"type":"service1.longvalueWithTime#a04606ec"`...)
		}
		w = append(w, `,"value":`...)
		w = item.valueLongvalueWithTime.WriteJSONOpt(newTypeNames, short, w)
		return append(w, '}')
	default: // Impossible due to panic above
		return w
	}
}

func (item Service1Value) String() string {
	return string(item.WriteJSON(nil))
}

func (item *Service1Value) MarshalJSON() ([]byte, error) {
	return item.WriteJSON(nil), nil
}

func (item *Service1Value) UnmarshalJSON(b []byte) error {
	if err := item.ReadJSON(true, &basictl.JsonLexer{Data: b}); err != nil {
		return internal.ErrorInvalidJSON("service1.Value", err.Error())
	}
	return nil
}
