// Copyright 2022 V Kontakte LLC
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Code generated by vktl/cmd/tlgen2; DO NOT EDIT.
package tlService3Product

import (
	"github.com/vkcom/tl/internal/tlcodegen/test/gen/schema/internal"
	"github.com/vkcom/tl/internal/tlcodegen/test/gen/schema/internal/tl/tlBool"
	"github.com/vkcom/tl/internal/tlcodegen/test/gen/schema/internal/tl/tlBuiltinVectorInt"
	"github.com/vkcom/tl/pkg/basictl"
)

var _ = basictl.NatWrite
var _ = internal.ErrorInvalidEnumTag

type Service3Product struct {
	Type           int32
	Id             []int32
	Info           []int32
	Date           int32
	ExpirationDate int32
	Removed        bool // Conditional: nat_mode.0
}

func (Service3Product) TLName() string { return "service3.product" }
func (Service3Product) TLTag() uint32  { return 0x461f4ce2 }

func (item *Service3Product) SetRemoved(v bool, nat_mode *uint32) {
	item.Removed = v
	if nat_mode != nil {
		*nat_mode |= 1 << 0
	}
}
func (item *Service3Product) ClearRemoved(nat_mode *uint32) {
	item.Removed = false
	if nat_mode != nil {
		*nat_mode &^= 1 << 0
	}
}
func (item Service3Product) IsSetRemoved(nat_mode uint32) bool { return nat_mode&(1<<0) != 0 }

func (item *Service3Product) Reset() {
	item.Type = 0
	item.Id = item.Id[:0]
	item.Info = item.Info[:0]
	item.Date = 0
	item.ExpirationDate = 0
	item.Removed = false
}

func (item *Service3Product) Read(w []byte, nat_mode uint32) (_ []byte, err error) {
	if w, err = basictl.IntRead(w, &item.Type); err != nil {
		return w, err
	}
	if w, err = tlBuiltinVectorInt.BuiltinVectorIntRead(w, &item.Id); err != nil {
		return w, err
	}
	if w, err = tlBuiltinVectorInt.BuiltinVectorIntRead(w, &item.Info); err != nil {
		return w, err
	}
	if w, err = basictl.IntRead(w, &item.Date); err != nil {
		return w, err
	}
	if w, err = basictl.IntRead(w, &item.ExpirationDate); err != nil {
		return w, err
	}
	if nat_mode&(1<<0) != 0 {
		if w, err = tlBool.BoolReadBoxed(w, &item.Removed); err != nil {
			return w, err
		}
	} else {
		item.Removed = false
	}
	return w, nil
}

// This method is general version of Write, use it instead!
func (item *Service3Product) WriteGeneral(w []byte, nat_mode uint32) (_ []byte, err error) {
	return item.Write(w, nat_mode), nil
}

func (item *Service3Product) Write(w []byte, nat_mode uint32) []byte {
	w = basictl.IntWrite(w, item.Type)
	w = tlBuiltinVectorInt.BuiltinVectorIntWrite(w, item.Id)
	w = tlBuiltinVectorInt.BuiltinVectorIntWrite(w, item.Info)
	w = basictl.IntWrite(w, item.Date)
	w = basictl.IntWrite(w, item.ExpirationDate)
	if nat_mode&(1<<0) != 0 {
		w = tlBool.BoolWriteBoxed(w, item.Removed)
	}
	return w
}

func (item *Service3Product) ReadBoxed(w []byte, nat_mode uint32) (_ []byte, err error) {
	if w, err = basictl.NatReadExactTag(w, 0x461f4ce2); err != nil {
		return w, err
	}
	return item.Read(w, nat_mode)
}

// This method is general version of WriteBoxed, use it instead!
func (item *Service3Product) WriteBoxedGeneral(w []byte, nat_mode uint32) (_ []byte, err error) {
	return item.WriteBoxed(w, nat_mode), nil
}

func (item *Service3Product) WriteBoxed(w []byte, nat_mode uint32) []byte {
	w = basictl.NatWrite(w, 0x461f4ce2)
	return item.Write(w, nat_mode)
}

func (item *Service3Product) ReadJSON(legacyTypeNames bool, in *basictl.JsonLexer, nat_mode uint32) error {
	var propTypePresented bool
	var propIdPresented bool
	var propInfoPresented bool
	var propDatePresented bool
	var propExpirationDatePresented bool
	var propRemovedPresented bool

	if in != nil {
		in.Delim('{')
		if !in.Ok() {
			return in.Error()
		}
		for !in.IsDelim('}') {
			key := in.UnsafeFieldName(true)
			in.WantColon()
			switch key {
			case "type":
				if propTypePresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("service3.product", "type")
				}
				if err := internal.Json2ReadInt32(in, &item.Type); err != nil {
					return err
				}
				propTypePresented = true
			case "id":
				if propIdPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("service3.product", "id")
				}
				if err := tlBuiltinVectorInt.BuiltinVectorIntReadJSON(legacyTypeNames, in, &item.Id); err != nil {
					return err
				}
				propIdPresented = true
			case "info":
				if propInfoPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("service3.product", "info")
				}
				if err := tlBuiltinVectorInt.BuiltinVectorIntReadJSON(legacyTypeNames, in, &item.Info); err != nil {
					return err
				}
				propInfoPresented = true
			case "date":
				if propDatePresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("service3.product", "date")
				}
				if err := internal.Json2ReadInt32(in, &item.Date); err != nil {
					return err
				}
				propDatePresented = true
			case "expiration_date":
				if propExpirationDatePresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("service3.product", "expiration_date")
				}
				if err := internal.Json2ReadInt32(in, &item.ExpirationDate); err != nil {
					return err
				}
				propExpirationDatePresented = true
			case "removed":
				if propRemovedPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("service3.product", "removed")
				}
				if nat_mode&(1<<0) == 0 {
					return internal.ErrorInvalidJSON("service3.product", "field 'removed' is defined, while corresponding implicit fieldmask bit is 0")
				}
				if err := internal.Json2ReadBool(in, &item.Removed); err != nil {
					return err
				}
				propRemovedPresented = true
			default:
				return internal.ErrorInvalidJSONExcessElement("service3.product", key)
			}
			in.WantComma()
		}
		in.Delim('}')
		if !in.Ok() {
			return in.Error()
		}
	}
	if !propTypePresented {
		item.Type = 0
	}
	if !propIdPresented {
		item.Id = item.Id[:0]
	}
	if !propInfoPresented {
		item.Info = item.Info[:0]
	}
	if !propDatePresented {
		item.Date = 0
	}
	if !propExpirationDatePresented {
		item.ExpirationDate = 0
	}
	if !propRemovedPresented {
		item.Removed = false
	}
	return nil
}

// This method is general version of WriteJSON, use it instead!
func (item *Service3Product) WriteJSONGeneral(w []byte, nat_mode uint32) (_ []byte, err error) {
	return item.WriteJSONOpt(true, false, w, nat_mode), nil
}

func (item *Service3Product) WriteJSON(w []byte, nat_mode uint32) []byte {
	return item.WriteJSONOpt(true, false, w, nat_mode)
}
func (item *Service3Product) WriteJSONOpt(newTypeNames bool, short bool, w []byte, nat_mode uint32) []byte {
	w = append(w, '{')
	backupIndexType := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"type":`...)
	w = basictl.JSONWriteInt32(w, item.Type)
	if (item.Type != 0) == false {
		w = w[:backupIndexType]
	}
	backupIndexId := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"id":`...)
	w = tlBuiltinVectorInt.BuiltinVectorIntWriteJSONOpt(newTypeNames, short, w, item.Id)
	if (len(item.Id) != 0) == false {
		w = w[:backupIndexId]
	}
	backupIndexInfo := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"info":`...)
	w = tlBuiltinVectorInt.BuiltinVectorIntWriteJSONOpt(newTypeNames, short, w, item.Info)
	if (len(item.Info) != 0) == false {
		w = w[:backupIndexInfo]
	}
	backupIndexDate := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"date":`...)
	w = basictl.JSONWriteInt32(w, item.Date)
	if (item.Date != 0) == false {
		w = w[:backupIndexDate]
	}
	backupIndexExpirationDate := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"expiration_date":`...)
	w = basictl.JSONWriteInt32(w, item.ExpirationDate)
	if (item.ExpirationDate != 0) == false {
		w = w[:backupIndexExpirationDate]
	}
	if nat_mode&(1<<0) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"removed":`...)
		w = basictl.JSONWriteBool(w, item.Removed)
	}
	return append(w, '}')
}
