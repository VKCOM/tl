// Copyright 2022 V Kontakte LLC
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package tlcodegen

import (
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"
	"runtime/debug"
	"sort"
	"strconv"
	"strings"
	"sync/atomic"
	"time"

	"github.com/TwiN/go-color"
	"github.com/google/go-cmp/cmp"
	"github.com/vkcom/tl/internal/tlast"

	"golang.org/x/exp/slices"
)

const BuiltinTupleName = "__tuple"
const BuiltinVectorName = "__vector"
const BasicTLGoPackageName = "basictl" // does not contain tl prefix
const FactoryGoPackageName = "factory" // does not contain tl prefix
const FactoryGoPackageNameBytes = "factory_bytes"
const MetaGoPackageName = "meta" // does not contain tl prefix
const ConstantsPackageName = "constants"
const BasicTLCPPNamespaceName = "basictl" // does not contain tl prefix
const HeaderComment = "// Code generated by vktl/cmd/tlgen2; DO NOT EDIT."
const markerFile = "tlgen2_version.txt"
const EnableWarningsUnionNamespace = true
const EnableWarningsUnionNamePrefix = true
const EnableWarningsUnionNameExact = true
const EnableWarningsSimpleTypeName = true

const (
	goExt  = ".go"
	cppExt = ".cpp"
	hppExt = ".hpp"
)

const TlJSONHTML = "tljson.html"

const buildVersionFormat = `tlgen version: %s
schema url: %s
schema commit: %s
schema version: %d (%v)
`

var (
	errSeeHere                = fmt.Errorf("see here")
	errFieldNameCollision     = fmt.Errorf("field name collision")
	errNatParamNameCollision  = fmt.Errorf("nat-parametr name collision")
	errTypeParamNameCollision = fmt.Errorf("type-parametr name collision ")
)

type LocalResolveContext struct {
	localTypeArgs map[string]LocalTypeArg
	localNatArgs  map[string]LocalNatArg

	allowAnyConstructor bool   // we can reference all constructors (functions, union elements) directly internally
	overrideFileName    string // used for unions and built-in vectors and tuples, so they are defined in the file of argument
}

func TLGenVersion() string {
	if info, ok := debug.ReadBuildInfo(); ok {
		return info.Main.Version
	}
	return ""
}

// checkArgsCollision checks if passed name is already used in local context.
// pr: PR of the name we want to check
// err: will be returned (wrapped in beautiful error) if collision was NOT in type-parameter,
// must be defined depending on call context
func (lrc *LocalResolveContext) checkArgsCollision(name string, pr tlast.PositionRange, err error) error {
	if nat, ok := lrc.localNatArgs[name]; ok {
		e1 := pr.BeautifulError(err)
		e2 := nat.NamePR.BeautifulError(errSeeHere)
		return tlast.BeautifulError2(e1, e2)
	}
	if typ, ok := lrc.localTypeArgs[name]; ok {
		e1 := pr.BeautifulError(errTypeParamNameCollision)
		e2 := typ.PR.BeautifulError(errSeeHere)
		return tlast.BeautifulError2(e1, e2)
	}
	return nil
}

type LocalNatArg struct {
	wrongTypeErr error // we must add all field names to local context, because they must correctly shadow names outside, but we check the type

	NamePR tlast.PositionRange
	TypePR tlast.PositionRange
	natArg ActualNatArg
}

type LocalTypeArg struct {
	arg     ResolvedArgument
	PR      tlast.PositionRange // original template arg reference
	natArgs []ActualNatArg      // nat args associated with this type argument, if type argument itself has some nat args
}

type ResolvedArgument struct {
	isNat   bool
	isArith bool
	Arith   tlast.Arithmetic
	tip     *TypeRWWrapper
	bare    bool // vector Int is not the same as vector int, we must capture the difference somewhere
}

type ActualNatArg struct {
	isArith    bool
	Arith      tlast.Arithmetic
	isField    bool // otherwise it is # param with name
	FieldIndex int
	name       string // param name
}

type HalfResolvedArgument struct { // TODO - better name
	Name string                 // if empty, this is not argument position
	Args []HalfResolvedArgument // recursion
}

type InternalNamespace struct {
	DebugID      int   // for identification in logs
	FloodCounter int64 // beware!

	Namespaces    map[string]struct{}
	DirectImports *DirectImports
	Types         []*TypeRWWrapper

	SubPath string
	Name    string
}

func (n *InternalNamespace) Prefix(directImports *DirectImports, in *InternalNamespace) string {
	if n == in {
		return ""
	}
	directImports.ns[n] = struct{}{}
	return n.Name + "."
}

func (n *InternalNamespace) ImportsSingleNamedNamespace() (empty bool, name string) {
	for nn := range n.Namespaces {
		if nn == "" {
			empty = true
			continue
		}
		if name != "" {
			return empty, ""
		}
		name = nn
	}
	return empty, name
}

var floodCounter atomic.Int64 // TODO - move somewhere

func (n *InternalNamespace) FindRecursiveImports(ri map[*InternalNamespace][]*InternalNamespace, replace *InternalNamespace) {
	for k := range ri {
		delete(ri, k)
	}
	fc := floodCounter.Add(1)
	for k := range n.DirectImports.ns {
		if k != replace {
			k.findRecursiveImports(fc, n, ri, replace, n)
		}
	}
	if replace != nil {
		for k := range replace.DirectImports.ns {
			if k != n {
				k.findRecursiveImports(fc, n, ri, replace, n)
			}
		}
	}
}

func (n *InternalNamespace) findRecursiveImports(floodCounter int64, parent *InternalNamespace, ri map[*InternalNamespace][]*InternalNamespace, replace *InternalNamespace, with *InternalNamespace) {
	if n.FloodCounter >= floodCounter {
		return // visited already
	}
	n.FloodCounter = floodCounter
	ri[n] = append(ri[n], parent)
	for k := range n.DirectImports.ns {
		kk := k.replace(replace, with)
		kk.findRecursiveImports(floodCounter, n, ri, replace, with)
	}
}

func (n InternalNamespace) String() string {
	var s strings.Builder
	s.WriteString(fmt.Sprintf("id %d types: ", n.DebugID))
	s.WriteString(strings.Join(n.sortedElements(), ":"))
	s.WriteString("\nnamespaces: ")
	s.WriteString(strings.Join(n.sortedNamespaces(), ","))
	s.WriteString(fmt.Sprintf(" fc=%d\ndirect: ", n.FloodCounter))
	s.WriteString(strings.Join(n.sortedDirectElements(), ","))
	s.WriteString("\nrecursive: ")
	s.WriteString(strings.Join(n.sortedRecursiveElements(), ","))
	s.WriteString("\n")
	return s.String()
}

func (n *InternalNamespace) replace(replace *InternalNamespace, with *InternalNamespace) *InternalNamespace {
	if n == replace {
		return with
	}
	return n
}

// do not forget to remove from []*InternalNamespace after call
func (n *InternalNamespace) mergeFrom(from *InternalNamespace, internalNamespaces []*InternalNamespace) {
	into := n
	for _, t := range from.Types {
		into.Types = append(into.Types, t)
		t.ins = into
	}
	for nn := range from.Namespaces {
		n.Namespaces[nn] = struct{}{}
	}
	for nn := range from.DirectImports.ns {
		if nn != into {
			into.DirectImports.ns[nn] = struct{}{}
		}
	}
	into.DirectImports.importSort = into.DirectImports.importSort || from.DirectImports.importSort
	for _, ins := range internalNamespaces {
		if _, ok := ins.DirectImports.ns[from]; ok {
			if ins != into {
				ins.DirectImports.ns[into] = struct{}{}
			}
			// for k2 := range n.DirectImports {
			//	ins.DirectImports[k2] = struct{}{}
			// }
			delete(ins.DirectImports.ns, from)
		}
	}
}

func (n *InternalNamespace) sortedElements() []string {
	var elements []string
	for _, t := range n.Types {
		elements = append(elements, t.goGlobalName) // TODO - change to tlName.String() and fix problems
	}
	slices.Sort(elements)
	return elements
}

func (n *InternalNamespace) sortedRecursiveElements() []string {
	var elements []string
	ri := map[*InternalNamespace][]*InternalNamespace{}
	n.FindRecursiveImports(ri, nil)
	for r := range ri {
		var inside []string
		for _, t := range r.Types {
			inside = append(inside, t.goGlobalName)
		}
		slices.Sort(inside)
		elements = append(elements, strings.Join(inside, ":"))
	}
	slices.Sort(elements)
	return elements
}

func (n *InternalNamespace) sortedDirectElements() []string {
	var elements []string
	for r := range n.DirectImports.ns {
		var inside []string
		for _, t := range r.Types {
			inside = append(inside, t.goGlobalName)
		}
		slices.Sort(inside)
		elements = append(elements, strings.Join(inside, ":"))
	}
	slices.Sort(elements)
	return elements
}

func (n *InternalNamespace) sortedNamespaces() []string {
	var elements []string
	for n := range n.Namespaces {
		elements = append(elements, n)
	}
	slices.Sort(elements)
	return elements
}

type Namespace struct {
	types        []*TypeRWWrapper
	cppTemplates map[string]*TypeRWWrapper // canonical C++ template names like cross, cross<I,J>, cross<i>, cross<J> to avoid duplicates
	decGo        Deconflicter
	decCpp       Deconflicter
}

type Gen2Options struct {
	// General
	Language          string
	Outdir            string
	CopyrightFilePath string
	WarningsAreErrors bool
	Verbose           bool
	PrintDiff         bool
	ErrorWriter       io.Writer // all Errors and warnings should be redirected to this io.Writer, by default it is os.Stderr
	SplitInternal     bool

	// Linter
	Mode           string
	Schema2Compare string

	// Go
	BasicPackageNameFull   string // if empty, will be created
	TLPackageNameFull      string
	GenerateRPCCode        bool
	BasicRPCPath           string
	BytesVersions          string
	TypesWhileList         string
	GenerateRandomCode     bool
	GenerateLegacyJsonRead bool
	SchemaDocumentation    bool
	SchemaURL              string
	SchemaTimestamp        uint // for TLO version/date
	SchemaCommit           string

	// C++
	RootCPPNamespace string
	SeparateFiles    bool

	// PHP
	AddFunctionBodies            bool
	AddMetaData                  bool
	AddFactoryData               bool
	IgnoreUnusedInFunctionsTypes bool
	AddRPCTypes                  bool
	InplaceSimpleStructs         bool

	// .tlo
	TLOPath           string
	CanonicalFormPath string // combinators in canonical form, with comment of source schema file path
}

type Gen2 struct {
	// options
	options *Gen2Options // pointer so code modifying options in GenerateCode refers to the same structure

	// artifacts
	RootPackageName string

	// golang specific
	BasicPackageNameFull string // basic types are in separate namespace to minimize conflicts
	GlobalPackageName    string // we generate all go types in this package, because we need circular dependencies
	FactoryPackageName   string
	MetaPackageName      string

	// c++ specific
	RootCPPNamespaceElements    []string
	DetailsCPPNamespaceElements []string
	DetailsCPPNamespace         string // basictl::details

	// parsed TL
	supportedAnnotations map[string]int
	typeDescriptors      map[string][]*tlast.Combinator
	singleConstructors   map[string]*tlast.Combinator // only types with 1 constructor, no functions
	allConstructors      map[string]*tlast.Combinator // for printing beautiful errors
	allAnnotations       []string                     // position is bit

	// generation
	builtinTypes       map[string]*TypeRWWrapper
	generatedTypes     map[string]*TypeRWWrapper
	generatedTypesList []*TypeRWWrapper // we need more deterministic order than sort predicate can establish

	globalDec  Deconflicter
	Namespaces map[string]*Namespace // Handlers Code is inside

	// result
	TLO           []byte            // schema represented in tlo format, described using tls.* combinator
	Code          map[string]string // fileName->Content, split by file names relative to output dir
	copyrightText string

	// new options
	typesInfo       *TypesInfo
	componentsOrder []int
}

func doLint(commentRight string) bool {
	if len(commentRight) < 2 {
		return true
	}
	for _, f := range strings.Fields(commentRight[2:]) {
		if f == "tlgen:nolint" {
			return false
		}
	}
	return true
}

func (gen *Gen2) InternalPrefix() string {
	if gen.options.SplitInternal {
		return "internal."
	}
	return ""
}

func canonicalGoName(name tlast.Name, insideNamespace string) string {
	if name.Namespace == insideNamespace {
		return CNameToCamelName(name.Name)
	}
	return CNameToCamelName(name.Namespace) + CNameToCamelName(name.Name)
}

func (gen *Gen2) getNamespace(n string) *Namespace {
	na, ok := gen.Namespaces[n]
	if !ok {
		na = &Namespace{cppTemplates: map[string]*TypeRWWrapper{}}
		gen.Namespaces[n] = na
		// TODO - ALL golang-specific names
		na.decGo.deconflictName("Handler")
		na.decGo.deconflictName("Handle")
		na.decGo.deconflictName("Client")
		// TODO - if we want lowercase C++ identifiers, we need to add ~100 reserved keywords here
		// na.decCpp.deconflictName("double")
		// na.decCpp.deconflictName("int")
		// etc...
	}
	return na
}

func CheckBackwardCompatibility(newTL, oldTL *tlast.TL) *tlast.ParseError {
	newTypes, _ := extractTypes(newTL)
	oldTypes, oldOrder := extractTypes(oldTL)
	for _, typeName := range oldOrder {
		oldCombinators := oldTypes[typeName]
		newCombinators := newTypes[typeName]

		constructorToCombinator := make(map[tlast.Name]*tlast.Combinator)
		for _, constructor := range newCombinators {
			constructorToCombinator[constructor.Construct.Name] = constructor
		}

		for _, constructor := range oldCombinators {
			newConstructor := constructorToCombinator[constructor.Construct.Name]
			if newConstructor == nil {
				return &tlast.ParseError{
					Err: fmt.Errorf("this constructor can't be removed"),
					Pos: constructor.Construct.NamePR,
				}
			} else {
				if err := checkCombinatorsBackwardCompatibility(newConstructor, constructor); err.Err != nil {
					return &err
				}
			}
		}

		// some type "evolve" to union, then we must check it's used everywhere boxed (redundant due to another check before)
		if len(oldCombinators) == 1 && len(newCombinators) > 1 {
			combinator := oldCombinators[0]

			var checkBoxUsage func(tlast.TypeRef) tlast.ParseError
			checkBoxUsage = func(ref tlast.TypeRef) tlast.ParseError {
				// check that type used in boxed version
				if ref.Type == combinator.TypeDecl.Name {
					if ref.Bare {
						return tlast.ParseError{
							Err: fmt.Errorf("type \"%s\" can't change to union type due to backward compaibilty and its bare usage here", combinator.TypeDecl.Name),
							Pos: ref.PR,
						}
					}
				}
				if ref.Type == combinator.Construct.Name {
					return tlast.ParseError{
						Err: fmt.Errorf("type \"%s\" can't change to union type due to backward compaibilty and its usage by constructor here", combinator.TypeDecl.Name),
						Pos: ref.PR,
					}
				}
				for _, arg := range ref.Args {
					if !arg.IsArith {
						return checkBoxUsage(arg.T)
					}
				}
				return tlast.ParseError{}
			}

			if err := checkAllTypeRefs(oldTL, checkBoxUsage); err.Err != nil {
				return &err
			}
		}
	}
	return &tlast.ParseError{}
}

func extractTypes(tl *tlast.TL) (types map[tlast.Name][]*tlast.Combinator, order []tlast.Name) {
	types = make(map[tlast.Name][]*tlast.Combinator)
	for _, combinator := range *tl {
		if !combinator.IsFunction && !combinator.Builtin {
			name := combinator.TypeDecl.Name
			if types[name] == nil {
				order = append(order, name)
			}
			types[name] = append(types[name], combinator)
		}
	}
	return
}

func checkAllTypeRefs(allCombinators *tlast.TL, checkFunc func(ref tlast.TypeRef) tlast.ParseError) tlast.ParseError {
	for _, combinator := range *allCombinators {
		if err := checkFunc(combinator.FuncDecl); err.Err != nil {
			return err
		}
		for _, field := range combinator.Fields {
			if err := checkFunc(field.FieldType); err.Err != nil {
				return err
			}
		}
	}
	return tlast.ParseError{}
}

func checkCombinatorsBackwardCompatibility(newCombinator, oldCombinator *tlast.Combinator) tlast.ParseError {
	if len(newCombinator.Fields) < len(oldCombinator.Fields) {
		return *tlast.BeautifulError2(
			&tlast.ParseError{
				Err: fmt.Errorf("new version of combinator can't have less fields"),
				Pos: newCombinator.TypeDecl.NamePR,
			},
			&tlast.ParseError{
				Err: fmt.Errorf("missing fields"),
				Pos: tlast.PositionRange{
					Begin: oldCombinator.Fields[len(newCombinator.Fields)].PRName.Begin,
					End:   oldCombinator.Fields[len(oldCombinator.Fields)-1].PR.End,
					Outer: oldCombinator.PR.Outer,
				},
			})
	}

	if len(newCombinator.TemplateArguments) < len(oldCombinator.TemplateArguments) {
		return *tlast.BeautifulError2(
			&tlast.ParseError{
				Err: fmt.Errorf("new version of combinator can't have less template arguments"),
				Pos: newCombinator.TemplateArgumentsPR,
			},
			&tlast.ParseError{
				Err: fmt.Errorf("missing template arguments"),
				Pos: tlast.PositionRange{
					Begin: oldCombinator.TemplateArguments[len(newCombinator.TemplateArguments)].PR.Begin,
					End:   oldCombinator.TemplateArguments[len(oldCombinator.TemplateArguments)-1].PR.End,
					Outer: oldCombinator.PR.Outer,
				},
			})
	}

	//extractName := func(name string, mapping *map[string]int, combinator *tlast.Combinator) (bool, string) {
	//	index, ok := (*mapping)[name]
	//	if !ok {
	//		return false, ""
	//	}
	//	if index >= 0 {
	//		return true, combinator.Fields[index].FieldName
	//	} else {
	//		return true, combinator.TemplateArguments[len(combinator.TemplateArguments)+index].FieldName
	//	}
	//}

	fillMapping := func(mapping *map[string]int, combinator *tlast.Combinator) {
		for i, field := range combinator.Fields {
			(*mapping)[field.FieldName] = i
		}
		for i, arg := range combinator.TemplateArguments {
			(*mapping)[arg.FieldName] = -len(combinator.TemplateArguments) + i
		}
	}

	oldMapping := make(map[string]int)
	newMapping := make(map[string]int)

	fillMapping(&oldMapping, oldCombinator)
	fillMapping(&newMapping, newCombinator)

	var compareTypes func(newType, oldType *tlast.TypeRef) *tlast.ParseError
	compareTypes = func(newType, oldType *tlast.TypeRef) *tlast.ParseError {
		newIndex, newOk := newMapping[newType.Type.String()]
		oldIndex, oldOk := oldMapping[oldType.Type.String()]

		// TODO: maybe accept shuffle of template arguments
		if (newOk && !oldOk) || // argument starts referencing smth in type, but wasn't before
			(!newOk && oldOk) || // argument was referencing smth in type, but ended to do this
			(newOk && oldOk && newIndex != oldIndex) ||
			(!newOk && !oldOk && newType.Type != oldType.Type) {
			return tlast.BeautifulError2(
				&tlast.ParseError{
					Err: fmt.Errorf("this reference changed to different source in compare with original"),
					Pos: newType.PR,
				},
				&tlast.ParseError{
					Err: fmt.Errorf("original source"),
					Pos: oldType.PR,
				},
			)
		}

		return nil
	}

	for i, oldField := range oldCombinator.Fields {
		newField := newCombinator.Fields[i]
		if compErr := compareTypes(&newField.FieldType, &oldField.FieldType); compErr != nil {
			return *compErr
		}

		if (newField.Mask == nil) != (oldField.Mask == nil) {
			if newField.Mask != nil {
				return *tlast.BeautifulError2(
					&tlast.ParseError{
						Err: fmt.Errorf("you can't add fieldmask to a field if it wasn't before"),
						Pos: newField.Mask.PRName,
					},
					&tlast.ParseError{
						Err: fmt.Errorf("original field without fieldmask"),
						Pos: oldField.PRName,
					},
				)
			} else if oldField.Mask != nil {
				return *tlast.BeautifulError2(
					&tlast.ParseError{
						Err: fmt.Errorf("you can't remove fieldmask to a field if it was before"),
						Pos: newField.PRName,
					},
					&tlast.ParseError{
						Err: fmt.Errorf("original fieldmask"),
						Pos: oldField.Mask.PRName,
					},
				)
			}
		} else if newField.Mask != nil {
			newIndex, _ := newMapping[newField.Mask.MaskName]
			oldIndex, _ := oldMapping[oldField.Mask.MaskName]

			if newIndex != oldIndex {
				return *tlast.BeautifulError2(
					&tlast.ParseError{
						Err: fmt.Errorf("can't change reference used as a fieldmask"),
						Pos: newField.Mask.PRName,
					},
					&tlast.ParseError{
						Err: fmt.Errorf("original fieldmask"),
						Pos: oldField.Mask.PRName,
					},
				)
			}

			if newField.Mask.BitNumber != oldField.Mask.BitNumber {
				return *tlast.BeautifulError2(
					&tlast.ParseError{
						Err: fmt.Errorf("can't bit in fieldmask"),
						Pos: newField.Mask.PRBits,
					},
					&tlast.ParseError{
						Err: fmt.Errorf("original bit in fieldmask"),
						Pos: oldField.Mask.PRBits,
					},
				)
			}
		}
	}

	for i := len(oldCombinator.Fields); i < len(newCombinator.Fields); i++ {
		newField := newCombinator.Fields[i]
		if newField.Mask == nil {
			return tlast.ParseError{
				Err: fmt.Errorf("new fields must have field mask due to backward compaibilty"),
				Pos: newField.PR,
			}
		}
	}
	return tlast.ParseError{}
}

func checkTagCollisions(tl tlast.TL) error {
	constructorTags := map[uint32]*tlast.Combinator{}
	for _, typ := range tl {
		crc32 := typ.Crc32()
		if crc32 == 0 {
			// typeA#00000000 = TypeA;
			return typ.Construct.IDPR.BeautifulError(fmt.Errorf("constructor tag 0 is prohibited, even if generated implicitly"))
		}
		if col, ok := constructorTags[crc32]; ok {
			// typeA#dfc15abf = TypeA;
			// typeB#dfc15abf = TypeB;
			e1 := typ.Construct.IDPR.BeautifulError(fmt.Errorf("constructor tag #%08x used by %q is used again by %q", crc32, col.Construct.Name.String(), typ.Construct.Name.String()))
			e2 := col.Construct.IDPR.BeautifulError(errSeeHere)
			return tlast.BeautifulError2(e1, e2)
		}
		constructorTags[crc32] = typ
	}
	return nil
}

func checkNamespaceCollisions(tl tlast.TL) error {
	namespaces := map[string]struct {
		s  string
		pr tlast.PositionRange
	}{}
	for _, typ := range tl {
		ns := strings.ToLower(typ.Construct.Name.Namespace)
		if col, ok := namespaces[ns]; ok && col.s != typ.Construct.Name.Namespace {
			e1 := typ.Construct.NamePR.BeautifulError(fmt.Errorf("namespaces must not differ by only case"))
			e2 := col.pr.BeautifulError(errSeeHere)
			return tlast.BeautifulError2(e1, e2)
		}
		namespaces[ns] = struct {
			s  string
			pr tlast.PositionRange
		}{typ.Construct.Name.Namespace, typ.Construct.NamePR}
		ns = strings.ToLower(typ.TypeDecl.Name.Namespace)
		if col, ok := namespaces[ns]; ok && col.s != typ.TypeDecl.Name.Namespace {
			e1 := typ.TypeDecl.NamePR.BeautifulError(fmt.Errorf("namespaces must not differ by only case"))
			e2 := col.pr.BeautifulError(errSeeHere)
			return tlast.BeautifulError2(e1, e2)
		}
		namespaces[ns] = struct {
			s  string
			pr tlast.PositionRange
		}{typ.TypeDecl.Name.Namespace, typ.TypeDecl.NamePR}
	}
	return nil
}

func (gen *Gen2) buildMapDescriptors(tl tlast.TL) error {
	// Collect unions, check that functions cannot form a union with each other or with normal singleConstructors
	for _, typ := range tl {
		for _, f := range typ.Fields {
			if f.FieldName == "" && (len(typ.Fields) != 1 || f.Mask != nil) {
				return f.PR.BeautifulError(fmt.Errorf("anonymous fields are discouraged, except when used in '# a:[int]' pattern or when type has single anonymous field without fieldmask (typedef-like)"))
			}
		}
		conName := typ.Construct.Name.String()
		if col, ok := gen.allConstructors[conName]; ok {
			// typeA = TypeA;
			// typeA = TypeB;
			e1 := typ.Construct.NamePR.BeautifulError(fmt.Errorf("constructor name %q is used again here", conName))
			e2 := col.Construct.NamePR.BeautifulError(errSeeHere)
			return tlast.BeautifulError2(e1, e2)
		}
		gen.allConstructors[conName] = typ
		if !typ.IsFunction {
			typeName := typ.TypeDecl.Name.String()
			if len(typ.TemplateArguments) > len(typ.TypeDecl.Arguments) {
				// rightLeftArgs {X:Type} {Y:#} = RightLeftArgs X; <- bad
				arg := typ.TemplateArguments[len(typ.TypeDecl.Arguments)]
				return typ.TypeDecl.PR.CollapseToEnd().BeautifulError(fmt.Errorf("type declaration %q is missing template argument %q here", typeName, arg.FieldName))
			}
			if len(typ.TemplateArguments) < len(typ.TypeDecl.Arguments) {
				// rightLeftArgs {X:Type} {Y:#} = RightLeftArgs X Y Y; <- bad
				arg := typ.TypeDecl.Arguments[len(typ.TemplateArguments)]
				pr := typ.TypeDecl.ArgumentsPR[len(typ.TemplateArguments)]
				return pr.BeautifulError(fmt.Errorf("type declaration %q has excess template argument %q here", typeName, arg))
			}
			for j, t := range typ.TemplateArguments {
				if t.FieldName != typ.TypeDecl.Arguments[j] {
					// rightLeftArgs {X:Type} {Y:#} = RightLeftArgs Y X;   <- bad
					pr := typ.TypeDecl.ArgumentsPR[j]
					typArg := typ.TypeDecl.Arguments[j]
					e1 := pr.BeautifulError(fmt.Errorf("type declaration %q has wrong template argument name %q here", typeName, typArg))
					e2 := t.PR.BeautifulError(errSeeHere)
					return tlast.BeautifulError2(e1, e2)
				}
			}
			if typeName != "_" { // prohibit boxed type
				gen.typeDescriptors[typeName] = append(gen.typeDescriptors[typeName], typ)
			}
		} else {
			for _, t := range typ.TemplateArguments {
				if t.IsNat {
					// @read funWithArg {fields_mask: #} => True;
					return t.PR.BeautifulError(fmt.Errorf("function declaration %q cannot have template arguments", conName))
				}
				// TODO - sort out things with rpc wrapping later which has a form
				// @readwrite tree_stats.preferMaster {X:Type} query:!X = X;
			}
			if len(typ.Modifiers) == 0 && doLint(typ.CommentRight) {
				e1 := typ.Construct.NamePR.CollapseToBegin().BeautifulError(fmt.Errorf("function constructor %q without modifier (identifier starting with '@') not recommended", typ.Construct.Name.String()))
				if gen.options.WarningsAreErrors {
					return e1
				}
				e1.PrintWarning(gen.options.ErrorWriter, nil)
			}
		}
	}
	for _, typ := range gen.typeDescriptors {
		if len(typ) == 1 { // here there is no functions
			cName := typ[0].Construct.Name
			tName := typ[0].TypeDecl.Name
			typePrefix := strings.ToLower(ToLowerFirst(tName.Name))

			if cName.Namespace != tName.Namespace {
				e1 := typ[0].Construct.NamePR.BeautifulError(fmt.Errorf("simple type constructor namespace should exactly match type namespace"))
				e2 := typ[0].TypeDecl.NamePR.BeautifulError(errSeeHere)
				return tlast.BeautifulError2(e1, e2)
			}
			// We temporarily allow relaxed case match. To use strict match, remove strings.ToLower() calls below
			if EnableWarningsSimpleTypeName && strings.ToLower(cName.Name) != typePrefix &&
				!LegacyEnableWarningsSimpleTypeNameSkip(cName.String()) && doLint(typ[0].CommentRight) {
				e1 := typ[0].Construct.NamePR.BeautifulError(fmt.Errorf("simple type constructor name should differ from type name by case only"))
				e2 := typ[0].TypeDecl.NamePR.BeautifulError(errSeeHere)
				if gen.options.WarningsAreErrors {
					return tlast.BeautifulError2(e1, e2)
				}
				tlast.BeautifulError2(e1, e2).PrintWarning(gen.options.ErrorWriter, nil)
			}
			conName := cName.String()
			if col, ok := gen.singleConstructors[conName]; ok {
				e1 := typ[0].Construct.NamePR.BeautifulError(fmt.Errorf("constructor name %q is used again here", conName))
				e2 := col.Construct.NamePR.BeautifulError(errSeeHere)
				// TODO: not sure that this code ever runs, as we have same check on gen.allConstructors
				//       in Gen2.buildMapDescriptors method
				//       use panic to catch such case, remove it later
				err := tlast.BeautifulError2(e1, e2)
				var s strings.Builder
				err.ConsolePrint(&s, err, false)
				panic(s.String())
				// return tlast.BeautifulError2(e1, e2)
			}
			gen.singleConstructors[conName] = typ[0]
			continue
		}
		if err := checkUnionElementsCompatibility(typ, gen.options); err != nil {
			return err
		}
	}
	return nil
}

func checkUnionElementsCompatibility(types []*tlast.Combinator, options *Gen2Options) error {
	// We temporarily allow relaxed case match. To use strict match, remove strings.ToLower() calls below
	typePrefix := strings.ToLower(ToLowerFirst(types[0].TypeDecl.Name.Name))
	typeSuffix := strings.ToLower(types[0].TypeDecl.Name.Name)
	for _, typ := range types {
		conName := strings.ToLower(typ.Construct.Name.Name)
		if EnableWarningsUnionNamespace && typ.Construct.Name.Namespace != typ.TypeDecl.Name.Namespace &&
			!LegacyEnableWarningsUnionNamespaceSkip(typ.Construct.Name.Namespace, typ.TypeDecl.Name.Namespace) &&
			doLint(typ.CommentRight) {
			e1 := typ.Construct.NamePR.BeautifulError(fmt.Errorf("union constructor namespace %q should match type namespace %q", typ.Construct.Name.Namespace, typ.TypeDecl.Name.Namespace))
			e2 := typ.TypeDecl.NamePR.BeautifulError(errSeeHere)
			if options.WarningsAreErrors {
				return tlast.BeautifulError2(e1, e2)
			}
			tlast.BeautifulError2(e1, e2).PrintWarning(options.ErrorWriter, nil)
		}
		if EnableWarningsUnionNamePrefix &&
			!strings.HasPrefix(conName, typePrefix) &&
			!strings.HasSuffix(conName, typeSuffix) &&
			!LegacyEnableWarningsUnionNamePrefixSkip(typ.Construct.Name.Name, typePrefix, typeSuffix) &&
			doLint(typ.CommentRight) { // same check as in generateType
			e1 := typ.Construct.NamePR.BeautifulError(fmt.Errorf("union constructor should have type name prefix or suffix %q", typePrefix))
			e2 := typ.TypeDecl.NamePR.BeautifulError(errSeeHere)
			if options.WarningsAreErrors {
				return tlast.BeautifulError2(e1, e2)
			}
			tlast.BeautifulError2(e1, e2).PrintWarning(options.ErrorWriter, nil)
			continue
		}
		if EnableWarningsUnionNameExact && conName == typePrefix &&
			!LegacyEnableWarningsUnionNameExactSkip(typ.Construct.Name.String()) &&
			doLint(typ.CommentRight) {
			e1 := typ.Construct.NamePR.BeautifulError(fmt.Errorf("union constructor name should not exactly match type name %q", typePrefix))
			e2 := typ.TypeDecl.PR.BeautifulError(errSeeHere)
			if options.WarningsAreErrors {
				return tlast.BeautifulError2(e1, e2)
			}
			tlast.BeautifulError2(e1, e2).PrintWarning(options.ErrorWriter, nil)
		}
	}
	base := types[0]
	for _, typ := range types[1:] {
		cur := typ.Construct.Name.String()
		if len(typ.TemplateArguments) < len(base.TemplateArguments) {
			baseArg := base.TemplateArguments[len(typ.TemplateArguments)]
			// unionArgs2 {A:Type} {B:#} a:A = UnionArgs A B;
			// unionArgs1 {X:Type} a:X = UnionArgs X;
			e1 := typ.TemplateArgumentsPR.CollapseToEnd().BeautifulError(fmt.Errorf("union constructor %q has missing argument %q here", cur, baseArg.FieldName))
			e2 := baseArg.PR.BeautifulError(errSeeHere)
			return tlast.BeautifulError2(e1, e2)
		}
		if len(typ.TemplateArguments) > len(base.TemplateArguments) {
			typArg := typ.TemplateArguments[len(base.TemplateArguments)]
			// unionArgs1 {X:Type} a:X = UnionArgs X;
			// unionArgs2 {A:Type} {B:#} a:A = UnionArgs A B;
			e1 := typArg.PR.BeautifulError(fmt.Errorf("union constructor %q has excess argument %q here", cur, typArg.FieldName))
			e2 := base.TemplateArgumentsPR.CollapseToEnd().BeautifulError(errSeeHere)
			return tlast.BeautifulError2(e1, e2)
		}
		for i, typArg := range typ.TemplateArguments {
			baseArg := base.TemplateArguments[i]
			// unionArgs1 {X:Type} {Y:#} a:X = UnionArgs X Y;
			// unionArgs2 {A:Type} {B:Type} a:A = UnionArgs A B;
			// We cannot support this, because resolveType replaces parameter names into names of first union field
			if baseArg.IsNat != typArg.IsNat || baseArg.FieldName != typArg.FieldName {
				e1 := typArg.PR.BeautifulError(fmt.Errorf("union constructor %q has different argument name or type here %q", cur, typArg.FieldName))
				e2 := baseArg.PR.BeautifulError(errSeeHere)
				return tlast.BeautifulError2(e1, e2)
			}
		}
	}
	return nil
}

func inBytesVersionFilter(name tlast.Name, filter string) bool {
	if strings.HasSuffix(filter, ".") && name.Namespace == strings.TrimSuffix(filter, ".") {
		return true
	}
	if !strings.HasSuffix(filter, ".") && name.String() == filter {
		return true
	}
	return false
}

func collectRelativePaths(absDirName string, relDirName string, relativeFiles map[string]bool, relativeDirs *[]string) error {
	fis, err := os.ReadDir(absDirName)
	if err != nil {
		return err
	}
	for _, fi := range fis { // try all snapshots, loading the latest
		relFilename := filepath.Join(relDirName, fi.Name())
		absFilename := filepath.Join(absDirName, fi.Name())
		if fi.IsDir() {
			*relativeDirs = append(*relativeDirs, relFilename)
			if err = collectRelativePaths(absFilename, relFilename, relativeFiles, relativeDirs); err != nil {
				return err
			}
			continue
		}
		relativeFiles[relFilename] = true
	}
	return nil
}

// WriteToDir Most common action with generated code, so clients do not repeat it
func (gen *Gen2) WriteToDir(outdir string) error {
	if err := os.Mkdir(outdir, 0755); err != nil && !os.IsExist(err) { // we thus require parent directory to exist
		return fmt.Errorf("error creating outdir %q: %w", outdir, err)
	}
	// We do not want to touch files which did not change at all.
	relativeFiles := map[string]bool{}
	var relativeDirs []string
	if err := collectRelativePaths(outdir, "", relativeFiles, &relativeDirs); err != nil {
		return fmt.Errorf("error reading outdir content %q: %w", outdir, err)
	}
	if len(relativeFiles) != 0 && !relativeFiles[markerFile] {
		return fmt.Errorf("outdir %q not empty and has no %q marker file, please clean manually", outdir, markerFile)
	}
	markerContent := fmt.Sprintf(buildVersionFormat,
		strings.TrimSpace(TLGenVersion()),
		strings.TrimSpace(gen.options.SchemaURL),
		strings.TrimSpace(gen.options.SchemaCommit),
		gen.options.SchemaTimestamp, time.Unix(int64(gen.options.SchemaTimestamp), 0).UTC())
	if err := gen.addCodeFile(markerFile, markerContent); err != nil {
		return err
	}
	notTouched := 0
	written := 0
	deleted := 0
	for filepathName, code := range gen.Code {
		d := filepath.Join(outdir, filepath.Dir(filepathName))
		if err := os.MkdirAll(d, 0755); err != nil && !os.IsExist(err) {
			return fmt.Errorf("error creating dir %q: %w", d, err)
		}
		f := filepath.Join(outdir, filepathName)
		if relativeFiles[filepathName] {
			delete(relativeFiles, filepathName)
			was, err := os.ReadFile(f)
			if err != nil {
				return fmt.Errorf("error reading previous file %q: %w", f, err)
			}
			if string(was) == code {
				notTouched++
				continue
			} else {
				if gen.options.PrintDiff {
					fmt.Printf("File \"%s\":\n", f)
					fmt.Println(cmp.Diff(string(was), code))
				}
			}
		}
		written++
		if err := os.WriteFile(f, []byte(code), 0644); err != nil {
			return fmt.Errorf("error writing file %q: %w", f, err)
		}
	}
	for filepathName := range relativeFiles {
		f := filepath.Join(outdir, filepathName)
		if strings.HasSuffix(f, ".o") {
			continue
		}
		deleted++
		if err := os.Remove(f); err != nil {
			return fmt.Errorf("error deleting previous file %q: %w", f, err)
		}
	}
	for i := len(relativeDirs) - 1; i >= 0; i-- {
		f := filepath.Join(outdir, relativeDirs[i])
		_ = os.Remove(f) // non-empty dirs simply will not remove. This is good enough for us
	}
	// do not check Verbose
	fmt.Printf("%d target files did not change so were not touched, %d written, %d deleted\n", notTouched, written, deleted)
	return nil
}

func (gen *Gen2) addCodeFile(filepathName string, code string) error {
	if _, ok := gen.Code[filepathName]; ok {
		return fmt.Errorf("generator %sinternal error%s: source file %q is generated twice", color.Red, color.Reset, filepathName)
	}
	gen.Code[filepathName] = code
	return nil
}

func GenerateCode(tl tlast.TL, options Gen2Options) (*Gen2, error) {
	gen := &Gen2{
		options:    &options,
		Code:       map[string]string{},
		Namespaces: map[string]*Namespace{},
		// Files:                 map[string][]*TypeRWWrapper{},
		typeDescriptors:    map[string][]*tlast.Combinator{},
		singleConstructors: map[string]*tlast.Combinator{},
		allConstructors:    map[string]*tlast.Combinator{},
		builtinTypes:       map[string]*TypeRWWrapper{},
		generatedTypes:     map[string]*TypeRWWrapper{},
	}
	switch options.Language {
	case "": // linting
	case "go":
		if options.GenerateRPCCode && options.BasicRPCPath == "" {
			return nil, fmt.Errorf("--basicRPCPath must be specified if --generateRPCCode is set")
		}
		options.TLPackageNameFull = strings.TrimSpace(options.TLPackageNameFull)
		options.TLPackageNameFull = strings.TrimSuffix(options.TLPackageNameFull, "/")
		if options.TLPackageNameFull == "" { // for testing, empty path should be prohibited in main argv parsing
			options.TLPackageNameFull = "github.com/vkcom/tl/internal/tlcodegen/output/tl"
		}

		elements := strings.Split(options.TLPackageNameFull, "/")
		if len(elements) < 3 {
			return nil, fmt.Errorf("full go package name must have 2 non-empty rightmost path elements, for example '.../output/tl")
		}
		options.TLPackageNameFull = strings.Join(elements[:len(elements)-1], "/")
		gen.GlobalPackageName = elements[len(elements)-1]
		gen.RootPackageName = elements[len(elements)-2]
		gen.FactoryPackageName = strings.Join(append(elements[:len(elements)-1], FactoryGoPackageName), "/")
		gen.MetaPackageName = strings.Join(append(elements[:len(elements)-1], MetaGoPackageName), "/")
		if gen.GlobalPackageName == "" || elements[len(elements)-2] == "" {
			return nil, fmt.Errorf("full go package name must have 2 non-empty rightmost path elements, for example '.../output/tl")
		}
		if gen.options.BasicPackageNameFull == "" {
			gen.BasicPackageNameFull = strings.Join(append(elements[:len(elements)-1], BasicTLGoPackageName), "/")
		} else {
			elements = strings.Split(gen.options.BasicPackageNameFull, "/")
			if len(elements) < 2 || elements[len(elements)-1] != BasicTLGoPackageName {
				return nil, fmt.Errorf("basictl go package name must end with '/%s'", BasicTLGoPackageName)
			}
			gen.BasicPackageNameFull = gen.options.BasicPackageNameFull
		}
	case "cpp":
		if options.RootCPPNamespace == "" {
			options.RootCPPNamespace = "tl2"
		}
		gen.RootCPPNamespaceElements = strings.Split(options.RootCPPNamespace, "::")
		gen.DetailsCPPNamespaceElements = []string{options.RootCPPNamespace, "details"} // TODO - rename to prevent collisions with TL namespace details
		gen.DetailsCPPNamespace = options.RootCPPNamespace + "::details"
	case "php":
	default:
		return nil, fmt.Errorf("unsupported language %q, only 'go' and 'cpp' are supported, plus '' for linting", options.Language)
	}
	typesWhiteList := strings.Split(options.TypesWhileList, ",")
	for i := 0; i < len(typesWhiteList); i++ {
		typesWhiteList[i] = strings.TrimSpace(typesWhiteList[i])
		if len(typesWhiteList[i]) == 0 {
			typesWhiteList = append(typesWhiteList[:i], typesWhiteList[i+1:]...)
		}
	}
	generateByteVersions := strings.Split(options.BytesVersions, ",")
	for i := 0; i < len(generateByteVersions); i++ {
		generateByteVersions[i] = strings.TrimSpace(generateByteVersions[i])
		if len(generateByteVersions[i]) == 0 {
			generateByteVersions = append(generateByteVersions[:i], generateByteVersions[i+1:]...)
		}
	}
	gen.supportedAnnotations = map[string]int{"read": 0, "any": 1, "internal": 2, "write": 3, "readwrite": 4, "kphp": 5}
	rootNamespace := gen.getNamespace("")
	primitiveTypesList := []*TypeRWPrimitive{
		{
			tlType:            "#",
			goType:            "uint32",
			cppPrimitiveType:  "uint32_t",
			cppDefaultInit:    " = 0",
			cppFunctionSuffix: "nat",
			cppResetValue:     "%s = 0;",
			writeJSONValue:    "basictl.JSONWriteUint32",
			readJSONValue:     gen.InternalPrefix() + "JsonReadUint32",
			readJSON2Value:    gen.InternalPrefix() + "Json2ReadUint32",
			resetValue:        "%s = 0",
			randomValue:       "basictl.RandomUint",
			writeValue:        "basictl.NatWrite",
			readValue:         "basictl.NatRead",
		}, {
			tlType:            "int",
			goType:            "int32",
			cppPrimitiveType:  "int32_t",
			cppDefaultInit:    " = 0",
			cppFunctionSuffix: "int",
			cppResetValue:     "%s = 0;",
			writeJSONValue:    "basictl.JSONWriteInt32",
			readJSONValue:     gen.InternalPrefix() + "JsonReadInt32",
			readJSON2Value:    gen.InternalPrefix() + "Json2ReadInt32",
			resetValue:        "%s = 0",
			randomValue:       "basictl.RandomInt",
			writeValue:        "basictl.IntWrite",
			readValue:         "basictl.IntRead",
		}, {
			tlType:            "long",
			goType:            "int64",
			cppPrimitiveType:  "int64_t",
			cppDefaultInit:    " = 0",
			cppFunctionSuffix: "long",
			cppResetValue:     "%s = 0;",
			writeJSONValue:    "basictl.JSONWriteInt64",
			readJSONValue:     gen.InternalPrefix() + "JsonReadInt64",
			readJSON2Value:    gen.InternalPrefix() + "Json2ReadInt64",
			resetValue:        "%s = 0",
			randomValue:       "basictl.RandomLong",
			writeValue:        "basictl.LongWrite",
			readValue:         "basictl.LongRead",
		}, {
			tlType:            "float",
			goType:            "float32",
			cppPrimitiveType:  "float",
			cppDefaultInit:    " = 0",
			cppFunctionSuffix: "float",
			cppResetValue:     "%s = 0;",
			writeJSONValue:    "basictl.JSONWriteFloat32",
			readJSONValue:     gen.InternalPrefix() + "JsonReadFloat32",
			readJSON2Value:    gen.InternalPrefix() + "Json2ReadFloat32",
			resetValue:        "%s = 0",
			randomValue:       "basictl.RandomFloat",
			writeValue:        "basictl.FloatWrite",
			readValue:         "basictl.FloatRead",
		}, {
			tlType:            "double",
			goType:            "float64",
			cppPrimitiveType:  "double",
			cppDefaultInit:    " = 0",
			cppFunctionSuffix: "double",
			cppResetValue:     "%s = 0;",
			writeJSONValue:    "basictl.JSONWriteFloat64",
			readJSONValue:     gen.InternalPrefix() + "JsonReadFloat64",
			readJSON2Value:    gen.InternalPrefix() + "Json2ReadFloat64",
			resetValue:        "%s = 0",
			randomValue:       "basictl.RandomDouble",
			writeValue:        "basictl.DoubleWrite",
			readValue:         "basictl.DoubleRead",
		}, {
			tlType:            "string",
			goType:            "string",
			cppPrimitiveType:  "std::string",
			cppDefaultInit:    "",
			cppFunctionSuffix: "string",
			cppResetValue:     "%s.clear();",
			writeJSONValue:    "basictl.JSONWriteString",
			readJSONValue:     gen.InternalPrefix() + "JsonReadString",
			readJSON2Value:    gen.InternalPrefix() + "Json2ReadString",
			resetValue:        "%s = \"\"",
			randomValue:       "basictl.RandomString",
			writeValue:        "basictl.StringWrite",
			readValue:         "basictl.StringRead",
		},
	}
	builtinBeautifulText := fmt.Sprintf(`
%s {n:#} {t:Type} n*[t] = _ n t; // builtin tuple
%s {t:Type} # [t] = _ t; // builtin vector
`, BuiltinTupleName, BuiltinVectorName)
	primitiveTypes := map[string]*TypeRWPrimitive{}
	for _, cn := range primitiveTypesList {
		builtinBeautifulText += fmt.Sprintf("%s ? = _; // builtin primitive type\n", cn.tlType)
		primitiveTypes[cn.tlType] = cn
	}

	btl, err := tlast.ParseTLFile(builtinBeautifulText, "<builtin>", tlast.LexerOptions{
		AllowBuiltin: true,
		AllowDirty:   false,
		AllowMLC:     false,
	}, options.ErrorWriter) // We need references to token positions for beautification, so we decided to parse as a TL file
	if err != nil {
		return nil, fmt.Errorf("failed to parse internal builtin type representation for beautification: %w", err)
	}

	if gen.options.Language == "php" {
		// RPC SPECIAL CHANGES
		if gen.options.AddRPCTypes {
			const rpcRequestResultName = "ReqResult"
			rpcResultsMapping := map[string]string{
				"reqError":        "rpcResponseError",
				"reqResultHeader": "rpcResponseHeader",
				"_":               "rpcResponseOk",
			}
			rpcRemovedTypes := map[string]bool{
				"rpcReqResult": true,
				"rpcReqError":  true,
				"rpcInvokeReq": true,
			}
			rpcFunctionTypeRef := tlast.TypeRef{
				Type: tlast.Name{
					Name: PHPRPCFunctionMock,
				},
			}
			rpcFunctionResultTypeRef := tlast.TypeRef{
				Type: tlast.Name{
					Name: PHPRPCFunctionResultMock,
				},
			}
			rpcResponseTypeRef := tlast.TypeRef{
				Type: tlast.Name{
					Name: PHPRPCResponseMock,
				},
			}
			// TODO: RETURN ORIGINAL COMBINATOR
			tl = append(tl, &tlast.Combinator{
				TypeDecl: tlast.TypeDeclaration{
					Name: tlast.Name{
						Name: "ReqResult",
					},
					Arguments: []string{"X"},
				},
				Construct: tlast.Constructor{
					Name: tlast.Name{Name: "_"},
				},
				TemplateArguments: []tlast.TemplateArgument{
					{
						FieldName: "X",
						IsNat:     false,
					},
				},
				Fields: []tlast.Field{
					{
						FieldName: "result",
						FieldType: tlast.TypeRef{
							Type: tlast.Name{
								Name: "X",
							},
						},
					},
				},
			})
			tl = append(tl, &tlast.Combinator{
				TypeDecl: tlast.TypeDeclaration{
					Name: rpcFunctionTypeRef.Type,
				},
				Construct: tlast.Constructor{Name: rpcFunctionTypeRef.Type},
			})
			tl = append(tl, &tlast.Combinator{
				TypeDecl: tlast.TypeDeclaration{
					Name: rpcFunctionResultTypeRef.Type,
				},
				Construct: tlast.Constructor{Name: rpcFunctionResultTypeRef.Type},
			})
			for _, typ := range tl {
				if typ.IsFunction && len(typ.TemplateArguments) == 1 {
					phpRemoveTemplateFromGeneric(typ, &rpcFunctionTypeRef, &rpcFunctionResultTypeRef)
				} else if !typ.IsFunction &&
					rpcResultsMapping[typ.Construct.Name.String()] != "" &&
					typ.TypeDecl.Name.String() == rpcRequestResultName {
					typ.Construct.Name.Name = rpcResultsMapping[typ.Construct.Name.String()]
					typ.TypeDecl = tlast.TypeDeclaration{Name: rpcResponseTypeRef.Type}
					phpRemoveTemplateFromGeneric(typ, &rpcFunctionResultTypeRef, &rpcFunctionResultTypeRef)
				}
			}
			// TODO DELETE AS NORMAL PEOPLE
			var removedTypesIndecies []int
			for i, typ := range tl {
				if rpcRemovedTypes[typ.Construct.Name.String()] {
					removedTypesIndecies = append(removedTypesIndecies, i)
				}
			}
			sort.Ints(removedTypesIndecies)
			for i, index := range removedTypesIndecies {
				tl = append(tl[:index-i], tl[index-i+1:]...)
			}
		}
	}

	for i, typ := range tl { // replace built-in
		tName := typ.Construct.Name.String()
		// convert that old syntax to new syntax.
		if !typ.Builtin {
			continue
		}
		if len(typ.TemplateArguments) != 0 {
			return nil, typ.TemplateArgumentsPR.BeautifulError(fmt.Errorf("builtin wrapper %q cannot have template parameters", tName))
		}
		if _, ok := primitiveTypes[tName]; !ok {
			return nil, typ.Construct.NamePR.BeautifulError(fmt.Errorf("builtin wrapper %q must have constructor name equal to some builtin type", tName))
		}
		newDesc := &tlast.Combinator{}
		*newDesc = *tl[i]
		newDesc.OriginalDescriptor = typ
		newDesc.Fields = append(newDesc.Fields, tlast.Field{
			FieldType: tlast.TypeRef{
				Type: tlast.Name{Name: tName},
				Bare: true,
			},
		})
		newDesc.Builtin = false
		tl[i] = newDesc
	}
	if err := checkTagCollisions(tl); err != nil {
		return nil, err
	}
	if err := checkNamespaceCollisions(tl); err != nil {
		return nil, err
	}

	// ReplaceSquareBrackets will generate types with id 0, we will not generate boxed methods for such types
	if tl, err = gen.ReplaceSquareBracketsElem(tl); err != nil {
		return nil, fmt.Errorf("replacing with canonical tuples: %w", err)
	}
	err = gen.buildMapDescriptors(tl)
	if err != nil {
		return nil, err
	}

	// Now we replace all builtin legitimate builtin wrapper constructors to constructors of builtins
	// Int and %Int will reference wrappers, while int will reference builtin constructor.
	// To avoid 2 canonical forms, resolveType will replace %Int to int for wrappers
	for _, bt := range btl {
		var zero uint32
		bt.Construct.ID = &zero
		tName := bt.Construct.Name.String()
		if tName == BuiltinTupleName || tName == BuiltinVectorName {
			gen.allConstructors[tName] = bt
			gen.singleConstructors[tName] = bt
			continue
		}
		cn, ok := primitiveTypes[tName]
		if !ok {
			panic("broken primitive types list")
		}
		wrapper := &TypeRWWrapper{
			gen:          gen,
			ns:           rootNamespace,
			trw:          cn,
			goGlobalName: cn.goType,
			goLocalName:  "",
			fileName:     cn.tlType,
			origTL:       []*tlast.Combinator{bt},
		}
		if cn.tlType == "#" {
			wrapper.fileName = "nat"
		}
		gen.builtinTypes[cn.tlType] = wrapper
		gen.generatedTypesList = append(gen.generatedTypesList, wrapper)
		typ, ok := gen.allConstructors[tName]
		if ok {
			// vasya ? = Int;
			// vasya {T:Type} {N:#} ? = Int T N;
			// int {T:Type} {N:#} int = Int T N;
			// int = Int;
			// int int int = Int;
			// int vasya:int = Int;
			// int n.0?int = Int;
			// int (int 5) = Int;
			// int (%Int) = Int;
			// int (Int) = Int;
			// int ? = Int;   <-- allowed, but deprecated shape. TODO - prohibit in TL2
			// int int = Int; <-- allowed shape
			if len(typ.TemplateArguments) != 0 {
				return nil, typ.TemplateArgumentsPR.BeautifulError(fmt.Errorf("builtin wrapper %q cannot have template parameters", tName))
			}
			if len(typ.Fields) == 0 {
				return nil, typ.TemplateArgumentsPR.CollapseToEnd().BeautifulError(fmt.Errorf("builtin wrapper %q must have exactly 1 field", tName))
			}
			if len(typ.Fields) > 1 {
				return nil, typ.Fields[1].FieldType.PR.BeautifulError(fmt.Errorf("builtin wrapper %q has excess field, must have exactly 1", tName))
			}
			if typ.Fields[0].FieldName != "" {
				return nil, typ.Fields[0].PRName.BeautifulError(fmt.Errorf("builtin wrapper %q field must be anonymous", tName))
			}
			if typ.Fields[0].Mask != nil {
				return nil, typ.Fields[0].Mask.PRName.BeautifulError(fmt.Errorf("builtin wrapper %q field must not use field mask", tName))
			}
			if typ.Fields[0].FieldType.Type.String() != tName || len(typ.Fields[0].FieldType.Args) != 0 { // do not check Bare, because int === %int
				return nil, typ.Fields[0].FieldType.PR.BeautifulError(fmt.Errorf("builtin wrapper %q field type must match constructor name", tName))
			}
			if _, ok := gen.builtinTypes[tName]; !ok {
				return nil, typ.Construct.NamePR.BeautifulError(fmt.Errorf("builtin wrapper %q must have constructor name equal to some builtin type", tName))
			}
		} else {
			gen.allConstructors[tName] = bt
			gen.singleConstructors[tName] = bt
		}
	}

	// tupleDesc := btl[0]
	// vectorDesc := btl[1]
	// gen.singleConstructors[tupleDesc.Construct.Name.String()] = tupleDesc
	// gen.allConstructors[tupleDesc.Construct.Name.String()] = tupleDesc
	// gen.singleConstructors[vectorDesc.Construct.Name.String()] = vectorDesc
	// gen.allConstructors[vectorDesc.Construct.Name.String()] = vectorDesc

	{
		allAnnotations := map[string]struct{}{}
		for _, typ := range tl {
			for _, m := range typ.Modifiers {
				if strings.ToLower(m.Name) != m.Name { // TODO - move into lexer
					return nil, m.PR.BeautifulError(fmt.Errorf("annotations must be lower case"))
				}
				if _, ok := allAnnotations[m.Name]; !ok {
					if _, ok := gen.supportedAnnotations[m.Name]; !ok && doLint(typ.CommentRight) {
						e1 := m.PR.BeautifulError(fmt.Errorf("annotation %q not known to tlgen", m.Name))
						if gen.options.WarningsAreErrors {
							return nil, e1
						}
						e1.PrintWarning(options.ErrorWriter, nil)
					}
					allAnnotations[m.Name] = struct{}{}
					gen.allAnnotations = append(gen.allAnnotations, m.Name)
				}
			}
		}
		if len(gen.allAnnotations) > 32 {
			return nil, fmt.Errorf("too many (%d) differnet annotations, max is 32 for now", len(gen.allAnnotations))
		}
		sort.Strings(gen.allAnnotations)
	}
	skippedDueToWhitelist := 0

	if gen.options.Language == "cpp" {
		gen.typesInfo = processCombinators(gen.allConstructors)
	}

	for _, typ := range tl {
		if LegacyGenerateUnusedNatTemplates(typ.Construct.Name.String()) && len(typ.TemplateArguments) == 1 && typ.TemplateArguments[0].IsNat {
			t := tlast.TypeRef{Type: typ.TypeDecl.Name, PR: typ.TypeDecl.PR}
			argT := tlast.TypeRef{Type: tlast.Name{
				Namespace: "",
				Name:      "ArgumentN",
			}}
			t.Args = append(t.Args, tlast.ArithmeticOrType{
				IsArith: false,
				T:       argT,
			})
			lrc := LocalResolveContext{allowAnyConstructor: true, localNatArgs: map[string]LocalNatArg{}}
			lrc.localNatArgs["ArgumentN"] = LocalNatArg{
				natArg: ActualNatArg{isField: true, FieldIndex: 0},
			}
			_, _, _, _, err = gen.getType(lrc, t, nil)
			if err != nil {
				return nil, err
			}
		}
		shouldGenerate := options.TypesWhileList == ""
		whiteListName := typ.Construct.Name
		if !typ.IsFunction {
			whiteListName = typ.TypeDecl.Name
		}
		for _, bv := range generateByteVersions {
			if inBytesVersionFilter(whiteListName, bv) {
				shouldGenerate = true
			}
		}
		for _, bv := range typesWhiteList {
			if inBytesVersionFilter(whiteListName, bv) {
				shouldGenerate = true
			}
		}
		if !shouldGenerate {
			skippedDueToWhitelist++
			continue
		}
		if len(typ.TemplateArguments) == 0 {
			t := tlast.TypeRef{Type: typ.Construct.Name, PR: typ.Construct.NamePR}
			if !typ.IsFunction {
				t = tlast.TypeRef{Type: typ.TypeDecl.Name, PR: typ.TypeDecl.PR}
			}
			_, _, _, _, err = gen.getType(LocalResolveContext{allowAnyConstructor: true}, t, nil)
			if err != nil {
				return nil, err
			}
		}
	}
	LegacyPrintGlobalMap()

	bytesChildren := map[*TypeRWWrapper]bool{}
	typesCounterMarkBytes := 0
	// This loop can be before or after loops below, it is convenient to fill sortedTypes inside, so this loop is here
	for _, v := range gen.generatedTypesList {
		for _, bv := range generateByteVersions {
			if inBytesVersionFilter(v.tlName, bv) {
				v.MarkWantsBytesVersion(bytesChildren)
				typesCounterMarkBytes++
			}
		}
	}
	slices.SortStableFunc(gen.generatedTypesList, func(a, b *TypeRWWrapper) int { //  TODO - better idea?
		return TypeRWWrapperLessGlobal(a, b)
	})
	sortedTypes := gen.generatedTypesList
	// for _, st := range sortedTypes {
	//	fmt.Printf("sorted type %q\n", st.localTypeArg.rt.String())
	// }
	for _, v := range sortedTypes {
		// fmt.Printf("type %s names %s %s %d\n", v.CanonicalStringTop(), v.goGlobalName, v.tlName.String(), v.tlTag)
		// if len(v.origTL) <= 1 {
		//	fmt.Printf("     %s\n", v.CanonicalString(true))
		// } else {
		//	fmt.Printf("     %s\n", v.CanonicalString(false))
		// }
		// r # [r] = S;
		visitedNodes := map[*TypeRWWrapper]bool{}
		v.trw.fillRecursiveUnwrap(visitedNodes)
		v.preventUnwrap = visitedNodes[v]
		if v.preventUnwrap {
			fmt.Printf("prevented unwrap of %v\n", v.tlName)
		}
	}

	if options.Language == "cpp" {
		_, order := findAllTypesDependencyComponents(sortedTypes)
		gen.componentsOrder = order

		for _, v := range sortedTypes {
			if len(v.arguments) == 0 {
				visitedNodes := make(map[*TypeRWWrapper]int)
				v.trw.FillRecursiveChildren(visitedNodes, true)
			}
		}
	}

	// in BeforeCodeGenerationStep we split recursion. Which links will be broken depends on order of nodes visited
	for _, v := range sortedTypes {
		v.trw.BeforeCodeGenerationStep1()
	}
	// in BeforeCodeGenerationStep2 we split recursion in unions.
	for _, v := range sortedTypes {
		v.trw.BeforeCodeGenerationStep2()
	}
	// we link normal and long types for VK int->long conversion. This code is VK-specific and will be removed after full migration
	for _, v := range sortedTypes {
		// @readwrite queueLong.getQueueKey id:long ip:int timeout:int queue:string = queueLong.TimestampKey;
		// @readwrite queue.getQueueKey id:int ip:int timeout:int queue:string = queue.TimestampKey;
		longName := v.CanonicalStringTop()
		argsStart := strings.Index(longName, "<")
		if argsStart < 0 {
			argsStart = len(longName)
		}
		if i := strings.Index(longName[:argsStart], "."); i >= 0 {
			longName = longName[:i] + "Long" + longName[i:]

			if tt, ok := gen.generatedTypes[longName]; ok {
				// log.Printf("long name %s discovered for %s", longName, v.CanonicalStringTop())
				v.WrLong = tt
				tt.WrWithoutLong = v
			}
		}

		v.trw.BeforeCodeGenerationStep2()
	}
	// Order of these 2 loops is important, for example see TypeRWTuple where bytes version depends on whether it is dict_like
	for _, v := range sortedTypes {
		visitedNodes := map[*TypeRWWrapper]bool{}
		v.hasBytesVersion = v.MarkHasBytesVersion(visitedNodes)
		visitedNodes = map[*TypeRWWrapper]bool{}
		v.hasErrorInWriteMethods = v.MarkWriteHasError(visitedNodes)
	}
	// detect recursion loops first
	if options.Verbose {
		if skippedDueToWhitelist != 0 {
			log.Printf("skipped %d object roots by the whitelist filter: %s", skippedDueToWhitelist, strings.Join(typesWhiteList, ", "))
		}
		if filter := strings.Join(generateByteVersions, ", "); filter != "" {
			log.Printf("found %d object roots for byte-optimized versions of types by the following filter: %s", typesCounterMarkBytes, filter)
		}
	}
	if gen.options.CopyrightFilePath != "" {
		buf, err := os.ReadFile(gen.options.CopyrightFilePath)
		if err != nil {
			return nil, fmt.Errorf("failed to open copyright text file: %w", err)
		}
		gen.copyrightText = string(buf)
	}
	switch options.Language {
	case "go":
		if err := gen.generateCodeGolang(generateByteVersions); err != nil {
			return nil, err
		}
	case "cpp":
		if err := gen.generateCodeCPP(generateByteVersions); err != nil {
			return nil, err
		}
	case "php":
		{
			// TODO ADD FEATURE TO CHANGE IT
			gen.copyrightText = `/**
 * AUTOGENERATED, DO NOT EDIT! If you want to modify it, check tl schema.
 *
 * This autogenerated code represents tl class for typed RPC API.
 */

`
		}
		if err := gen.generateCodePHP(generateByteVersions); err != nil {
			return nil, err
		}

	}

	if options.SchemaDocumentation {
		if err := gen.addCodeFile(TlJSONHTML, tlJSON(gen, TLGenVersion())); err != nil {
			return nil, err
		}
	}

	return gen, nil
}

func phpRemoveTemplateFromGeneric(combinator *tlast.Combinator, newTypeRef, newTypeResultRef *tlast.TypeRef) {
	template := combinator.TemplateArguments[0].FieldName
	combinator.TemplateArguments = nil
	for i := range combinator.Fields {
		phpRemoveTemplateFromTypeDecl(&combinator.Fields[i].FieldType, template, newTypeRef)
	}
	phpRemoveTemplateFromTypeDecl(&combinator.FuncDecl, template, newTypeResultRef)
}

func phpRemoveTemplateFromTypeDecl(declaration *tlast.TypeRef, template string, newTypeRef *tlast.TypeRef) {
	if declaration.Type.String() == template {
		*declaration = *newTypeRef
	} else {
		for i := range declaration.Args {
			if !declaration.Args[i].IsArith {
				phpRemoveTemplateFromTypeDecl(&declaration.Args[i].T, template, newTypeRef)
			}
		}
	}
}

var TypeComparator = func(a, b *TypeRWWrapper) int {
	return strings.Compare(a.goGlobalName, b.goGlobalName)
}

func stabilizeOrder(mp *map[*TypeRWWrapper][]*TypeRWWrapper) (keyOrder []*TypeRWWrapper) {
	for k, v := range *mp {
		slices.SortFunc(v, TypeComparator)
		keyOrder = append(keyOrder, k)
	}
	slices.SortFunc(keyOrder, TypeComparator)
	return
}

func findAllTypesDependencyComponents(types []*TypeRWWrapper) (map[int]map[int]bool, []int) {
	dependencyGraph := make(map[*TypeRWWrapper][]*TypeRWWrapper)
	reverseDependencyGraph := make(map[*TypeRWWrapper][]*TypeRWWrapper)

	for _, tpU := range types {
		dependencies := tpU.trw.AllTypeDependencies(true, false)
		for _, tpV := range dependencies {
			dependencyGraph[tpU] = append(dependencyGraph[tpU], tpV)
			reverseDependencyGraph[tpV] = append(reverseDependencyGraph[tpV], tpU)
		}
	}

	_ = stabilizeOrder(&dependencyGraph)
	_ = stabilizeOrder(&reverseDependencyGraph)

	visitedTypes := make(map[*TypeRWWrapper]bool)
	order := make([]*TypeRWWrapper, 0)
	for _, tp := range types {
		if !visitedTypes[tp] {
			findAllTypesDependencyComponentsStep1(
				tp,
				&visitedTypes,
				&dependencyGraph,
				&order,
			)
		}
	}
	visitedTypes = make(map[*TypeRWWrapper]bool)
	component := 1
	for i := len(order) - 1; i >= 0; i-- {
		target := order[i]
		if !visitedTypes[target] {
			findAllTypesDependencyComponentsStep2(
				target,
				&visitedTypes,
				&reverseDependencyGraph,
				component,
			)
			component += 1
		}
	}

	componentsDeps := make(map[int]map[int]bool)

	for _, tpU := range types {
		if _, ok := componentsDeps[tpU.typeComponent]; !ok {
			componentsDeps[tpU.typeComponent] = make(map[int]bool)
		}
		for _, tpV := range tpU.trw.AllTypeDependencies(true, false) {
			if tpU.typeComponent != tpV.typeComponent {
				componentsDeps[tpU.typeComponent][tpV.typeComponent] = true
			}
		}
	}

	componentsOrdered := make([]int, 0)
	componentsDepsOrdered := make(map[int][]int)

	for componentId, itsDeps := range componentsDeps {
		componentsOrdered = append(componentsOrdered, componentId)
		list := make([]int, len(itsDeps))
		for dep := range itsDeps {
			list = append(list, dep)
		}
		sort.Ints(list)
		componentsDepsOrdered[componentId] = list
	}

	sort.Ints(componentsOrdered)

	compOrder := make([]int, 0)
	compVisited := make(map[int]bool)

	for comp := range componentsOrdered {
		if !compVisited[comp] {
			sortComponents(comp, &compVisited, &componentsDepsOrdered, &compOrder)
		}
	}

	//slices.Reverse(compOrder)

	return componentsDeps, compOrder
}

func findAllTypesDependencyComponentsStep1(
	tp *TypeRWWrapper,
	visited *map[*TypeRWWrapper]bool,
	typeDeps *map[*TypeRWWrapper][]*TypeRWWrapper,
	order *[]*TypeRWWrapper) {
	(*visited)[tp] = true
	for _, tpDep := range (*typeDeps)[tp] {
		if !(*visited)[tpDep] {
			findAllTypesDependencyComponentsStep1(tpDep, visited, typeDeps, order)
		}
	}
	*order = append(*order, tp)
}

func findAllTypesDependencyComponentsStep2(
	tp *TypeRWWrapper,
	visited *map[*TypeRWWrapper]bool,
	typeDeps *map[*TypeRWWrapper][]*TypeRWWrapper,
	component int) {
	(*visited)[tp] = true
	tp.typeComponent = component
	for _, tpDep := range (*typeDeps)[tp] {
		if !(*visited)[tpDep] {
			findAllTypesDependencyComponentsStep2(tpDep, visited, typeDeps, component)
		}
	}
}

func sortComponents(target int, visited *map[int]bool, deps *map[int][]int, order *[]int) {
	(*visited)[target] = true
	for _, next := range (*deps)[target] {
		if !(*visited)[next] {
			sortComponents(next, visited, deps, order)
		}
	}
	*order = append(*order, target)
}

type LanguageTypeSystemInfo struct {
	AllowedTypeGenerics                bool
	AllowedCompileTimeConstantGenerics bool
}

func (lti LanguageTypeSystemInfo) OnlyFullyResolvedTypes() bool {
	return !(lti.AllowedCompileTimeConstantGenerics && lti.AllowedTypeGenerics)
}

type ConstructorName = tlast.Name
type Constructor struct {
	Type   *TypeDefinition
	Id     uint
	Name   ConstructorName
	Fields []tlast.Field
	Result *tlast.TypeRef
}

type TypeName = tlast.Name
type TypeDefinition struct {
	IsBasic       bool
	Name          TypeName
	TypeArguments []tlast.TemplateArgument
	Constructors  []*Constructor
}

type EvaluatedTypeVariant = int

const (
	NumberConstant EvaluatedTypeVariant = 0
	NumberVariable EvaluatedTypeVariant = 1
	TypeConstant   EvaluatedTypeVariant = 2
	TypeVariable   EvaluatedTypeVariant = 3
)

type EvaluatedType struct {
	Index EvaluatedTypeVariant

	// union variants
	Constant     uint32         // 0
	Variable     string         // 1
	Type         *TypeReduction // 2
	TypeVariable string         // 3

	VariableActsAsConstant bool // only if Index == 1 and only for type declarations
}

type TypeReduction struct {
	IsType bool

	Type        *TypeDefinition
	Constructor *Constructor

	Arguments []EvaluatedType
}

func (tr *TypeReduction) EraseTypes() TypeReduction {
	erasedReduction := *tr
	erasedReduction.Arguments = make([]EvaluatedType, 0)

	var typeIndex int

	for _, arg := range tr.Arguments {
		switch arg.Index {
		case TypeConstant:
			erasedReduction.Arguments = append(
				erasedReduction.Arguments,
				EvaluatedType{Index: TypeVariable, TypeVariable: fmt.Sprintf("X%d", typeIndex)},
			)
			typeIndex++
		default:
			erasedReduction.Arguments = append(erasedReduction.Arguments, arg)
		}
	}
	return erasedReduction
}

func (tr *TypeReduction) EraseConstants() TypeReduction {
	erasedReduction := *tr
	erasedReduction.Arguments = make([]EvaluatedType, 0)

	var conIndex int

	for _, arg := range tr.Arguments {
		switch arg.Index {
		case NumberConstant:
			erasedReduction.Arguments = append(
				erasedReduction.Arguments,
				EvaluatedType{Index: NumberVariable, Variable: fmt.Sprintf("n%d", conIndex), VariableActsAsConstant: true},
			)
			conIndex++
		default:
			erasedReduction.Arguments = append(erasedReduction.Arguments, arg)
		}
	}
	return erasedReduction
}

func (tr *TypeReduction) EraseConstantsAndTypes() TypeReduction {
	erasedReduction := (*tr).EraseTypes()
	erasedReduction = erasedReduction.EraseConstants()
	return erasedReduction
}

func (tr *TypeReduction) AncestorTemplateInTypeSystem(info LanguageTypeSystemInfo) TypeReduction {
	ancestor := *tr
	if info.AllowedTypeGenerics {
		ancestor = ancestor.EraseTypes()
	}
	if info.AllowedCompileTimeConstantGenerics {
		ancestor = ancestor.EraseConstants()
	}
	return ancestor
}

func (tr *TypeReduction) IsFullyResolved() bool {
	for _, arg := range tr.Arguments {
		switch arg.Index {
		case NumberConstant:
			continue
		case NumberVariable:
			continue
		case TypeConstant:
			if !arg.Type.IsFullyResolved() {
				return false
			}
		case TypeVariable:
			return false
		default:
			panic("not all variants of reduction considered")
		}
	}
	return true
}

func (tr *TypeReduction) ReferenceName() (name tlast.Name) {
	if tr.IsType {
		name = tr.Type.Name
	} else {
		name = tr.Constructor.Name
	}
	return
}

func (tr *TypeReduction) ReferenceType() *TypeDefinition {
	if tr.IsType {
		return tr.Type
	}
	return tr.Constructor.Type
}

func (tr *TypeReduction) String() string {
	s := ""
	if tr.Type != nil || tr.Constructor != nil {
		s += tr.ReferenceName().String()
		if len(tr.Arguments) != 0 {
			s += "<"
			for i, arg := range tr.Arguments {
				switch arg.Index {
				case 0:
					s += "Con" + strconv.FormatInt(int64(arg.Constant), 10)
				case 1:
					if arg.VariableActsAsConstant {
						s += "ConstVar"
					} else {
						s += "Var"
					}
				case 2:
					s += arg.Type.String()
				case 3:
					s += "TypeVar"
				}
				if len(tr.Arguments) != i+1 {
					s += ","
				}
			}
			s += ">"
		}
	}
	return s
}

func processCombinators(types map[string]*tlast.Combinator) *TypesInfo {
	existingTypes := make(map[TypeName]*TypeDefinition)
	existingConstructors := make(map[ConstructorName]*Constructor)

	for _, comb := range types {
		declaredType := comb.TypeDecl.Name
		if comb.Builtin {
			declaredType = comb.Construct.Name
		}
		currentConstructor := comb.Construct.Name
		if _, presented := existingTypes[declaredType]; !presented {
			existingTypes[declaredType] = &TypeDefinition{
				IsBasic:       comb.Builtin,
				Name:          declaredType,
				Constructors:  []*Constructor{},
				TypeArguments: comb.TemplateArguments,
			}
		}
		targetType := existingTypes[declaredType]
		constructor := Constructor{
			Name:   currentConstructor,
			Fields: comb.Fields,
			Id:     uint(len(targetType.Constructors)),
			Type:   targetType,
			Result: &comb.FuncDecl,
		}
		if !comb.IsFunction {
			constructor.Result = nil
		}
		targetType.Constructors = append(targetType.Constructors, &constructor)
		existingConstructors[currentConstructor] = &constructor
	}

	typeReductions := make(map[string]*TypeReduction)
	visitedTypes := make(map[TypeName]bool)

	for _, comb := range existingTypes {
		if len(comb.TypeArguments) != 0 {
			continue
		}
		reduce(
			TypeReduction{
				IsType: true,
				Type:   existingTypes[comb.Name],
			},
			&typeReductions,
			&existingTypes,
			&existingConstructors,
			&visitedTypes,
		)
	}

	ti := TypesInfo{Types: existingTypes, Constructors: existingConstructors, TypeReductions: typeReductions}

	//printResults(ti)

	return &ti
}

func reduce(
	targetTypeReduction TypeReduction,
	visitedReductions *map[string]*TypeReduction,
	types *map[TypeName]*TypeDefinition,
	constructors *map[ConstructorName]*Constructor,
	visitedTypes *map[TypeName]bool,
) {
	for _, arg := range targetTypeReduction.Arguments {
		if arg.Index == TypeConstant {
			reduce(*arg.Type, visitedReductions, types, constructors, visitedTypes)
		}
	}

	var visitingConstructors []*Constructor

	if targetTypeReduction.IsType {
		visitingConstructors = targetTypeReduction.Type.Constructors
	} else {
		visitingConstructors = append(visitingConstructors, targetTypeReduction.Constructor)
	}

	for _, constr := range visitingConstructors {
		reduceConstructor(
			constr,
			targetTypeReduction.Arguments,
			visitedReductions,
			types,
			constructors,
			visitedTypes,
		)
	}
}

func reduceConstructor(
	constructor *Constructor,
	args []EvaluatedType,
	visitedReductions *map[string]*TypeReduction,
	types *map[TypeName]*TypeDefinition,
	constructors *map[ConstructorName]*Constructor,
	visitedTypes *map[TypeName]bool,
) {
	if constructor == nil || constructor.Type.IsBasic {
		return
	}

	if (*visitedTypes)[constructor.Name] {
		return
	} else {
		(*visitedTypes)[constructor.Name] = true
		defer func() {
			(*visitedTypes)[constructor.Name] = false
		}()
	}

	constructorReduction := TypeReduction{IsType: false, Constructor: constructor, Arguments: args}

	if _, ok := (*visitedReductions)[constructorReduction.String()]; !ok {
		(*visitedReductions)[constructorReduction.String()] = &constructorReduction
	} else {
		return
	}

	defaultFields := calculateDefaultFields(constructor, args)

	for _, field := range constructor.Fields {
		fieldType := toTypeReduction(field.FieldType, types, constructors)
		if fieldType != nil {
			fillTypeReduction(fieldType, args, constructor.Type, &defaultFields)
			reduce(*fieldType, visitedReductions, types, constructors, visitedTypes)
		}
	}
}

func calculateDefaultFields(
	constructor *Constructor,
	args []EvaluatedType,
) map[string]bool {
	defaults := make(map[string]bool)

	for _, field := range constructor.Fields {
		if field.Mask != nil {
			name := field.Mask.MaskName
			bit := field.Mask.BitNumber
			if _, ok := defaults[name]; ok {
				defaults[field.FieldName] = true
				continue
			}
			if argIndex := findArgByName(name, constructor.Type.TypeArguments); argIndex != -1 {
				arg := args[argIndex]
				if arg.Index == 0 && (arg.Constant&(1<<bit) == 0) {
					defaults[field.FieldName] = true
					continue
				}
			}
		}
	}

	return defaults
}

func findArgByName(targetArg string, args []tlast.TemplateArgument) int {
	for i, arg := range args {
		if arg.FieldName == targetArg {
			return i
		}
	}
	return -1
}

func fillTypeReduction(
	typeReduction *TypeReduction,
	args []EvaluatedType,
	originalType *TypeDefinition,
	defaultFields *map[string]bool,
) {
	for argI, arg := range typeReduction.Arguments {
		switch arg.Index {
		// nat var
		case NumberVariable:
			j := findArgByName(arg.Variable, originalType.TypeArguments)
			if j != -1 && args[j].Index == NumberConstant {
				typeReduction.Arguments[argI] = args[j]
			} else if j != -1 && args[j].Index == NumberVariable && args[j].VariableActsAsConstant {
				typeReduction.Arguments[argI].VariableActsAsConstant = true
			} else if _, ok := (*defaultFields)[arg.Variable]; ok {
				typeReduction.Arguments[argI] = EvaluatedType{Index: NumberConstant, Constant: 0}
			}
		// type
		case TypeConstant:
			fillTypeReduction(arg.Type, args, originalType, defaultFields)
		// type var
		case TypeVariable:
			j := findArgByName(arg.TypeVariable, originalType.TypeArguments)
			if j != -1 {
				index := args[j].Index
				if index == TypeConstant || index == TypeVariable {
					typeReduction.Arguments[argI] = args[j]
				}
			}
		}
	}
}

func toTypeReduction(
	typeRef tlast.TypeRef,
	types *map[TypeName]*TypeDefinition,
	constructors *map[ConstructorName]*Constructor,
) *TypeReduction {
	var reduction TypeReduction

	typeName := typeRef.Type
	var targetType *TypeDefinition

	if constr, isConstructor := (*constructors)[typeName]; isConstructor {
		reduction.IsType = false
		reduction.Constructor = constr
		targetType = constr.Type
	} else if typ, isType := (*types)[typeName]; isType {
		reduction.IsType = true
		reduction.Type = typ
		targetType = typ
	} else {
		return nil
	}

	evalArguments := make([]EvaluatedType, 0)

	for i, actualArg := range typeRef.Args {
		typeArg := targetType.TypeArguments[i]
		if actualArg.IsArith {
			evalArguments = append(evalArguments, EvaluatedType{
				Index:    NumberConstant,
				Constant: actualArg.Arith.Res,
			})
		} else if typeArg.IsNat {
			evalArguments = append(evalArguments, EvaluatedType{
				Index:    NumberVariable,
				Variable: actualArg.T.Type.Name,
			})
		} else {
			typ := toTypeReduction(actualArg.T, types, constructors)
			if typ != nil {
				evalArguments = append(evalArguments, EvaluatedType{
					Index: TypeConstant,
					Type:  typ,
				})
			} else {
				evalArguments = append(evalArguments, EvaluatedType{
					Index:        TypeVariable,
					TypeVariable: actualArg.T.Type.Name,
				})
			}
		}
	}

	reduction.Arguments = evalArguments

	return &reduction
}

type TypesInfo struct {
	Types          map[TypeName]*TypeDefinition
	Constructors   map[ConstructorName]*Constructor
	TypeReductions map[string]*TypeReduction
}

// works for given constructor or for 1-st
func (ti *TypesInfo) FieldTypeReduction(tr *TypeReduction, fieldId int) EvaluatedType {
	constructor := tr.Constructor
	if tr.IsType {
		constructor = tr.ReferenceType().Constructors[0]
	}
	field := constructor.Fields[fieldId]
	fieldType := toTypeReduction(field.FieldType, &ti.Types, &ti.Constructors)
	if fieldType == nil {
		genericName := field.FieldType.Type.Name
		i := findArgByName(genericName, tr.ReferenceType().TypeArguments)
		if i == -1 || tr.Arguments[i].Type == nil {
			return EvaluatedType{Index: TypeVariable, TypeVariable: genericName}
		}
		return EvaluatedType{Index: TypeConstant, Type: tr.Arguments[i].Type}
	}
	defaultValues := calculateDefaultFields(constructor, tr.Arguments)
	fillTypeReduction(fieldType, tr.Arguments, tr.ReferenceType(), &defaultValues)
	return EvaluatedType{Index: TypeConstant, Type: fieldType}
}

func (ti *TypesInfo) ResultTypeReduction(tr *TypeReduction) EvaluatedType {
	resultRef := tr.Constructor.Result
	if resultRef == nil {
		panic("not a function")
	}
	constructor := tr.Constructor
	if tr.IsType {
		constructor = tr.ReferenceType().Constructors[0]
	}

	resultType := toTypeReduction(*resultRef, &ti.Types, &ti.Constructors)
	defaultValues := calculateDefaultFields(constructor, tr.Arguments)
	fillTypeReduction(resultType, tr.Arguments, tr.ReferenceType(), &defaultValues)
	return EvaluatedType{Index: TypeConstant, Type: resultType}
}

func (ti *TypesInfo) TypeNameToGenericTypeReduction(t TypeName) TypeReduction {
	var rd TypeReduction
	rd.Type, rd.IsType = ti.Types[t]
	rd.Constructor = ti.Constructors[t]

	refType := rd.ReferenceType()
	for i, arg := range refType.TypeArguments {
		var evalType EvaluatedType
		if arg.IsNat {
			evalType = EvaluatedType{Index: NumberVariable, Variable: fmt.Sprintf("_Nat%d", i)}
		} else {
			evalType = EvaluatedType{Index: TypeVariable, TypeVariable: fmt.Sprintf("_Type%d", i)}
		}
		rd.Arguments = append(rd.Arguments, evalType)
	}

	return rd
}

func (ti *TypesInfo) TypeRWWrapperToTypeReduction(t *TypeRWWrapper) TypeReduction {
	tr := ti.TypeNameToGenericTypeReduction(t.tlName)
	for i, arg := range t.arguments {
		if arg.tip != nil {
			evalArg := ti.TypeRWWrapperToTypeReduction(arg.tip)
			tr.Arguments[i] = EvaluatedType{Index: TypeConstant, Type: &evalArg}
		} else {
			if arg.isArith {
				tr.Arguments[i] = EvaluatedType{Index: NumberConstant, Constant: arg.Arith.Res}
			}
		}
	}
	return tr
}
