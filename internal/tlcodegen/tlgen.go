// Copyright 2022 V Kontakte LLC
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package tlcodegen

import (
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"
	"runtime/debug"
	"sort"
	"strings"
	"sync/atomic"
	"time"

	"golang.org/x/exp/slices"

	"github.com/TwiN/go-color"

	"github.com/vkcom/tl/internal/tlast"
)

const BuiltinTupleName = "__tuple"
const BuiltinVectorName = "__vector"
const BasicTLGoPackageName = "basictl" // does not contain tl prefix
const FactoryGoPackageName = "factory" // does not contain tl prefix
const MetaGoPackageName = "meta"       // does not contain tl prefix
const ConstantsPackageName = "constants"
const BasicTLCPPNamespaceName = "basictl" // does not contain tl prefix
const HeaderComment = "// Code generated by vktl/cmd/tlgen2; DO NOT EDIT."
const markerFile = "tlgen2_version.txt"
const EnableWarningsUnionNamespace = true
const EnableWarningsUnionNamePrefix = true
const EnableWarningsUnionNameExact = true
const EnableWarningsSimpleTypeName = true

const (
	goExt  = ".go"
	cppExt = ".cpp"
	hppExt = ".hpp"
)

const TlJSONHTML = "tljson.html"

const buildVersionFormat = `tlgen version: %s
schema url: %s
schema commit: %s
schema version: %d (%v)
`

var (
	errSeeHere                = fmt.Errorf("see here")
	errFieldNameCollision     = fmt.Errorf("field name collision")
	errNatParamNameCollision  = fmt.Errorf("nat-parametr name collision")
	errTypeParamNameCollision = fmt.Errorf("type-parametr name collision ")
)

type LocalResolveContext struct {
	localTypeArgs map[string]LocalTypeArg
	localNatArgs  map[string]LocalNatArg

	allowAnyConstructor bool   // we can reference all constructors (functions, union elements) directly internally
	overrideFileName    string // used for unions and built-in vectors and tuples, so they are defined in the file of argument
}

func TLGenVersion() string {
	if info, ok := debug.ReadBuildInfo(); ok {
		return info.Main.Version
	}
	return ""
}

// checkArgsCollision checks if passed name is already used in local context.
// pr: PR of the name we want to check
// err: will be returned (wrapped in beautiful error) if collision was NOT in type-parameter,
// must be defined depending on call context
func (lrc *LocalResolveContext) checkArgsCollision(name string, pr tlast.PositionRange, err error) error {
	if nat, ok := lrc.localNatArgs[name]; ok {
		e1 := pr.BeautifulError(err)
		e2 := nat.NamePR.BeautifulError(errSeeHere)
		return tlast.BeautifulError2(e1, e2)
	}
	if typ, ok := lrc.localTypeArgs[name]; ok {
		e1 := pr.BeautifulError(errTypeParamNameCollision)
		e2 := typ.PR.BeautifulError(errSeeHere)
		return tlast.BeautifulError2(e1, e2)
	}
	return nil
}

type LocalNatArg struct {
	wrongTypeErr error // we must add all field names to local context, because they must correctly shadow names outside, but we check the type

	NamePR tlast.PositionRange
	TypePR tlast.PositionRange
	natArg ActualNatArg
}

type LocalTypeArg struct {
	arg     ResolvedArgument
	PR      tlast.PositionRange // original template arg reference
	natArgs []ActualNatArg      // nat args associated with this type argument, if type argument itself has some nat args
}

type ResolvedArgument struct {
	isNat   bool
	isArith bool
	Arith   tlast.Arithmetic
	tip     *TypeRWWrapper
	bare    bool // vector Int is not the same as vector int, we must capture the difference somewhere
}

type ActualNatArg struct {
	isArith    bool
	Arith      tlast.Arithmetic
	isField    bool // otherwise it is # param with name
	FieldIndex int
	name       string // param name
}

type HalfResolvedArgument struct { // TODO - better name
	Name string                 // if empty, this is not argument position
	Args []HalfResolvedArgument // recursion
}

type InternalNamespace struct {
	DebugID      int   // for identification in logs
	FloodCounter int64 // beware!

	Namespaces    map[string]struct{}
	DirectImports *DirectImports
	Types         []*TypeRWWrapper

	SubPath string
	Name    string
}

func (n *InternalNamespace) Prefix(directImports *DirectImports, in *InternalNamespace) string {
	if n == in {
		return ""
	}
	directImports.ns[n] = struct{}{}
	return n.Name + "."
}

func (n *InternalNamespace) ImportsSingleNamedNamespace() (empty bool, name string) {
	for nn := range n.Namespaces {
		if nn == "" {
			empty = true
			continue
		}
		if name != "" {
			return empty, ""
		}
		name = nn
	}
	return empty, name
}

var floodCounter atomic.Int64 // TODO - move somewhere

func (n *InternalNamespace) FindRecursiveImports(ri map[*InternalNamespace][]*InternalNamespace, replace *InternalNamespace) {
	for k := range ri {
		delete(ri, k)
	}
	fc := floodCounter.Add(1)
	for k := range n.DirectImports.ns {
		if k != replace {
			k.findRecursiveImports(fc, n, ri, replace, n)
		}
	}
	if replace != nil {
		for k := range replace.DirectImports.ns {
			if k != n {
				k.findRecursiveImports(fc, n, ri, replace, n)
			}
		}
	}
}

func (n *InternalNamespace) findRecursiveImports(floodCounter int64, parent *InternalNamespace, ri map[*InternalNamespace][]*InternalNamespace, replace *InternalNamespace, with *InternalNamespace) {
	if n.FloodCounter >= floodCounter {
		return // visited already
	}
	n.FloodCounter = floodCounter
	ri[n] = append(ri[n], parent)
	for k := range n.DirectImports.ns {
		kk := k.replace(replace, with)
		kk.findRecursiveImports(floodCounter, n, ri, replace, with)
	}
}

func (n InternalNamespace) String() string {
	var s strings.Builder
	s.WriteString(fmt.Sprintf("id %d types: ", n.DebugID))
	s.WriteString(strings.Join(n.sortedElements(), ":"))
	s.WriteString("\nnamespaces: ")
	s.WriteString(strings.Join(n.sortedNamespaces(), ","))
	s.WriteString(fmt.Sprintf(" fc=%d\ndirect: ", n.FloodCounter))
	s.WriteString(strings.Join(n.sortedDirectElements(), ","))
	s.WriteString("\nrecursive: ")
	s.WriteString(strings.Join(n.sortedRecursiveElements(), ","))
	s.WriteString("\n")
	return s.String()
}

func (n *InternalNamespace) replace(replace *InternalNamespace, with *InternalNamespace) *InternalNamespace {
	if n == replace {
		return with
	}
	return n
}

// do not forget to remove from []*InternalNamespace after call
func (n *InternalNamespace) mergeFrom(from *InternalNamespace, internalNamespaces []*InternalNamespace) {
	into := n
	for _, t := range from.Types {
		into.Types = append(into.Types, t)
		t.ins = into
	}
	for nn := range from.Namespaces {
		n.Namespaces[nn] = struct{}{}
	}
	for nn := range from.DirectImports.ns {
		if nn != into {
			into.DirectImports.ns[nn] = struct{}{}
		}
	}
	into.DirectImports.importSort = into.DirectImports.importSort || from.DirectImports.importSort
	for _, ins := range internalNamespaces {
		if _, ok := ins.DirectImports.ns[from]; ok {
			if ins != into {
				ins.DirectImports.ns[into] = struct{}{}
			}
			// for k2 := range n.DirectImports {
			//	ins.DirectImports[k2] = struct{}{}
			// }
			delete(ins.DirectImports.ns, from)
		}
	}
}

func (n *InternalNamespace) sortedElements() []string {
	var elements []string
	for _, t := range n.Types {
		elements = append(elements, t.goGlobalName) // TODO - change to tlName.String() and fix problems
	}
	slices.Sort(elements)
	return elements
}

func (n *InternalNamespace) sortedRecursiveElements() []string {
	var elements []string
	ri := map[*InternalNamespace][]*InternalNamespace{}
	n.FindRecursiveImports(ri, nil)
	for r := range ri {
		var inside []string
		for _, t := range r.Types {
			inside = append(inside, t.goGlobalName)
		}
		slices.Sort(inside)
		elements = append(elements, strings.Join(inside, ":"))
	}
	slices.Sort(elements)
	return elements
}

func (n *InternalNamespace) sortedDirectElements() []string {
	var elements []string
	for r := range n.DirectImports.ns {
		var inside []string
		for _, t := range r.Types {
			inside = append(inside, t.goGlobalName)
		}
		slices.Sort(inside)
		elements = append(elements, strings.Join(inside, ":"))
	}
	slices.Sort(elements)
	return elements
}

func (n *InternalNamespace) sortedNamespaces() []string {
	var elements []string
	for n := range n.Namespaces {
		elements = append(elements, n)
	}
	slices.Sort(elements)
	return elements
}

type Namespace struct {
	types        []*TypeRWWrapper
	cppTemplates map[string]*TypeRWWrapper // canonical C++ template names like cross, cross<I,J>, cross<i>, cross<J> to avoid duplicates
	decGo        Deconflicter
	decCpp       Deconflicter
}

type Gen2Options struct {
	// General
	Language          string
	Outdir            string
	CopyrightFilePath string
	WarningsAreErrors bool
	Verbose           bool
	ErrorWriter       io.Writer // all Errors and warnings should be redirected to this io.Writer, by default it is os.Stderr

	// Go
	BasicPackageNameFull   string // if empty, will be created
	TLPackageNameFull      string
	GenerateRPCCode        bool
	BasicRPCPath           string
	BytesVersions          string
	TypesWhileList         string
	SplitInternal          bool
	GenerateRandomCode     bool
	GenerateLegacyJsonRead bool
	SchemaDocumentation    bool
	SchemaURL              string
	SchemaTimestamp        uint // for TLO version/date
	SchemaCommit           string

	// C++
	RootCPPNamespace string

	// .tlo
	TLOPath           string
	CanonicalFormPath string // combinators in canonical form, with comment of source schema file path
}

type Gen2 struct {
	// options
	options *Gen2Options // pointer so code modifying options in GenerateCode refers to the same structure

	// artifacts
	RootPackageName string

	// golang specific
	BasicPackageNameFull string // basic types are in separate namespace to minimize conflicts
	GlobalPackageName    string // we generate all go types in this package, because we need circular dependencies
	FactoryPackageName   string
	MetaPackageName      string

	// c++ specific
	RootCPPNamespaceElements    []string
	DetailsCPPNamespaceElements []string
	DetailsCPPNamespace         string // basictl::details

	// parsed TL
	supportedAnnotations map[string]int
	typeDescriptors      map[string][]*tlast.Combinator
	singleConstructors   map[string]*tlast.Combinator // only types with 1 constructor, no functions
	allConstructors      map[string]*tlast.Combinator // for printing beautiful errors
	allAnnotations       []string                     // position is bit

	// generation
	builtinTypes       map[string]*TypeRWWrapper
	generatedTypes     map[string]*TypeRWWrapper
	generatedTypesList []*TypeRWWrapper // we need more deterministic order than sort predicate can establish

	globalDec  Deconflicter
	Namespaces map[string]*Namespace // Handlers Code is inside

	// result
	TLO           []byte            // schema represented in tlo format, described using tls.* combinator
	Code          map[string]string // fileName->Content, split by file names relative to output dir
	copyrightText string
}

func (gen *Gen2) InternalPrefix() string {
	if gen.options.SplitInternal {
		return "internal."
	}
	return ""
}

func canonicalGoName(name tlast.Name, insideNamespace string) string {
	if name.Namespace == insideNamespace {
		return CNameToCamelName(name.Name)
	}
	return CNameToCamelName(name.Namespace) + CNameToCamelName(name.Name)
}

func (gen *Gen2) getNamespace(n string) *Namespace {
	na, ok := gen.Namespaces[n]
	if !ok {
		na = &Namespace{cppTemplates: map[string]*TypeRWWrapper{}}
		gen.Namespaces[n] = na
		// TODO - ALL golang-specific names
		na.decGo.deconflictName("Handler")
		na.decGo.deconflictName("Handle")
		na.decGo.deconflictName("Client")
		// TODO - if we want lowercase C++ identifiers, we need to add ~100 reserved keywords here
		// na.decCpp.deconflictName("double")
		// na.decCpp.deconflictName("int")
		// etc...
	}
	return na
}

func checkTagCollisions(tl tlast.TL) error {
	constructorTags := map[uint32]*tlast.Combinator{}
	for _, typ := range tl {
		crc32 := typ.Crc32()
		if crc32 == 0 {
			// typeA#00000000 = TypeA;
			return typ.Construct.IDPR.BeautifulError(fmt.Errorf("constructor tag 0 is prohibited, even if generated implicitly"))
		}
		if col, ok := constructorTags[crc32]; ok {
			// typeA#dfc15abf = TypeA;
			// typeB#dfc15abf = TypeB;
			e1 := typ.Construct.IDPR.BeautifulError(fmt.Errorf("constructor tag #%08x used by %q is used again by %q", crc32, col.Construct.Name.String(), typ.Construct.Name.String()))
			e2 := col.Construct.IDPR.BeautifulError(errSeeHere)
			return tlast.BeautifulError2(e1, e2)
		}
		constructorTags[crc32] = typ
	}
	return nil
}

func checkNamespaceCollisions(tl tlast.TL) error {
	namespaces := map[string]struct {
		s  string
		pr tlast.PositionRange
	}{}
	for _, typ := range tl {
		ns := strings.ToLower(typ.Construct.Name.Namespace)
		if col, ok := namespaces[ns]; ok && col.s != typ.Construct.Name.Namespace {
			e1 := typ.Construct.NamePR.BeautifulError(fmt.Errorf("namespaces must not differ by only case"))
			e2 := col.pr.BeautifulError(errSeeHere)
			return tlast.BeautifulError2(e1, e2)
		}
		namespaces[ns] = struct {
			s  string
			pr tlast.PositionRange
		}{typ.Construct.Name.Namespace, typ.Construct.NamePR}
		ns = strings.ToLower(typ.TypeDecl.Name.Namespace)
		if col, ok := namespaces[ns]; ok && col.s != typ.TypeDecl.Name.Namespace {
			e1 := typ.TypeDecl.NamePR.BeautifulError(fmt.Errorf("namespaces must not differ by only case"))
			e2 := col.pr.BeautifulError(errSeeHere)
			return tlast.BeautifulError2(e1, e2)
		}
		namespaces[ns] = struct {
			s  string
			pr tlast.PositionRange
		}{typ.TypeDecl.Name.Namespace, typ.TypeDecl.NamePR}
	}
	return nil
}

func (gen *Gen2) buildMapDescriptors(tl tlast.TL) error {
	// Collect unions, check that functions cannot form a union with each other or with normal singleConstructors
	for _, typ := range tl {
		for _, f := range typ.Fields {
			if f.FieldName == "" && (len(typ.Fields) != 1 || f.Mask != nil) {
				return f.PR.BeautifulError(fmt.Errorf("anonymous fields are discouraged, except when used in '# a:[int]' pattern or when type has single anonymous field without fieldmask (typedef-like)"))
			}
		}
		conName := typ.Construct.Name.String()
		if col, ok := gen.allConstructors[conName]; ok {
			// typeA = TypeA;
			// typeA = TypeB;
			e1 := typ.Construct.NamePR.BeautifulError(fmt.Errorf("constructor name %q is used again here", conName))
			e2 := col.Construct.NamePR.BeautifulError(errSeeHere)
			return tlast.BeautifulError2(e1, e2)
		}
		gen.allConstructors[conName] = typ
		if !typ.IsFunction {
			typeName := typ.TypeDecl.Name.String()
			if len(typ.TemplateArguments) > len(typ.TypeDecl.Arguments) {
				// rightLeftArgs {X:Type} {Y:#} = RightLeftArgs X; <- bad
				arg := typ.TemplateArguments[len(typ.TypeDecl.Arguments)]
				return typ.TypeDecl.PR.CollapseToEnd().BeautifulError(fmt.Errorf("type declaration %q is missing template argument %q here", typeName, arg.FieldName))
			}
			if len(typ.TemplateArguments) < len(typ.TypeDecl.Arguments) {
				// rightLeftArgs {X:Type} {Y:#} = RightLeftArgs X Y Y; <- bad
				arg := typ.TypeDecl.Arguments[len(typ.TemplateArguments)]
				pr := typ.TypeDecl.ArgumentsPR[len(typ.TemplateArguments)]
				return pr.BeautifulError(fmt.Errorf("type declaration %q has excess template argument %q here", typeName, arg))
			}
			for j, t := range typ.TemplateArguments {
				if t.FieldName != typ.TypeDecl.Arguments[j] {
					// rightLeftArgs {X:Type} {Y:#} = RightLeftArgs Y X;   <- bad
					pr := typ.TypeDecl.ArgumentsPR[j]
					typArg := typ.TypeDecl.Arguments[j]
					e1 := pr.BeautifulError(fmt.Errorf("type declaration %q has wrong template argument name %q here", typeName, typArg))
					e2 := t.PR.BeautifulError(errSeeHere)
					return tlast.BeautifulError2(e1, e2)
				}
			}
			if typeName != "_" { // prohibit boxed type
				gen.typeDescriptors[typeName] = append(gen.typeDescriptors[typeName], typ)
			}
		} else {
			if len(typ.Modifiers) == 0 {
				e1 := typ.Construct.NamePR.CollapseToBegin().BeautifulError(fmt.Errorf("function constructor %q without modifier (identifier starting with '@') not recommended", typ.Construct.Name.String()))
				if gen.options.WarningsAreErrors {
					return e1
				}
				e1.PrintWarning(gen.options.ErrorWriter, nil)
			}
		}
	}
	for _, typ := range gen.typeDescriptors {
		if len(typ) == 1 { // here there is no functions
			cName := typ[0].Construct.Name
			tName := typ[0].TypeDecl.Name
			typePrefix := strings.ToLower(ToLowerFirst(tName.Name))

			if cName.Namespace != tName.Namespace {
				e1 := typ[0].Construct.NamePR.BeautifulError(fmt.Errorf("simple type constructor namespace should exactly match type namespace"))
				e2 := typ[0].TypeDecl.NamePR.BeautifulError(errSeeHere)
				return tlast.BeautifulError2(e1, e2)
			}
			// We temporarily allow relaxed case match. To use strict match, remove strings.ToLower() calls below
			if EnableWarningsSimpleTypeName && strings.ToLower(cName.Name) != typePrefix &&
				!EnableWarningsSimpleTypeNameSkipLegacy(cName.String()) {
				e1 := typ[0].Construct.NamePR.BeautifulError(fmt.Errorf("simple type constructor name should differ from type name by case only"))
				e2 := typ[0].TypeDecl.NamePR.BeautifulError(errSeeHere)
				if gen.options.WarningsAreErrors {
					return tlast.BeautifulError2(e1, e2)
				}
				tlast.BeautifulError2(e1, e2).PrintWarning(gen.options.ErrorWriter, nil)
			}
			conName := cName.String()
			if col, ok := gen.singleConstructors[conName]; ok {
				e1 := typ[0].Construct.NamePR.BeautifulError(fmt.Errorf("constructor name %q is used again here", conName))
				e2 := col.Construct.NamePR.BeautifulError(errSeeHere)
				// TODO: not sure that this code ever runs, as we have same check on gen.allConstructors
				//       in Gen2.buildMapDescriptors method
				//       use panic to catch such case, remove it later
				err := tlast.BeautifulError2(e1, e2)
				var s strings.Builder
				err.ConsolePrint(&s, err, false)
				panic(s.String())
				// return tlast.BeautifulError2(e1, e2)
			}
			gen.singleConstructors[conName] = typ[0]
			continue
		}
		if err := checkUnionElementsCompatibility(typ, gen.options); err != nil {
			return err
		}
	}
	return nil
}

func checkUnionElementsCompatibility(types []*tlast.Combinator, options *Gen2Options) error {
	// We temporarily allow relaxed case match. To use strict match, remove strings.ToLower() calls below
	typePrefix := strings.ToLower(ToLowerFirst(types[0].TypeDecl.Name.Name))
	typeSuffix := strings.ToLower(types[0].TypeDecl.Name.Name)
	for _, typ := range types {
		conName := strings.ToLower(typ.Construct.Name.Name)
		if EnableWarningsUnionNamespace && typ.Construct.Name.Namespace != typ.TypeDecl.Name.Namespace &&
			!EnableWarningsUnionNamespaceSkipLegacy(typ.Construct.Name.Namespace, typ.TypeDecl.Name.Namespace) {
			e1 := typ.Construct.NamePR.BeautifulError(fmt.Errorf("union constructor namespace %q should match type namespace %q", typ.Construct.Name.Namespace, typ.TypeDecl.Name.Namespace))
			e2 := typ.TypeDecl.NamePR.BeautifulError(errSeeHere)
			if options.WarningsAreErrors {
				return tlast.BeautifulError2(e1, e2)
			}
			tlast.BeautifulError2(e1, e2).PrintWarning(options.ErrorWriter, nil)
		}
		if EnableWarningsUnionNamePrefix &&
			!strings.HasPrefix(conName, typePrefix) &&
			!strings.HasSuffix(conName, typeSuffix) &&
			!EnableWarningsUnionNamePrefixSkipLegacy(typ.Construct.Name.Name, typePrefix, typeSuffix) { // same check as in generateType
			e1 := typ.Construct.NamePR.BeautifulError(fmt.Errorf("union constructor should have type name prefix or suffix %q", typePrefix))
			e2 := typ.TypeDecl.NamePR.BeautifulError(errSeeHere)
			if options.WarningsAreErrors {
				return tlast.BeautifulError2(e1, e2)
			}
			tlast.BeautifulError2(e1, e2).PrintWarning(options.ErrorWriter, nil)
			continue
		}
		if EnableWarningsUnionNameExact && conName == typePrefix &&
			!EnableWarningsUnionNameExactSkipLegacy(typ.Construct.Name.String()) {
			e1 := typ.Construct.NamePR.BeautifulError(fmt.Errorf("union constructor name should not exactly match type name %q", typePrefix))
			e2 := typ.TypeDecl.PR.BeautifulError(errSeeHere)
			if options.WarningsAreErrors {
				return tlast.BeautifulError2(e1, e2)
			}
			tlast.BeautifulError2(e1, e2).PrintWarning(options.ErrorWriter, nil)
		}
	}
	base := types[0]
	for _, typ := range types[1:] {
		cur := typ.Construct.Name.String()
		if len(typ.TemplateArguments) < len(base.TemplateArguments) {
			baseArg := base.TemplateArguments[len(typ.TemplateArguments)]
			// unionArgs2 {A:Type} {B:#} a:A = UnionArgs A B;
			// unionArgs1 {X:Type} a:X = UnionArgs X;
			e1 := typ.TemplateArgumentsPR.CollapseToEnd().BeautifulError(fmt.Errorf("union constructor %q has missing argument %q here", cur, baseArg.FieldName))
			e2 := baseArg.PR.BeautifulError(errSeeHere)
			return tlast.BeautifulError2(e1, e2)
		}
		if len(typ.TemplateArguments) > len(base.TemplateArguments) {
			typArg := typ.TemplateArguments[len(base.TemplateArguments)]
			// unionArgs1 {X:Type} a:X = UnionArgs X;
			// unionArgs2 {A:Type} {B:#} a:A = UnionArgs A B;
			e1 := typArg.PR.BeautifulError(fmt.Errorf("union constructor %q has excess argument %q here", cur, typArg.FieldName))
			e2 := base.TemplateArgumentsPR.CollapseToEnd().BeautifulError(errSeeHere)
			return tlast.BeautifulError2(e1, e2)
		}
		for i, typArg := range typ.TemplateArguments {
			baseArg := base.TemplateArguments[i]
			// unionArgs1 {X:Type} {Y:#} a:X = UnionArgs X Y;
			// unionArgs2 {A:Type} {B:Type} a:A = UnionArgs A B;
			// We cannot support this, because resolveType replaces parameter names into names of first union field
			if baseArg.IsNat != typArg.IsNat || baseArg.FieldName != typArg.FieldName {
				e1 := typArg.PR.BeautifulError(fmt.Errorf("union constructor %q has different argument name or type here %q", cur, typArg.FieldName))
				e2 := baseArg.PR.BeautifulError(errSeeHere)
				return tlast.BeautifulError2(e1, e2)
			}
		}
	}
	return nil
}

func inBytesVersionFilter(name tlast.Name, filter string) bool {
	if strings.HasSuffix(filter, ".") && name.Namespace == strings.TrimSuffix(filter, ".") {
		return true
	}
	if !strings.HasSuffix(filter, ".") && name.String() == filter {
		return true
	}
	return false
}

func collectRelativePaths(absDirName string, relDirName string, relativeFiles map[string]bool, relativeDirs *[]string) error {
	fis, err := os.ReadDir(absDirName)
	if err != nil {
		return err
	}
	for _, fi := range fis { // try all snapshots, loading the latest
		relFilename := filepath.Join(relDirName, fi.Name())
		absFilename := filepath.Join(absDirName, fi.Name())
		if fi.IsDir() {
			*relativeDirs = append(*relativeDirs, relFilename)
			if err = collectRelativePaths(absFilename, relFilename, relativeFiles, relativeDirs); err != nil {
				return err
			}
			continue
		}
		relativeFiles[relFilename] = true
	}
	return nil
}

// WriteToDir Most common action with generated code, so clients do not repeat it
func (gen *Gen2) WriteToDir(outdir string) error {
	if err := os.Mkdir(outdir, 0755); err != nil && !os.IsExist(err) { // we thus require parent directory to exist
		return fmt.Errorf("error creating outdir %q: %w", outdir, err)
	}
	// We do not want to touch files which did not change at all.
	relativeFiles := map[string]bool{}
	var relativeDirs []string
	if err := collectRelativePaths(outdir, "", relativeFiles, &relativeDirs); err != nil {
		return fmt.Errorf("error reading outdir content %q: %w", outdir, err)
	}
	if len(relativeFiles) != 0 && !relativeFiles[markerFile] {
		return fmt.Errorf("outdir %q not empty and has no %q marker file, please clean manually", outdir, markerFile)
	}
	markerContent := fmt.Sprintf(buildVersionFormat,
		strings.TrimSpace(TLGenVersion()),
		strings.TrimSpace(gen.options.SchemaURL),
		strings.TrimSpace(gen.options.SchemaCommit),
		gen.options.SchemaTimestamp, time.Unix(int64(gen.options.SchemaTimestamp), 0).UTC())
	if err := gen.addCodeFile(markerFile, markerContent); err != nil {
		return err
	}
	notTouched := 0
	written := 0
	deleted := 0
	for filepathName, code := range gen.Code {
		d := filepath.Join(outdir, filepath.Dir(filepathName))
		if err := os.MkdirAll(d, 0755); err != nil && !os.IsExist(err) {
			return fmt.Errorf("error creating dir %q: %w", d, err)
		}
		f := filepath.Join(outdir, filepathName)
		if relativeFiles[filepathName] {
			delete(relativeFiles, filepathName)
			was, err := os.ReadFile(f)
			if err != nil {
				return fmt.Errorf("error reading previous file %q: %w", f, err)
			}
			if string(was) == code {
				notTouched++
				continue
			}
		}
		written++
		if err := os.WriteFile(f, []byte(code), 0644); err != nil {
			return fmt.Errorf("error writing file %q: %w", f, err)
		}
	}
	for filepathName := range relativeFiles {
		deleted++
		f := filepath.Join(outdir, filepathName)
		if err := os.Remove(f); err != nil {
			return fmt.Errorf("error deleting previous file %q: %w", f, err)
		}
	}
	for i := len(relativeDirs) - 1; i >= 0; i-- {
		f := filepath.Join(outdir, relativeDirs[i])
		_ = os.Remove(f) // non-empty dirs simply will not remove. This is good enough for us
	}
	fmt.Printf("%d target files did not change so were not touched, %d written, %d deleted\n", notTouched, written, deleted)
	return nil
}

func (gen *Gen2) addCodeFile(filepathName string, code string) error {
	if _, ok := gen.Code[filepathName]; ok {
		return fmt.Errorf("generator %sinternal error%s: source file %q is generated twice", color.Red, color.Reset, filepathName)
	}
	gen.Code[filepathName] = code
	return nil
}

func GenerateCode(tl tlast.TL, options Gen2Options) (*Gen2, error) {
	gen := &Gen2{
		options:    &options,
		Code:       map[string]string{},
		Namespaces: map[string]*Namespace{},
		// Files:                 map[string][]*TypeRWWrapper{},
		typeDescriptors:    map[string][]*tlast.Combinator{},
		singleConstructors: map[string]*tlast.Combinator{},
		allConstructors:    map[string]*tlast.Combinator{},
		builtinTypes:       map[string]*TypeRWWrapper{},
		generatedTypes:     map[string]*TypeRWWrapper{},
	}
	switch options.Language {
	case "": // linting
	case "go":
		if options.GenerateRPCCode && options.BasicRPCPath == "" {
			return nil, fmt.Errorf("--basicRPCPath must be specified if --generateRPCCode is set")
		}
		options.TLPackageNameFull = strings.TrimSpace(options.TLPackageNameFull)
		options.TLPackageNameFull = strings.TrimSuffix(options.TLPackageNameFull, "/")
		if options.TLPackageNameFull == "" { // for testing, empty path should be prohibited in main argv parsing
			options.TLPackageNameFull = "github.com/vkcom/tl/internal/tlcodegen/output/tl"
		}

		elements := strings.Split(options.TLPackageNameFull, "/")
		if len(elements) < 3 {
			return nil, fmt.Errorf("full go package name must have 2 non-empty rightmost path elements, for example '.../output/tl")
		}
		options.TLPackageNameFull = strings.Join(elements[:len(elements)-1], "/")
		gen.GlobalPackageName = elements[len(elements)-1]
		gen.RootPackageName = elements[len(elements)-2]
		gen.FactoryPackageName = strings.Join(append(elements[:len(elements)-1], FactoryGoPackageName), "/")
		gen.MetaPackageName = strings.Join(append(elements[:len(elements)-1], MetaGoPackageName), "/")
		if gen.GlobalPackageName == "" || elements[len(elements)-2] == "" {
			return nil, fmt.Errorf("full go package name must have 2 non-empty rightmost path elements, for example '.../output/tl")
		}
		if gen.options.BasicPackageNameFull == "" {
			gen.BasicPackageNameFull = strings.Join(append(elements[:len(elements)-1], BasicTLGoPackageName), "/")
		} else {
			elements = strings.Split(gen.options.BasicPackageNameFull, "/")
			if len(elements) < 2 || elements[len(elements)-1] != BasicTLGoPackageName {
				return nil, fmt.Errorf("basictl go package name must end with '/%s'", BasicTLGoPackageName)
			}
			gen.BasicPackageNameFull = gen.options.BasicPackageNameFull
		}
	case "cpp":
		if options.RootCPPNamespace == "" {
			options.RootCPPNamespace = "tl2"
		}
		gen.RootCPPNamespaceElements = strings.Split(options.RootCPPNamespace, "::")
		gen.DetailsCPPNamespaceElements = []string{options.RootCPPNamespace, "details"} // TODO - rename to prevent collisions with TL namespace details
		gen.DetailsCPPNamespace = options.RootCPPNamespace + "::details"
	default:
		return nil, fmt.Errorf("unsupported language %q, only 'go' and 'cpp' are supported, plus '' for linting", options.Language)
	}
	typesWhiteList := strings.Split(options.TypesWhileList, ",")
	for i := 0; i < len(typesWhiteList); i++ {
		typesWhiteList[i] = strings.TrimSpace(typesWhiteList[i])
		if len(typesWhiteList[i]) == 0 {
			typesWhiteList = append(typesWhiteList[:i], typesWhiteList[i+1:]...)
		}
	}
	generateByteVersions := strings.Split(options.BytesVersions, ",")
	for i := 0; i < len(generateByteVersions); i++ {
		generateByteVersions[i] = strings.TrimSpace(generateByteVersions[i])
		if len(generateByteVersions[i]) == 0 {
			generateByteVersions = append(generateByteVersions[:i], generateByteVersions[i+1:]...)
		}
	}
	gen.supportedAnnotations = map[string]int{"read": 0, "any": 1, "internal": 2, "write": 3, "readwrite": 4, "kphp": 5}
	rootNamespace := gen.getNamespace("")
	primitiveTypesList := []*TypeRWPrimitive{
		{
			tlType:            "#",
			goType:            "uint32",
			cppPrimitiveType:  "uint32_t",
			cppDefaultInit:    " = 0",
			cppFunctionSuffix: "nat",
			cppResetValue:     "%s = 0;",
			writeJSONValue:    "basictl.JSONWriteUint32",
			readJSONValue:     gen.InternalPrefix() + "JsonReadUint32",
			readJSON2Value:    gen.InternalPrefix() + "Json2ReadUint32",
			resetValue:        "%s = 0",
			randomValue:       "basictl.RandomUint",
			writeValue:        "basictl.NatWrite",
			readValue:         "basictl.NatRead",
		}, {
			tlType:            "int",
			goType:            "int32",
			cppPrimitiveType:  "int32_t",
			cppDefaultInit:    " = 0",
			cppFunctionSuffix: "int",
			cppResetValue:     "%s = 0;",
			writeJSONValue:    "basictl.JSONWriteInt32",
			readJSONValue:     gen.InternalPrefix() + "JsonReadInt32",
			readJSON2Value:    gen.InternalPrefix() + "Json2ReadInt32",
			resetValue:        "%s = 0",
			randomValue:       "basictl.RandomInt",
			writeValue:        "basictl.IntWrite",
			readValue:         "basictl.IntRead",
		}, {
			tlType:            "long",
			goType:            "int64",
			cppPrimitiveType:  "int64_t",
			cppDefaultInit:    " = 0",
			cppFunctionSuffix: "long",
			cppResetValue:     "%s = 0;",
			writeJSONValue:    "basictl.JSONWriteInt64",
			readJSONValue:     gen.InternalPrefix() + "JsonReadInt64",
			readJSON2Value:    gen.InternalPrefix() + "Json2ReadInt64",
			resetValue:        "%s = 0",
			randomValue:       "basictl.RandomLong",
			writeValue:        "basictl.LongWrite",
			readValue:         "basictl.LongRead",
		}, {
			tlType:            "float",
			goType:            "float32",
			cppPrimitiveType:  "float",
			cppDefaultInit:    " = 0",
			cppFunctionSuffix: "float",
			cppResetValue:     "%s = 0;",
			writeJSONValue:    "basictl.JSONWriteFloat32",
			readJSONValue:     gen.InternalPrefix() + "JsonReadFloat32",
			readJSON2Value:    gen.InternalPrefix() + "Json2ReadFloat32",
			resetValue:        "%s = 0",
			randomValue:       "basictl.RandomFloat",
			writeValue:        "basictl.FloatWrite",
			readValue:         "basictl.FloatRead",
		}, {
			tlType:            "double",
			goType:            "float64",
			cppPrimitiveType:  "double",
			cppDefaultInit:    " = 0",
			cppFunctionSuffix: "double",
			cppResetValue:     "%s = 0;",
			writeJSONValue:    "basictl.JSONWriteFloat64",
			readJSONValue:     gen.InternalPrefix() + "JsonReadFloat64",
			readJSON2Value:    gen.InternalPrefix() + "Json2ReadFloat64",
			resetValue:        "%s = 0",
			randomValue:       "basictl.RandomDouble",
			writeValue:        "basictl.DoubleWrite",
			readValue:         "basictl.DoubleRead",
		}, {
			tlType:            "string",
			goType:            "string",
			cppPrimitiveType:  "std::string",
			cppDefaultInit:    "",
			cppFunctionSuffix: "string",
			cppResetValue:     "%s.clear();",
			writeJSONValue:    "basictl.JSONWriteString",
			readJSONValue:     gen.InternalPrefix() + "JsonReadString",
			readJSON2Value:    gen.InternalPrefix() + "Json2ReadString",
			resetValue:        "%s = \"\"",
			randomValue:       "basictl.RandomString",
			writeValue:        "basictl.StringWrite",
			readValue:         "basictl.StringRead",
		},
	}
	builtinBeautifulText := fmt.Sprintf(`
%s {n:#} {t:Type} n*[t] = _ n t; // builtin tuple
%s {t:Type} # [t] = _ t; // builtin vector
`, BuiltinTupleName, BuiltinVectorName)
	primitiveTypes := map[string]*TypeRWPrimitive{}
	for _, cn := range primitiveTypesList {
		builtinBeautifulText += fmt.Sprintf("%s ? = _; // builtin primitive type\n", cn.tlType)
		primitiveTypes[cn.tlType] = cn
	}

	btl, err := tlast.ParseTL2(builtinBeautifulText, "<builtin>", true, false) // We need references to token positions for beautification
	if err != nil {
		return nil, fmt.Errorf("failed to parse internal builtin type representation for beautification: %w", err)
	}
	for i, typ := range tl { // replace built-in
		tName := typ.Construct.Name.String()
		// convert that old syntax to new syntax.
		if !typ.Builtin {
			continue
		}
		if len(typ.TemplateArguments) != 0 {
			return nil, typ.TemplateArgumentsPR.BeautifulError(fmt.Errorf("builtin wrapper %q cannot have template parameters", tName))
		}
		if _, ok := primitiveTypes[tName]; !ok {
			return nil, typ.Construct.NamePR.BeautifulError(fmt.Errorf("builtin wrapper %q must have constructor name equal to some builtin type", tName))
		}
		newDesc := &tlast.Combinator{}
		*newDesc = *tl[i]
		newDesc.OriginalDescriptor = typ
		newDesc.Fields = append(newDesc.Fields, tlast.Field{
			FieldType: tlast.TypeRef{
				Type: tlast.Name{Name: tName},
				Bare: true,
			},
		})
		newDesc.Builtin = false
		tl[i] = newDesc
	}
	if err := checkTagCollisions(tl); err != nil {
		return nil, err
	}
	if err := checkNamespaceCollisions(tl); err != nil {
		return nil, err
	}

	// ReplaceSquareBrackets will generate types with id 0, we will not generate boxed methods for such types
	if tl, err = gen.ReplaceSquareBracketsElem(tl); err != nil {
		return nil, fmt.Errorf("replacing with canonical tuples: %w", err)
	}
	err = gen.buildMapDescriptors(tl)
	if err != nil {
		return nil, err
	}

	// Now we replace all builtin legitimate builtin wrapper constructors to constructors of builtins
	// Int and %Int will reference wrappers, while int will reference builtin constructor.
	// To avoid 2 canonical forms, resolveType will replace %Int to int for wrappers
	for _, bt := range btl {
		var zero uint32
		bt.Construct.ID = &zero
		tName := bt.Construct.Name.String()
		if tName == BuiltinTupleName || tName == BuiltinVectorName {
			gen.allConstructors[tName] = bt
			gen.singleConstructors[tName] = bt
			continue
		}
		cn, ok := primitiveTypes[tName]
		if !ok {
			panic("broken primitive types list")
		}
		wrapper := &TypeRWWrapper{
			gen:          gen,
			ns:           rootNamespace,
			trw:          cn,
			goGlobalName: cn.goType,
			goLocalName:  "",
			fileName:     cn.tlType,
			origTL:       []*tlast.Combinator{bt},
		}
		if cn.tlType == "#" {
			wrapper.fileName = "nat"
		}
		gen.builtinTypes[cn.tlType] = wrapper
		gen.generatedTypesList = append(gen.generatedTypesList, wrapper)
		typ, ok := gen.allConstructors[tName]
		if ok {
			// vasya ? = Int;
			// vasya {T:Type} {N:#} ? = Int T N;
			// int {T:Type} {N:#} int = Int T N;
			// int = Int;
			// int int int = Int;
			// int vasya:int = Int;
			// int n.0?int = Int;
			// int (int 5) = Int;
			// int (%Int) = Int;
			// int (Int) = Int;
			// int ? = Int;   <-- allowed, but deprecated shape. TODO - prohibit in TL2
			// int int = Int; <-- allowed shape
			if len(typ.TemplateArguments) != 0 {
				return nil, typ.TemplateArgumentsPR.BeautifulError(fmt.Errorf("builtin wrapper %q cannot have template parameters", tName))
			}
			if len(typ.Fields) == 0 {
				return nil, typ.TemplateArgumentsPR.CollapseToEnd().BeautifulError(fmt.Errorf("builtin wrapper %q must have exactly 1 field", tName))
			}
			if len(typ.Fields) > 1 {
				return nil, typ.Fields[1].FieldType.PR.BeautifulError(fmt.Errorf("builtin wrapper %q has excess field, must have exactly 1", tName))
			}
			if typ.Fields[0].FieldName != "" {
				return nil, typ.Fields[0].PRName.BeautifulError(fmt.Errorf("builtin wrapper %q field must be anonymous", tName))
			}
			if typ.Fields[0].Mask != nil {
				return nil, typ.Fields[0].Mask.PRName.BeautifulError(fmt.Errorf("builtin wrapper %q field must not use field mask", tName))
			}
			if typ.Fields[0].FieldType.Type.String() != tName || len(typ.Fields[0].FieldType.Args) != 0 { // do not check Bare, because int === %int
				return nil, typ.Fields[0].FieldType.PR.BeautifulError(fmt.Errorf("builtin wrapper %q field type must match constructor name", tName))
			}
			if _, ok := gen.builtinTypes[tName]; !ok {
				return nil, typ.Construct.NamePR.BeautifulError(fmt.Errorf("builtin wrapper %q must have constructor name equal to some builtin type", tName))
			}
		} else {
			gen.allConstructors[tName] = bt
			gen.singleConstructors[tName] = bt
		}
	}

	// tupleDesc := btl[0]
	// vectorDesc := btl[1]
	// gen.singleConstructors[tupleDesc.Construct.Name.String()] = tupleDesc
	// gen.allConstructors[tupleDesc.Construct.Name.String()] = tupleDesc
	// gen.singleConstructors[vectorDesc.Construct.Name.String()] = vectorDesc
	// gen.allConstructors[vectorDesc.Construct.Name.String()] = vectorDesc

	{
		allAnnotations := map[string]struct{}{}
		for _, typ := range tl {
			for _, m := range typ.Modifiers {
				if strings.ToLower(m.Name) != m.Name { // TODO - move into lexer
					return nil, m.PR.BeautifulError(fmt.Errorf("annotations must be lower case"))
				}
				if _, ok := allAnnotations[m.Name]; !ok {
					if _, ok := gen.supportedAnnotations[m.Name]; !ok {
						e1 := m.PR.BeautifulError(fmt.Errorf("annotation %q not known to tl compiler", m.Name))
						if gen.options.WarningsAreErrors {
							return nil, e1
						}
						e1.PrintWarning(options.ErrorWriter, nil)
					}
					allAnnotations[m.Name] = struct{}{}
					gen.allAnnotations = append(gen.allAnnotations, m.Name)
				}
			}
		}
		if len(gen.allAnnotations) > 32 {
			return nil, fmt.Errorf("too many (%d) differnet annotations, max is 32 for now", len(gen.allAnnotations))
		}
		sort.Strings(gen.allAnnotations)
	}
	skippedDueToWhitelist := 0
	for _, typ := range tl {
		if GenerateUnusedNatTemplates(typ.Construct.Name.String()) && len(typ.TemplateArguments) == 1 && typ.TemplateArguments[0].IsNat {
			t := tlast.TypeRef{Type: typ.TypeDecl.Name, PR: typ.TypeDecl.PR}
			argT := tlast.TypeRef{Type: tlast.Name{
				Namespace: "",
				Name:      "ArgumentN",
			}}
			t.Args = append(t.Args, tlast.ArithmeticOrType{
				IsArith: false,
				T:       argT,
			})
			lrc := LocalResolveContext{allowAnyConstructor: true, localNatArgs: map[string]LocalNatArg{}}
			lrc.localNatArgs["ArgumentN"] = LocalNatArg{
				natArg: ActualNatArg{isField: true, FieldIndex: 0},
			}
			_, _, _, _, err = gen.getType(lrc, t, nil)
			if err != nil {
				return nil, err
			}
		}
		shouldGenerate := options.TypesWhileList == ""
		whiteListName := typ.Construct.Name
		if !typ.IsFunction {
			whiteListName = typ.TypeDecl.Name
		}
		for _, bv := range generateByteVersions {
			if inBytesVersionFilter(whiteListName, bv) {
				shouldGenerate = true
			}
		}
		for _, bv := range typesWhiteList {
			if inBytesVersionFilter(whiteListName, bv) {
				shouldGenerate = true
			}
		}
		if !shouldGenerate {
			skippedDueToWhitelist++
			continue
		}
		if len(typ.TemplateArguments) == 0 {
			t := tlast.TypeRef{Type: typ.Construct.Name, PR: typ.Construct.NamePR}
			if !typ.IsFunction {
				t = tlast.TypeRef{Type: typ.TypeDecl.Name, PR: typ.TypeDecl.PR}
			}
			_, _, _, _, err = gen.getType(LocalResolveContext{allowAnyConstructor: true}, t, nil)
			if err != nil {
				return nil, err
			}
		}
	}
	bytesChildren := map[*TypeRWWrapper]bool{}
	typesCounterMarkBytes := 0
	// This loop can be before or after loops below, it is convenient to fill sortedTypes inside, so this loop is here
	for _, v := range gen.generatedTypesList {
		for _, bv := range generateByteVersions {
			if inBytesVersionFilter(v.tlName, bv) {
				v.MarkWantsBytesVersion(bytesChildren)
				typesCounterMarkBytes++
			}
		}
	}
	slices.SortStableFunc(gen.generatedTypesList, func(a, b *TypeRWWrapper) int { //  TODO - better idea?
		return TypeRWWrapperLessGlobal(a, b)
	})
	sortedTypes := gen.generatedTypesList
	// for _, st := range sortedTypes {
	//	fmt.Printf("sorted type %q\n", st.localTypeArg.rt.String())
	// }
	for _, v := range sortedTypes {
		// fmt.Printf("type %s names %s %s %d\n", v.CanonicalStringTop(), v.goGlobalName, v.tlName.String(), v.tlTag)
		// if len(v.origTL) <= 1 {
		//	fmt.Printf("     %s\n", v.CanonicalString(true))
		// } else {
		//	fmt.Printf("     %s\n", v.CanonicalString(false))
		// }
		// r # [r] = S;
		visitedNodes := map[*TypeRWWrapper]bool{}
		v.trw.fillRecursiveUnwrap(visitedNodes)
		v.preventUnwrap = visitedNodes[v]
		if v.preventUnwrap {
			fmt.Printf("prevented unwrap of %v\n", v.tlName)
		}
	}
	// in BeforeCodeGenerationStep we split recursion. Which links will be broken depends on order of nodes visited
	for _, v := range sortedTypes {
		v.trw.BeforeCodeGenerationStep1()
	}
	// in BeforeCodeGenerationStep2 we split recursion in unions.
	for _, v := range sortedTypes {
		v.trw.BeforeCodeGenerationStep2()
	}
	// we link normal and long types for VK int->long conversion. This code is VK-specific and will be removed after full migration
	for _, v := range sortedTypes {
		// @readwrite queueLong.getQueueKey id:long ip:int timeout:int queue:string = queueLong.TimestampKey;
		// @readwrite queue.getQueueKey id:int ip:int timeout:int queue:string = queue.TimestampKey;
		longName := v.CanonicalStringTop()
		argsStart := strings.Index(longName, "<")
		if argsStart < 0 {
			argsStart = len(longName)
		}
		if i := strings.Index(longName[:argsStart], "."); i >= 0 {
			longName = longName[:i] + "Long" + longName[i:]

			if tt, ok := gen.generatedTypes[longName]; ok {
				// log.Printf("long name %s discovered for %s", longName, v.CanonicalStringTop())
				v.WrLong = tt
				tt.WrWithoutLong = v
			}
		}

		v.trw.BeforeCodeGenerationStep2()
	}
	// Order of these 2 loops is important, for example see TypeRWTuple where bytes version depends on whether it is dict_like
	for _, v := range sortedTypes {
		visitedNodes := map[*TypeRWWrapper]bool{}
		v.hasBytesVersion = v.MarkHasBytesVersion(visitedNodes)
		visitedNodes = map[*TypeRWWrapper]bool{}
		v.hasErrorInWriteMethods = v.MarkWriteHasError(visitedNodes)
	}
	// detect recursion loops first
	if options.Verbose {
		if skippedDueToWhitelist != 0 {
			log.Printf("skipped %d object roots by the whitelist filter: %s", skippedDueToWhitelist, strings.Join(typesWhiteList, ", "))
		}
		if filter := strings.Join(generateByteVersions, ", "); filter != "" {
			log.Printf("found %d object roots for byte-optimized versions of types by the following filter: %s", typesCounterMarkBytes, filter)
		}
	}
	if gen.options.CopyrightFilePath != "" {
		buf, err := os.ReadFile(gen.options.CopyrightFilePath)
		if err != nil {
			return nil, fmt.Errorf("failed to open copyright text file: %w", err)
		}
		gen.copyrightText = string(buf)
	}
	switch options.Language {
	case "go":
		if err := gen.generateCodeGolang(generateByteVersions); err != nil {
			return nil, err
		}
	case "cpp":
		if err := gen.generateCodeCPP(generateByteVersions); err != nil {
			return nil, err
		}
	}

	if options.SchemaDocumentation {
		if err := gen.addCodeFile(TlJSONHTML, tlJSON(gen, TLGenVersion())); err != nil {
			return nil, err
		}
	}

	return gen, nil
}
