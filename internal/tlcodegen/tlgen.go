// Copyright 2022 V Kontakte LLC
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package tlcodegen

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"
	"sync/atomic"

	"golang.org/x/exp/slices"

	"github.com/TwiN/go-color"

	"github.com/vkcom/tl/internal/tlast"
	"github.com/vkcom/tl/internal/utils"
)

const BuiltinTupleName = "__tuple"
const BuiltinVectorName = "__vector"
const BasicTLGoPackageName = "basictl" // does not contain tl prefix
const FactoryGoPackageName = "factory" // does not contain tl prefix
const MetaGoPackageName = "meta"       // does not contain tl prefix
const ConstantsPackageName = "constants"
const BasicTLCPPNamespaceName = "basictl" // does not contain tl prefix
const HeaderComment = "// Code generated by vktl/cmd/tlgen2; DO NOT EDIT."
const markerFile = "tlgen2_version.txt"

const (
	jsonExt = ".json"
	tloExt  = ".tlo"
	goExt   = ".go"
	cppExt  = ".cpp"
	hppExt  = ".hpp"
)

const TlJSONHTML = "tljson.html"

// Do not forget to bump version when making changes.
// We do not want repository hash, because it advances automatically each time ANYTHING in repository changes, not only tlgen2.
// And we do not want stable checksum of go files tlgen folder, because checksums are not comparable and there is no idea how old that version is
const buildVersionString = "tlgen2 version 2022.06.30, hash of source code - "

var buildSHA256Checksum = "" // filled when building

var (
	errSeeHere                = fmt.Errorf("see here")
	errFieldNameCollision     = fmt.Errorf("field name collision")
	errNatParamNameCollision  = fmt.Errorf("nat-parametr name collision")
	errTypeParamNameCollision = fmt.Errorf("type-parametr name collision ")
)

type LocalResolveContext struct {
	localTypeArgs map[string]LocalTypeArg
	localNatArgs  map[string]LocalNatArg

	allowAnyConstructor bool   // we can reference all constructors (functions, union elements) directly internally
	overrideFileName    string // used for unions and built-in vectors and tuples, so they are defined in the file of argument
}

// checkArgsCollision checks if passed name is already used in local context.
// pr: PR of the name we want to check
// err: will be returned (wrapped in beautiful error) if collision was NOT in type-parameter,
// must be defined depending on call context
func (lrc *LocalResolveContext) checkArgsCollision(name string, pr tlast.PositionRange, err error) error {
	if nat, ok := lrc.localNatArgs[name]; ok {
		e1 := pr.BeautifulError(err)
		e2 := nat.NamePR.BeautifulError(errSeeHere)
		return tlast.BeautifulError2(e1, e2)
	}
	if typ, ok := lrc.localTypeArgs[name]; ok {
		e1 := pr.BeautifulError(errTypeParamNameCollision)
		e2 := typ.PR.BeautifulError(errSeeHere)
		return tlast.BeautifulError2(e1, e2)
	}
	return nil
}

type LocalNatArg struct {
	wrongTypeErr error // we must add all field names to local context, because they must correctly shadow names outside, but we check the type

	NamePR tlast.PositionRange
	TypePR tlast.PositionRange
	natArg ActualNatArg
}

type LocalTypeArg struct {
	arg     ResolvedArgument
	PR      tlast.PositionRange // original template arg reference
	natArgs []ActualNatArg      // nat args associated with this type argument, if type argument itself has some nat args
}

type ResolvedArgument struct {
	isNat   bool
	isArith bool
	Arith   tlast.Arithmetic
	tip     *TypeRWWrapper
	bare    bool // vector Int is not the same as vector int, we must capture the difference somewhere
}

type ActualNatArg struct {
	isArith    bool
	Arith      tlast.Arithmetic
	isField    bool // otherwise it is # param with name
	FieldIndex int
	name       string // param name
}

type InternalNamespace struct {
	DebugID      int   // for identification in logs
	FloodCounter int64 // beware!

	Namespaces    map[string]struct{}
	DirectImports *DirectImports
	Types         []*TypeRWWrapper

	SubPath string
	Name    string
}

func (n *InternalNamespace) Prefix(directImports *DirectImports, in *InternalNamespace) string {
	if n == in {
		return ""
	}
	directImports.ns[n] = struct{}{}
	return n.Name + "."
}

func (n *InternalNamespace) ImportsSingleNamedNamespace() (empty bool, name string) {
	for nn := range n.Namespaces {
		if nn == "" {
			empty = true
			continue
		}
		if name != "" {
			return empty, ""
		}
		name = nn
	}
	return empty, name
}

var floodCounter atomic.Int64 // TODO - move somewhere

func (n *InternalNamespace) FindRecursiveImports(ri map[*InternalNamespace][]*InternalNamespace, replace *InternalNamespace) {
	for k := range ri {
		delete(ri, k)
	}
	fc := floodCounter.Add(1)
	for k := range n.DirectImports.ns {
		if k != replace {
			k.findRecursiveImports(fc, n, ri, replace, n)
		}
	}
	if replace != nil {
		for k := range replace.DirectImports.ns {
			if k != n {
				k.findRecursiveImports(fc, n, ri, replace, n)
			}
		}
	}
}

func (n *InternalNamespace) findRecursiveImports(floodCounter int64, parent *InternalNamespace, ri map[*InternalNamespace][]*InternalNamespace, replace *InternalNamespace, with *InternalNamespace) {
	if n.FloodCounter >= floodCounter {
		return // visited already
	}
	n.FloodCounter = floodCounter
	ri[n] = append(ri[n], parent)
	for k := range n.DirectImports.ns {
		kk := k.replace(replace, with)
		kk.findRecursiveImports(floodCounter, n, ri, replace, with)
	}
}

func (n InternalNamespace) String() string {
	var s strings.Builder
	s.WriteString(fmt.Sprintf("id %d types: ", n.DebugID))
	s.WriteString(strings.Join(n.sortedElements(), ":"))
	s.WriteString("\nnamespaces: ")
	s.WriteString(strings.Join(n.sortedNamespaces(), ","))
	s.WriteString(fmt.Sprintf(" fc=%d\ndirect: ", n.FloodCounter))
	s.WriteString(strings.Join(n.sortedDirectElements(), ","))
	s.WriteString("\nrecursive: ")
	s.WriteString(strings.Join(n.sortedRecursiveElements(), ","))
	s.WriteString("\n")
	return s.String()
}

func (n *InternalNamespace) replace(replace *InternalNamespace, with *InternalNamespace) *InternalNamespace {
	if n == replace {
		return with
	}
	return n
}

// do not forget to remove from []*InternalNamespace after call
func (n *InternalNamespace) mergeFrom(from *InternalNamespace, internalNamespaces []*InternalNamespace) {
	into := n
	for _, t := range from.Types {
		into.Types = append(into.Types, t)
		t.ins = into
	}
	for nn := range from.Namespaces {
		n.Namespaces[nn] = struct{}{}
	}
	for nn := range from.DirectImports.ns {
		if nn != into {
			into.DirectImports.ns[nn] = struct{}{}
		}
	}
	into.DirectImports.importSort = into.DirectImports.importSort || from.DirectImports.importSort
	for _, ins := range internalNamespaces {
		if _, ok := ins.DirectImports.ns[from]; ok {
			if ins != into {
				ins.DirectImports.ns[into] = struct{}{}
			}
			// for k2 := range n.DirectImports {
			//	ins.DirectImports[k2] = struct{}{}
			// }
			delete(ins.DirectImports.ns, from)
		}
	}
}

func (n *InternalNamespace) sortedElements() []string {
	var elements []string
	for _, t := range n.Types {
		elements = append(elements, t.goGlobalName)
	}
	slices.Sort(elements)
	return elements
}

func (n *InternalNamespace) sortedRecursiveElements() []string {
	var elements []string
	ri := map[*InternalNamespace][]*InternalNamespace{}
	n.FindRecursiveImports(ri, nil)
	for r := range ri {
		var inside []string
		for _, t := range r.Types {
			inside = append(inside, t.goGlobalName)
		}
		slices.Sort(inside)
		elements = append(elements, strings.Join(inside, ":"))
	}
	slices.Sort(elements)
	return elements
}

func (n *InternalNamespace) sortedDirectElements() []string {
	var elements []string
	for r := range n.DirectImports.ns {
		var inside []string
		for _, t := range r.Types {
			inside = append(inside, t.goGlobalName)
		}
		slices.Sort(inside)
		elements = append(elements, strings.Join(inside, ":"))
	}
	slices.Sort(elements)
	return elements
}

func (n *InternalNamespace) sortedNamespaces() []string {
	var elements []string
	for n := range n.Namespaces {
		elements = append(elements, n)
	}
	slices.Sort(elements)
	return elements
}

type Namespace struct {
	types []*TypeRWWrapper
	dec   Deconflicter
}

type Gen2Options struct {
	TypesWhileList       string
	BytesVersions        string
	TLPackageNameFull    string
	BasicPackageNameFull string // if empty, will be created
	Verbose              bool
	GenerateRPCCode      bool
	BasicRPCPath         string
	TLOPath              string
	GenerateRandomCode   bool
	SchemaDocumentation  bool
	SplitInternal        bool
	Language             string
	RootCPPNamespace     string
	CopyrightFilePath    string
	IgnoreGeneratedCode  bool // ignores generated code, tlo and documentation will be generated with related flags
}

type Gen2 struct {
	// options
	options *Gen2Options // pointer so code modifying options in GenerateCode refers to the same structure

	// artifacts
	RootPackageName string

	// golang specific
	BasicPackageNameFull string // basic types are in separate namespace to minimize conflicts
	GlobalPackageName    string // we generate all go types in this package, because we need circular dependencies
	FactoryPackageName   string
	MetaPackageName      string

	// c++ specific
	RootCPPNamespaceElements    []string
	DetailsCPPNamespaceElements []string
	DetailsCPPNamespace         string // basictl::details

	// parsed TL
	supportedModifierBits map[string]int
	typeDescriptors       map[string][]*tlast.Combinator
	singleConstructors    map[string]*tlast.Combinator // only types with 1 constructor, no functions
	allConstructors       map[string]*tlast.Combinator // for printing beautiful errors

	// generation
	builtinTypes       map[string]*TypeRWWrapper
	generatedTypes     map[string]*TypeRWWrapper
	generatedTypesList []*TypeRWWrapper // we need more deterministic order than sort predicate can establish

	globalDec  Deconflicter
	Namespaces map[string]*Namespace // Handlers Code is inside

	// result
	TLO           []byte            // schema represented in tlo format, described using tls.* combinator
	Code          map[string]string // fileName->Content, split by file names relative to output dir
	copyrightText string
}

func (gen *Gen2) InternalPrefix() string {
	if gen.options.SplitInternal {
		return "internal."
	}
	return ""
}

func canonicalGoName(name tlast.Name, insideNamespace string) string {
	if name.Namespace == insideNamespace {
		return CNameToCamelName(name.Name)
	}
	return CNameToCamelName(name.Namespace) + CNameToCamelName(name.Name)
}

/*
func canonicalCPPName(name tlast.Name, insideNamespace string) string { // TODO
	if name.Namespace == insideNamespace {
		return name.Name
	}
	return name.Namespace + "_" + name.Name
}

func fullyResolvedClassCppSuffixArgs(rt ResolvedType) (string, []string) { // name in namespace, arguments decl
	cppSuffix := strings.Builder{}
	var cppArgsDecl []string
	for _, a := range rt.Args {
		if a.IsNat {
			if a.isArith {
				cppSuffix.WriteString(a.TemplateArgName)
				cppArgsDecl = append(cppArgsDecl, "uint32_t "+a.TemplateArgName)
			}
		} else {
			cppArgsDecl = append(cppArgsDecl, "typename "+a.TemplateArgName)
		}
	}
	return cppSuffix.String(), cppArgsDecl
}
*/

func (gen *Gen2) getNamespace(n string) *Namespace {
	na, ok := gen.Namespaces[n]
	if !ok {
		na = &Namespace{}
		gen.Namespaces[n] = na
		// TODO - ALL golang-specific names
		na.dec.deconflictName("Handler")
		na.dec.deconflictName("Handle")
		na.dec.deconflictName("Client")
		// TODO - if we want lowercase C++ identifiers, we need to add ~100 reserved keywords here
		// na.dec.deconflictName("double")
		// na.dec.deconflictName("int")
		// etc...
	}
	return na
}

func checkTagCollisions(tl tlast.TL) error {
	constructorTags := map[uint32]*tlast.Combinator{}
	for _, typ := range tl {
		crc32 := typ.Crc32()
		if crc32 == 0 {
			// typeA#00000000 = TypeA;
			return typ.Construct.IDPR.BeautifulError(fmt.Errorf("constructor tag 0 is prohibited, even if generated implicitly"))
		}
		if col, ok := constructorTags[crc32]; ok {
			// typeA#dfc15abf = TypeA;
			// typeB#dfc15abf = TypeB;
			e1 := typ.Construct.IDPR.BeautifulError(fmt.Errorf("constructor tag #%08x used by %q is used again by %q", crc32, col.Construct.Name.String(), typ.Construct.Name.String()))
			e2 := col.Construct.IDPR.BeautifulError(errSeeHere)
			return tlast.BeautifulError2(e1, e2)
		}
		constructorTags[crc32] = typ
	}
	return nil
}

func (gen *Gen2) buildMapDescriptors(tl tlast.TL) error {
	// Collect unions, check that functions cannot form a union with each other or with normal singleConstructors
	for _, typ := range tl {
		for _, f := range typ.Fields {
			if len(f.FieldName) == 0 && (len(typ.Fields) != 1 || f.Mask != nil) {
				f.PR.BeautifulWarning(fmt.Errorf("anonymous fields are discouraged, except when used in '# a:[int]' pattern or when type has single anonymous field without fieldmask (typedef-like)")).ConsolePrint(nil)
				fmt.Printf("\n")
			}
		}
		conName := typ.Construct.Name.String()
		if col, ok := gen.allConstructors[conName]; ok {
			// typeA = TypeA;
			// typeA = TypeB;
			e1 := typ.Construct.NamePR.BeautifulError(fmt.Errorf("constructor name %q is used again here", conName))
			e2 := col.Construct.NamePR.BeautifulError(errSeeHere)
			return tlast.BeautifulError2(e1, e2)
		}
		gen.allConstructors[conName] = typ
		if !typ.IsFunction {
			typeName := typ.TypeDecl.Name.String()
			if typeName != "_" { // prohibit boxed type
				if len(typ.TemplateArguments) > len(typ.TypeDecl.Arguments) {
					// rightLeftArgs {X:Type} {Y:#} = RightLeftArgs X; <- bad
					arg := typ.TemplateArguments[len(typ.TypeDecl.Arguments)]
					return typ.TypeDecl.PR.CollapseToEnd().BeautifulError(fmt.Errorf("type declaration %q is missing template argument %q here", typeName, arg.FieldName))
				}
				if len(typ.TemplateArguments) < len(typ.TypeDecl.Arguments) {
					// rightLeftArgs {X:Type} {Y:#} = RightLeftArgs X Y Y; <- bad
					arg := typ.TypeDecl.Arguments[len(typ.TemplateArguments)]
					pr := typ.TypeDecl.ArgumentsPR[len(typ.TemplateArguments)]
					return pr.BeautifulError(fmt.Errorf("type declaration %q has excess template argument %q here", typeName, arg))
				}
				for j, t := range typ.TemplateArguments {
					if t.FieldName != typ.TypeDecl.Arguments[j] {
						// rightLeftArgs {X:Type} {Y:#} = RightLeftArgs Y X;   <- bad
						pr := typ.TypeDecl.ArgumentsPR[j]
						typArg := typ.TypeDecl.Arguments[j]
						e1 := pr.BeautifulError(fmt.Errorf("type declaration %q has wrong template argument name %q here", typeName, typArg))
						e2 := t.PR.BeautifulError(errSeeHere)
						return tlast.BeautifulError2(e1, e2)
					}
				}
				gen.typeDescriptors[typeName] = append(gen.typeDescriptors[typeName], typ)
			}
		} else {
			if len(typ.Modifiers) == 0 {
				typ.Construct.NamePR.CollapseToBegin().BeautifulWarning(fmt.Errorf("function constructor %q without modifier (identifier starting with '@') not recommended", typ.Construct.Name.String())).ConsolePrint(nil)
				fmt.Printf("\n")
			}
			for _, m := range typ.Modifiers {
				if _, ok := gen.supportedModifierBits[m.Name]; !ok {
					m.PR.BeautifulWarning(fmt.Errorf("modifier %q not known to tl compiler", m.Name)).ConsolePrint(nil)
					fmt.Printf("\n")
				}
			}
		}
	}
	for _, typ := range gen.typeDescriptors {
		if len(typ) == 1 { // here there is no functions
			conName := typ[0].Construct.Name.String()
			if col, ok := gen.singleConstructors[conName]; ok {
				e1 := typ[0].Construct.NamePR.LogicError(fmt.Errorf("constructor name %q is used again here", conName))
				e2 := col.Construct.NamePR.BeautifulError(errSeeHere)
				return tlast.BeautifulError2(e1, e2)
			}
			gen.singleConstructors[conName] = typ[0]
			continue
		}
		if err := checkUnionElementsCompatibility(typ); err != nil {
			return err
		}
	}
	return nil
}

func checkUnionElementsCompatibility(types []*tlast.Combinator) error {
	for _, typ := range types {
		s1 := strings.ToLower(typ.TypeDecl.Name.String())
		s2 := strings.ToLower(typ.Construct.Name.String())
		if s1 == s2 {
			e1 := typ.Construct.NamePR.BeautifulWarning(fmt.Errorf("union type name collision with constructor"))
			e2 := typ.TypeDecl.PR.BeautifulError(errSeeHere)
			tlast.BeautifulError2(e1, e2).ConsolePrint(nil)
			fmt.Printf("\n")
		}
	}
	base := types[0]
	for _, typ := range types[1:] {
		cur := typ.Construct.Name.String()
		if len(typ.TemplateArguments) < len(base.TemplateArguments) {
			baseArg := base.TemplateArguments[len(typ.TemplateArguments)]
			// unionArgs2 {A:Type} {B:#} a:A = UnionArgs A B;
			// unionArgs1 {X:Type} a:X = UnionArgs X;
			e1 := typ.TemplateArgumentsPR.CollapseToEnd().BeautifulError(fmt.Errorf("union constructor %q has missing argument %q here", cur, baseArg.FieldName))
			e2 := baseArg.PR.BeautifulError(errSeeHere)
			return tlast.BeautifulError2(e1, e2)
		}
		if len(typ.TemplateArguments) > len(base.TemplateArguments) {
			typArg := typ.TemplateArguments[len(base.TemplateArguments)]
			// unionArgs1 {X:Type} a:X = UnionArgs X;
			// unionArgs2 {A:Type} {B:#} a:A = UnionArgs A B;
			e1 := typArg.PR.BeautifulError(fmt.Errorf("union constructor %q has excess argument %q here", cur, typArg.FieldName))
			e2 := base.TemplateArgumentsPR.CollapseToEnd().BeautifulError(errSeeHere)
			return tlast.BeautifulError2(e1, e2)
		}
		for i, typArg := range typ.TemplateArguments {
			baseArg := base.TemplateArguments[i]
			// unionArgs1 {X:Type} {Y:#} a:X = UnionArgs X Y;
			// unionArgs2 {A:Type} {B:Type} a:A = UnionArgs A B;
			// We cannot support this, because resolveType replaces parameter names into names of first union field
			if baseArg.IsNat != typArg.IsNat || baseArg.FieldName != typArg.FieldName {
				e1 := typArg.PR.BeautifulError(fmt.Errorf("union constructor %q has different argument name or type here %q", cur, typArg.FieldName))
				e2 := baseArg.PR.BeautifulError(errSeeHere)
				return tlast.BeautifulError2(e1, e2)
			}
		}
	}
	return nil
}

func inBytesVersionFilter(name tlast.Name, filter string) bool {
	if strings.HasSuffix(filter, ".") && name.Namespace == strings.TrimSuffix(filter, ".") {
		return true
	}
	if !strings.HasSuffix(filter, ".") && name.String() == filter {
		return true
	}
	return false
}

func collectRelativePaths(absDirName string, relDirName string, relativeFiles map[string]bool, relativeDirs *[]string) error {
	fis, err := os.ReadDir(absDirName)
	if err != nil {
		return err
	}
	for _, fi := range fis { // try all snapshots, loading the latest
		relFilename := filepath.Join(relDirName, fi.Name())
		absFilename := filepath.Join(absDirName, fi.Name())
		if fi.IsDir() {
			*relativeDirs = append(*relativeDirs, relFilename)
			if err = collectRelativePaths(absFilename, relFilename, relativeFiles, relativeDirs); err != nil {
				return err
			}
			continue
		}
		relativeFiles[relFilename] = true
	}
	return nil
}

// WriteToDir Most common action with generated code, so clients do not repeat it
func (gen *Gen2) WriteToDir(outdir string) error {
	if gen.options.IgnoreGeneratedCode {
		return nil
	}
	if err := os.Mkdir(outdir, 0755); err != nil && !os.IsExist(err) { // we thus require parent directory to exist
		return fmt.Errorf("error creating outdir %q: %w", outdir, err)
	}
	// We do not want to touch files which did not change at all.
	relativeFiles := map[string]bool{}
	var relativeDirs []string
	if err := collectRelativePaths(outdir, "", relativeFiles, &relativeDirs); err != nil {
		return fmt.Errorf("error reading outdir content %q: %w", outdir, err)
	}
	if len(relativeFiles) != 0 && !relativeFiles[markerFile] {
		return fmt.Errorf("outdir %q not empty and has no %q marker file, please clean manually", outdir, markerFile)
	}
	notTouched := 0
	written := 0
	deleted := 0
	for filepathName, code := range gen.Code {
		d := filepath.Join(outdir, filepath.Dir(filepathName))
		if err := os.MkdirAll(d, 0755); err != nil && !os.IsExist(err) {
			return fmt.Errorf("error creating dir %q: %w", d, err)
		}
		f := filepath.Join(outdir, filepathName)
		if relativeFiles[filepathName] {
			delete(relativeFiles, filepathName)
			was, err := os.ReadFile(f)
			if err != nil {
				return fmt.Errorf("error reading previous file %q: %w", f, err)
			}
			if string(was) == code {
				notTouched++
				continue
			}
		}
		written++
		if err := os.WriteFile(f, []byte(code), 0644); err != nil {
			return fmt.Errorf("error writing file %q: %w", f, err)
		}
	}
	for filepathName := range relativeFiles {
		deleted++
		f := filepath.Join(outdir, filepathName)
		if err := os.Remove(f); err != nil {
			return fmt.Errorf("error deleting previous file %q: %w", f, err)
		}
	}
	for i := len(relativeDirs) - 1; i >= 0; i-- {
		f := filepath.Join(outdir, relativeDirs[i])
		_ = os.Remove(f) // non-empty dirs simply will not remove. This is good enough for us
	}
	fmt.Printf("%d target files did not change so were not touched, %d written, %d deleted\n", notTouched, written, deleted)
	return nil
}

func (gen *Gen2) addCodeFile(filepathName string, code string) error {
	if _, ok := gen.Code[filepathName]; ok {
		return fmt.Errorf("generator %sinternal error%s: source file %q is generated twice", color.Red, color.Reset, filepathName)
	}
	gen.Code[filepathName] = code
	return nil
}

func GenerateCode(tl tlast.TL, options Gen2Options) (*Gen2, error) {
	if options.TLPackageNameFull == "" { // for testing, empty path should be prohibited in main argv parsing
		options.TLPackageNameFull = "github.com/vkcom/tl/internal/tlcodegen/output/tl"
	}
	if options.RootCPPNamespace == "" {
		options.RootCPPNamespace = "tl2"
	}
	options.TLPackageNameFull = strings.TrimSpace(options.TLPackageNameFull)
	if options.Language == "" {
		options.Language = "go"
	}
	gen := &Gen2{
		options:    &options,
		Code:       map[string]string{},
		Namespaces: map[string]*Namespace{},
		// Files:                 map[string][]*TypeRWWrapper{},
		supportedModifierBits: map[string]int{}, // filled statically for now, will be read from TL file later
		typeDescriptors:       map[string][]*tlast.Combinator{},
		allConstructors:       map[string]*tlast.Combinator{},
		singleConstructors:    map[string]*tlast.Combinator{},
		builtinTypes:          map[string]*TypeRWWrapper{},
		generatedTypes:        map[string]*TypeRWWrapper{},
	}
	switch options.Language {
	case "go", "cpp":
		break
	default:
		return nil, fmt.Errorf("unsupported language %q, only 'go' and 'cpp' are supported", options.Language)
	}
	if options.Language == "go" {
		elements := strings.Split(options.TLPackageNameFull, "/")
		if len(elements) < 3 {
			return nil, fmt.Errorf("full go package name must have 2 non-empty rightmost path elements, for example '.../output/tl")
		}
		options.TLPackageNameFull = strings.Join(elements[:len(elements)-1], "/")
		gen.GlobalPackageName = elements[len(elements)-1]
		gen.RootPackageName = elements[len(elements)-2]
		gen.FactoryPackageName = strings.Join(append(elements[:len(elements)-1], FactoryGoPackageName), "/")
		gen.MetaPackageName = strings.Join(append(elements[:len(elements)-1], MetaGoPackageName), "/")
		if gen.GlobalPackageName == "" || elements[len(elements)-2] == "" {
			return nil, fmt.Errorf("full go package name must have 2 non-empty rightmost path elements, for example '.../output/tl")
		}
		if gen.options.BasicPackageNameFull == "" {
			gen.BasicPackageNameFull = strings.Join(append(elements[:len(elements)-1], BasicTLGoPackageName), "/")
		} else {
			elements = strings.Split(gen.options.BasicPackageNameFull, "/")
			if len(elements) < 2 || elements[len(elements)-1] != BasicTLGoPackageName {
				return nil, fmt.Errorf("basictl go package name must end with '/%s'", BasicTLGoPackageName)
			}
			gen.BasicPackageNameFull = gen.options.BasicPackageNameFull
		}
	}
	if options.Language == "cpp" {
		gen.RootCPPNamespaceElements = strings.Split(options.RootCPPNamespace, "::")
		gen.DetailsCPPNamespaceElements = []string{options.RootCPPNamespace, "details"} // TODO - rename to prevent collisions with TL namespace details
		gen.DetailsCPPNamespace = options.RootCPPNamespace + "::details"
	}
	typesWhiteList := strings.Split(options.TypesWhileList, ",")
	for i := 0; i < len(typesWhiteList); i++ {
		typesWhiteList[i] = strings.TrimSpace(typesWhiteList[i])
		if len(typesWhiteList[i]) == 0 {
			typesWhiteList = append(typesWhiteList[:i], typesWhiteList[i+1:]...)
		}
	}
	generateByteVersions := strings.Split(options.BytesVersions, ",")
	for i := 0; i < len(generateByteVersions); i++ {
		generateByteVersions[i] = strings.TrimSpace(generateByteVersions[i])
		if len(generateByteVersions[i]) == 0 {
			generateByteVersions = append(generateByteVersions[:i], generateByteVersions[i+1:]...)
		}
	}
	gen.supportedModifierBits = map[string]int{"@read": 0, "@any": 1, "@internal": 2, "@write": 3, "@readwrite": 4, "@kphp": 5}
	rootNamespace := gen.getNamespace("")
	primitiveTypesList := []*TypeRWPrimitive{
		{
			tlType:            "#",
			goType:            "uint32",
			cppPrimitiveType:  "uint32_t",
			cppDefaultInit:    " = 0",
			cppFunctionSuffix: "nat",
			cppResetValue:     "%s = 0;",
			writeJSONValue:    "basictl.JSONWriteUint32",
			readJSONValue:     gen.InternalPrefix() + "JsonReadUint32",
			resetValue:        "%s = 0",
			randomValue:       "basictl.RandomNat",
			writeValue:        "basictl.NatWrite",
			readValue:         "basictl.NatRead",
		}, {
			tlType:            "int",
			goType:            "int32",
			cppPrimitiveType:  "int32_t",
			cppDefaultInit:    " = 0",
			cppFunctionSuffix: "int",
			cppResetValue:     "%s = 0;",
			writeJSONValue:    "basictl.JSONWriteInt32",
			readJSONValue:     gen.InternalPrefix() + "JsonReadInt32",
			resetValue:        "%s = 0",
			randomValue:       "basictl.RandomInt",
			writeValue:        "basictl.IntWrite",
			readValue:         "basictl.IntRead",
		}, {
			tlType:            "long",
			goType:            "int64",
			cppPrimitiveType:  "int64_t",
			cppDefaultInit:    " = 0",
			cppFunctionSuffix: "long",
			cppResetValue:     "%s = 0;",
			writeJSONValue:    "basictl.JSONWriteInt64",
			readJSONValue:     gen.InternalPrefix() + "JsonReadInt64",
			resetValue:        "%s = 0",
			randomValue:       "basictl.RandomLong",
			writeValue:        "basictl.LongWrite",
			readValue:         "basictl.LongRead",
		}, {
			tlType:            "float",
			goType:            "float32",
			cppPrimitiveType:  "float",
			cppDefaultInit:    " = 0",
			cppFunctionSuffix: "float",
			cppResetValue:     "%s = 0;",
			writeJSONValue:    "basictl.JSONWriteFloat32",
			readJSONValue:     gen.InternalPrefix() + "JsonReadFloat32",
			resetValue:        "%s = 0",
			randomValue:       "basictl.RandomFloat",
			writeValue:        "basictl.FloatWrite",
			readValue:         "basictl.FloatRead",
		}, {
			tlType:            "double",
			goType:            "float64",
			cppPrimitiveType:  "double",
			cppDefaultInit:    " = 0",
			cppFunctionSuffix: "double",
			cppResetValue:     "%s = 0;",
			writeJSONValue:    "basictl.JSONWriteFloat64",
			readJSONValue:     gen.InternalPrefix() + "JsonReadFloat64",
			resetValue:        "%s = 0",
			randomValue:       "basictl.RandomDouble",
			writeValue:        "basictl.DoubleWrite",
			readValue:         "basictl.DoubleRead",
		}, {
			tlType:            "string",
			goType:            "string",
			cppPrimitiveType:  "std::string",
			cppDefaultInit:    "",
			cppFunctionSuffix: "string",
			cppResetValue:     "%s.clear();",
			writeJSONValue:    "basictl.JSONWriteString",
			readJSONValue:     gen.InternalPrefix() + "JsonReadString",
			resetValue:        "%s = \"\"",
			randomValue:       "basictl.RandomString",
			writeValue:        "basictl.StringWrite",
			readValue:         "basictl.StringRead",
			writeHasError:     true,
		},
	}
	builtinBeautifulText := fmt.Sprintf(`
%s {t:Type} {n:#} ? = _ t n; // builtin tuple
%s {t:Type} # [t] = _ t; // builtin vector
`, BuiltinTupleName, BuiltinVectorName)
	primitiveTypes := map[string]*TypeRWPrimitive{}
	for _, cn := range primitiveTypesList {
		builtinBeautifulText += fmt.Sprintf("%s ? = _; // builtin primitive type\n", cn.tlType)
		primitiveTypes[cn.tlType] = cn
	}

	btl, err := tlast.ParseTL2(builtinBeautifulText, "<builtin>", true) // We need references to token positions for beautification
	if err != nil {
		return nil, fmt.Errorf("failed to parse internal builtin type representation for beautification: %w", err)
	}
	for i, typ := range tl { // replace built-in
		tName := typ.Construct.Name.String()
		// convert that old syntax to new syntax.
		if !typ.Builtin {
			continue
		}
		if len(typ.TemplateArguments) != 0 {
			return nil, typ.TemplateArgumentsPR.BeautifulError(fmt.Errorf("builtin wrapper %q cannot have template parameters", tName))
		}
		if _, ok := primitiveTypes[tName]; !ok {
			return nil, typ.Construct.NamePR.BeautifulError(fmt.Errorf("builtin wrapper %q must have constructor name equal to some builtin type", tName))
		}
		newDesc := &tlast.Combinator{}
		*newDesc = *tl[i]
		newDesc.OriginalDescriptor = typ
		newDesc.Fields = append(newDesc.Fields, tlast.Field{
			FieldType: tlast.TypeRef{
				Type: tlast.Name{Name: tName},
				Bare: true,
			},
		})
		newDesc.Builtin = false
		tl[i] = newDesc
	}
	if options.Verbose {
		log.Printf("checking tags collisions...")
	}
	if err := checkTagCollisions(tl); err != nil {
		return nil, err
	}
	if options.Verbose {
		log.Printf("transforming collections into canonical tuples...")
	}

	// for _, c := range tl {
	//	fmt.Printf("%s\n", c.String())
	// }
	tlTLO, err := ReplaceSquareBracketsElem(tl, true)
	if err != nil {
		return nil, fmt.Errorf("replacing with canonical tuples: %w", err)
	}
	// for _, c := range tlTLO {
	//	fmt.Printf("%s\n", c.String())
	// }
	if options.TLOPath != "" {
		filepathName := gen.RootPackageName + tloExt + jsonExt
		if options.Verbose {
			log.Printf("generating tlo to %s", filepathName)
		}
		err = gen.buildMapDescriptors(tlTLO)
		if err != nil {
			return nil, err
		}
		for _, bt := range btl {
			tName := bt.Construct.Name.String()
			gen.allConstructors[tName] = bt
			gen.singleConstructors[tName] = bt // will overwrite without checking, this code is for TLO only
		}
		tlo, tloJSON, err := gen.generateTLO()
		if err != nil {
			return gen, fmt.Errorf("can't generate TLO: %v", err)
		}
		gen.TLO = tlo
		if err := gen.addCodeFile(filepathName, string(utils.JsonPrettyPrint(tloJSON))); err != nil {
			return gen, err
		}
		// Clear map descriptors, we will build them again after replacing square brackets
		gen.typeDescriptors = map[string][]*tlast.Combinator{}
		gen.allConstructors = map[string]*tlast.Combinator{}
		gen.singleConstructors = map[string]*tlast.Combinator{}
	}

	// ReplaceSquareBrackets will generate types with id 0, we will not generate boxed methods for such types
	if tl, err = ReplaceSquareBracketsElem(tl, false); err != nil {
		return nil, fmt.Errorf("replacing with canonical tuples: %w", err)
	}
	if options.Verbose {
		log.Printf("checking name collisions...")
	}
	err = gen.buildMapDescriptors(tl)
	if err != nil {
		return nil, err
	}

	// Now we replace all builtin legitimate builtin wrapper constructors to constructors of builtins
	// Int and %Int will reference wrappers, while int will reference builtin constructor.
	// To avoid 2 canonical forms, resolveType will replace %Int to int for wrappers
	for _, bt := range btl {
		var zero uint32
		bt.Construct.ID = &zero
		tName := bt.Construct.Name.String()
		if tName == BuiltinTupleName || tName == BuiltinVectorName {
			gen.allConstructors[tName] = bt
			gen.singleConstructors[tName] = bt
			continue
		}
		cn, ok := primitiveTypes[tName]
		if !ok {
			panic("broken primitive types list")
		}
		wrapper := &TypeRWWrapper{
			gen:          gen,
			ns:           rootNamespace,
			trw:          cn,
			goGlobalName: cn.goType,
			goLocalName:  "",
			fileName:     cn.tlType,
			origTL:       []*tlast.Combinator{bt},
		}
		if cn.tlType == "#" {
			wrapper.fileName = "nat"
		}
		gen.builtinTypes[cn.tlType] = wrapper
		gen.generatedTypesList = append(gen.generatedTypesList, wrapper)
		typ, ok := gen.allConstructors[tName]
		if ok {
			// vasya ? = Int;
			// vasya {T:Type} {N:#} ? = Int T N;
			// int {T:Type} {N:#} int = Int T N;
			// int = Int;
			// int int int = Int;
			// int vasya:int = Int;
			// int n.0?int = Int;
			// int (int 5) = Int;
			// int (%Int) = Int;
			// int (Int) = Int;
			// int ? = Int;   <-- allowed, but deprecated shape. TODO - prohibit in TL2
			// int int = Int; <-- allowed shape
			if len(typ.TemplateArguments) != 0 {
				return nil, typ.TemplateArgumentsPR.BeautifulError(fmt.Errorf("builtin wrapper %q cannot have template parameters", tName))
			}
			if len(typ.Fields) == 0 {
				return nil, typ.TemplateArgumentsPR.CollapseToEnd().BeautifulError(fmt.Errorf("builtin wrapper %q must have exactly 1 field", tName))
			}
			if len(typ.Fields) > 1 {
				return nil, typ.Fields[1].FieldType.PR.BeautifulError(fmt.Errorf("builtin wrapper %q has excess field, must have exactly 1", tName))
			}
			if typ.Fields[0].FieldName != "" {
				return nil, typ.Fields[0].PRName.BeautifulError(fmt.Errorf("builtin wrapper %q field must be anonymous", tName))
			}
			if typ.Fields[0].Mask != nil {
				return nil, typ.Fields[0].Mask.PRName.BeautifulError(fmt.Errorf("builtin wrapper %q field must not use field mask", tName))
			}
			if typ.Fields[0].FieldType.Type.String() != tName || len(typ.Fields[0].FieldType.Args) != 0 { // do not check Bare, because int === %int
				return nil, typ.Fields[0].FieldType.PR.BeautifulError(fmt.Errorf("builtin wrapper %q field type must match constructor name", tName))
			}
			if _, ok := gen.builtinTypes[tName]; !ok {
				return nil, typ.Construct.NamePR.BeautifulError(fmt.Errorf("builtin wrapper %q must have constructor name equal to some builtin type", tName))
			}
		} else {
			gen.allConstructors[tName] = bt
			gen.singleConstructors[tName] = bt
		}
	}

	// tupleDesc := btl[0]
	// vectorDesc := btl[1]
	// gen.singleConstructors[tupleDesc.Construct.Name.String()] = tupleDesc
	// gen.allConstructors[tupleDesc.Construct.Name.String()] = tupleDesc
	// gen.singleConstructors[vectorDesc.Construct.Name.String()] = vectorDesc
	// gen.allConstructors[vectorDesc.Construct.Name.String()] = vectorDesc
	if options.Verbose {
		log.Printf("type checking and templates instantiation...")
	}

	skippedDueToWhitelist := 0
	for _, typ := range tl {
		// TODO - after rpcInvokeReq is fixed, remove this
		if len(typ.TemplateArguments) == 1 && typ.TemplateArguments[0].IsNat && !typ.IsFunction && (typ.Construct.Name.String() == "rpcInvokeReqExtra" || typ.Construct.Name.String() == "rpcReqResultExtra") {
			fmt.Printf("Special treatment for %q, will be removed some day\n", typ.Construct.Name.String())
			t := tlast.TypeRef{Type: typ.TypeDecl.Name, PR: typ.TypeDecl.PR}
			argT := tlast.TypeRef{Type: tlast.Name{
				Namespace: "",
				Name:      "ArgumentN",
			}}
			t.Args = append(t.Args, tlast.ArithmeticOrType{
				IsArith: false,
				T:       argT,
			})
			lrc := LocalResolveContext{allowAnyConstructor: true, localNatArgs: map[string]LocalNatArg{}}
			lrc.localNatArgs["ArgumentN"] = LocalNatArg{
				natArg: ActualNatArg{isField: true, FieldIndex: 0},
			}
			_, _, _, err = gen.getType(lrc, t, nil)
			if err != nil {
				return nil, err
			}
		}
		shouldGenerate := options.TypesWhileList == ""
		whiteListName := typ.Construct.Name
		if !typ.IsFunction {
			whiteListName = typ.TypeDecl.Name
		}
		for _, bv := range generateByteVersions {
			if inBytesVersionFilter(whiteListName, bv) {
				shouldGenerate = true
			}
		}
		for _, bv := range typesWhiteList {
			if inBytesVersionFilter(whiteListName, bv) {
				shouldGenerate = true
			}
		}
		if !shouldGenerate {
			skippedDueToWhitelist++
			continue
		}
		if len(typ.TemplateArguments) == 0 {
			t := tlast.TypeRef{Type: typ.Construct.Name, PR: typ.Construct.NamePR}
			if !typ.IsFunction {
				t = tlast.TypeRef{Type: typ.TypeDecl.Name, PR: typ.TypeDecl.PR}
			}
			_, _, _, err = gen.getType(LocalResolveContext{allowAnyConstructor: true}, t, nil)
			if err != nil {
				return nil, err
			}
		}
	}
	bytesChildren := map[*TypeRWWrapper]bool{}
	typesCounterMarkBytes := 0
	// This loop can be before or after loops below, it is convenient to fill sortedTypes inside, so this loop is here
	for _, v := range gen.generatedTypesList {
		for _, bv := range generateByteVersions {
			if inBytesVersionFilter(v.tlName, bv) {
				v.MarkWantsBytesVersion(bytesChildren)
				typesCounterMarkBytes++
			}
		}
	}
	slices.SortStableFunc(gen.generatedTypesList, func(a, b *TypeRWWrapper) int { //  TODO - better idea?
		return TypeRWWrapperLessGlobal(a, b)
	})
	sortedTypes := gen.generatedTypesList
	// for _, st := range sortedTypes {
	//	fmt.Printf("sorted type %q\n", st.localTypeArg.rt.String())
	// }
	for _, v := range sortedTypes {
		// fmt.Printf("type %s names %s %s %d\n", v.CanonicalStringTop(), v.goGlobalName, v.tlName.String(), v.tlTag)
		// if len(v.origTL) <= 1 {
		//	fmt.Printf("     %s\n", v.CanonicalString(true))
		// } else {
		//	fmt.Printf("     %s\n", v.CanonicalString(false))
		// }
		// r # [r] = S;
		visitedNodes := map[*TypeRWWrapper]bool{}
		v.trw.fillRecursiveUnwrap(visitedNodes)
		v.preventUnwrap = visitedNodes[v]
		if v.preventUnwrap {
			fmt.Printf("prevented unwrap of %v\n", v.tlName)
		}
	}
	// in BeforeCodeGenerationStep we split recursion. Which links will be broken depends on order of nodes visited
	for _, v := range sortedTypes {
		v.trw.BeforeCodeGenerationStep1()
	}
	// in BeforeCodeGenerationStep2 we split recursion in unions.
	for _, v := range sortedTypes {
		v.trw.BeforeCodeGenerationStep2()
	}
	// we link normal and long types for VK int->long conversion. This code is VK-specific and will be removed after full migration
	for _, v := range sortedTypes {
		// @readwrite queueLong.getQueueKey id:long ip:int timeout:int queue:string = queueLong.TimestampKey;
		// @readwrite queue.getQueueKey id:int ip:int timeout:int queue:string = queue.TimestampKey;
		longName := v.CanonicalStringTop()
		argsStart := strings.Index(longName, "<")
		if argsStart < 0 {
			argsStart = len(longName)
		}
		if i := strings.Index(longName[:argsStart], "."); i >= 0 {
			longName = longName[:i] + "Long" + longName[i:]

			if tt, ok := gen.generatedTypes[longName]; ok {
				// log.Printf("long name %s discovered for %s", longName, v.CanonicalStringTop())
				v.WrLong = tt
				tt.WrWithoutLong = v
			}
		}

		v.trw.BeforeCodeGenerationStep2()
	}
	// Order of these 2 loops is important, for example see TypeRWTuple where bytes version depends on whether it is dict_like
	for _, v := range sortedTypes {
		visitedNodes := map[*TypeRWWrapper]bool{}
		v.hasBytesVersion = v.MarkHasBytesVersion(visitedNodes)
	}
	// detect recursion loops first
	if options.Verbose {
		if skippedDueToWhitelist != 0 {
			log.Printf("skipped %d object roots by the whitelist filter: %s", skippedDueToWhitelist, strings.Join(typesWhiteList, ", "))
		}
		log.Printf("found %d object roots for byte-optimized versions of types by the following filter: %s", typesCounterMarkBytes, strings.Join(generateByteVersions, ", "))
		log.Printf("generating serialization code...")
	}
	if gen.options.CopyrightFilePath != "" {
		buf, err := os.ReadFile(gen.options.CopyrightFilePath)
		if err != nil {
			return nil, fmt.Errorf("failed to open copyright text file: %w", err)
		}
		gen.copyrightText = string(buf)
	}
	if !options.IgnoreGeneratedCode {
		switch options.Language {
		case "go":
			if err := gen.generateCodeGolang(generateByteVersions); err != nil {
				return nil, err
			}
		//case "cpp":
		//	if err := gen.generateCodeCPP(generateByteVersions); err != nil {
		//		return nil, err
		//	}
		default:
			log.Panicf("uknown language, though language was checked before")
		}
	}

	if options.SchemaDocumentation {
		if err := gen.addCodeFile(TlJSONHTML, tlJSON(gen, buildSHA256Checksum)); err != nil {
			return gen, err
		}
	}

	if err := gen.addCodeFile(markerFile, buildVersionString+strings.TrimSpace(buildSHA256Checksum)+"\n"); err != nil { // some stupid editors insist on empty line at the end
		return nil, err
	}
	return gen, nil
}
