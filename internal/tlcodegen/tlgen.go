// Copyright 2022 V Kontakte LLC
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package tlcodegen

import (
	"crypto/sha1"
	"encoding/hex"
	"fmt"
	"go/format"
	"log"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"sync/atomic"

	"golang.org/x/exp/slices"

	"github.com/TwiN/go-color"

	"github.com/vkcom/tl/internal/tlast"
	"github.com/vkcom/tl/internal/utils"
)

const OptimizeConstParameters = true // if false, they will be passed to children and ignored there
const BuiltinTupleName = "__tuple"
const BuiltinVectorName = "__vector"
const BasicTLGoPackageName = "basictl" // does not contain tl prefix
const FactoryGoPackageName = "factory" // does not contain tl prefix
const MetaGoPackageName = "meta"       // does not contain tl prefix
const ConstantsPackageName = "constants"
const BasicTLCPPNamespaceName = "basictl" // does not contain tl prefix
const HeaderComment = "// Code generated by vktl/cmd/tlgen2; DO NOT EDIT."
const markerFile = "tlgen2_version.txt"

const (
	jsonExt = ".json"
	tloExt  = ".tlo"
	goExt   = ".go"
	cppExt  = ".cpp"
	hppExt  = ".hpp"
)

const TlJSONHTML = "tljson.html"

// Do not forget to bump version when making changes.
// We do not want repository hash, because it advances automatically each time ANYTHING in repository changes, not only tlgen2.
// And we do not want stable checksum of go files tlgen folder, because checksums are not comparable and there is no idea how old that version is
const buildVersionString = "tlgen2 version 2022.06.30, hash of source code - "

var buildSHA256Checksum = "" // filled when building

var (
	errSeeHere                = fmt.Errorf("see here")
	errFieldNameCollision     = fmt.Errorf("field name collision")
	errNatParamNameCollision  = fmt.Errorf("nat-parametr name collision")
	errTypeParamNameCollision = fmt.Errorf("type-parametr name collision ")
)

type LocalResolveContext struct {
	localTypeArgs map[string]LocalTypeArg
	localNatArgs  map[string]LocalNatArg

	allowAnyConstructor bool   // we can reference all constructors (functions, union elements) directly internally
	overrideFileName    string // used for unions and built-in vectors and tuples, so they are defined in the file of argument
}

// checkArgsCollision checks if passed name is already used in local context.
// pr: PR of the name we want to check
// err: will be returned (wrapped in beautiful error) if collision was NOT in type-parameter,
// must be defined depending on call context
func (lrc *LocalResolveContext) checkArgsCollision(name string, pr tlast.PositionRange, err error) error {
	if nat, ok := lrc.localNatArgs[name]; ok {
		e1 := pr.BeautifulError(err)
		e2 := nat.NamePR.BeautifulError(errSeeHere)
		return tlast.BeautifulError2(e1, e2)
	}
	if typ, ok := lrc.localTypeArgs[name]; ok {
		e1 := pr.BeautifulError(errTypeParamNameCollision)
		e2 := typ.PR.BeautifulError(errSeeHere)
		return tlast.BeautifulError2(e1, e2)
	}
	return nil
}

type LocalNatArg struct {
	wrongTypeErr error // we must add all field names to local context, because they must correctly shadow names outside, but we check the type

	NamePR tlast.PositionRange
	TypePR tlast.PositionRange
	natArg ActualNatArg
}

type LocalTypeArg struct {
	resolvedType ResolvedType
	natParams    []string
	PR           tlast.PositionRange // original template arg reference
}

type ActualNatArg struct {
	isArith    bool
	Arith      tlast.Arithmetic
	isField    bool // otherwise it is # param with name
	FieldIndex int
	name       string // param name
}

type ResolvedArg struct {
	IsNat   bool
	isArith bool
	Arith   tlast.Arithmetic
	T       ResolvedType
	TRW     *TypeRWWrapper

	TemplateArgName string
}

func (aot ResolvedArg) String() string {
	if aot.IsNat {
		if aot.isArith {
			return strconv.FormatUint(uint64(aot.Arith.Res), 10)
		}
		return "%"
	}
	return aot.T.String()
}

func (aot ResolvedArg) DebugString() string {
	prefix := ""
	if aot.TemplateArgName != "" {
		prefix += aot.TemplateArgName + "$"
	}
	if aot.T.OriginalName != "" {
		prefix += aot.T.OriginalName + ":"
	}
	if aot.IsNat {
		if aot.isArith {
			return prefix + strconv.FormatUint(uint64(aot.Arith.Res), 10)
		}
		return "%" + aot.T.DebugString()
	}
	return prefix + aot.T.DebugString()
}

type ResolvedType struct {
	OriginalName string // if not empty, contains original template argument name
	PR           tlast.PositionRange

	Type tlast.Name
	Args []ResolvedArg
	Bare bool
}

func (t ResolvedType) String() string {
	var s strings.Builder
	if t.Bare {
		s.WriteByte('%')
	}
	if t.Args != nil {
		s.WriteByte('(')
		s.WriteString(t.Type.String())
		for _, x := range t.Args {
			s.WriteByte(' ')
			s.WriteString(x.String())
		}
		s.WriteByte(')')
		return s.String()
	}
	s.WriteString(t.Type.String())
	return s.String()
}

func (t ResolvedType) DebugString() string {
	var s strings.Builder
	if t.OriginalName != "" {
		s.WriteString(t.OriginalName + ":")
	}
	if t.Bare {
		s.WriteByte('%')
	}
	if t.Args != nil {
		s.WriteByte('(')
		s.WriteString(t.Type.String())
		for _, x := range t.Args {
			s.WriteByte(' ')
			s.WriteString(x.DebugString())
		}
		s.WriteByte(')')
		return s.String()
	}
	s.WriteString(t.Type.String())
	return s.String()
}

type InternalNamespace struct {
	DebugID      int   // for identification in logs
	FloodCounter int64 // beware!

	Namespaces    map[string]struct{}
	DirectImports *DirectImports
	Types         []*TypeRWWrapper

	SubPath string
	Name    string
}

func (n *InternalNamespace) Prefix(directImports *DirectImports, in *InternalNamespace) string {
	if n == in {
		return ""
	}
	directImports.ns[n] = struct{}{}
	return n.Name + "."
}

func (n *InternalNamespace) ImportsSingleNamedNamespace() (empty bool, name string) {
	for nn := range n.Namespaces {
		if nn == "" {
			empty = true
			continue
		}
		if name != "" {
			return empty, ""
		}
		name = nn
	}
	return empty, name
}

var floodCounter atomic.Int64 // TODO - move somewhere

func (n *InternalNamespace) FindRecursiveImports(ri map[*InternalNamespace][]*InternalNamespace, replace *InternalNamespace) {
	for k := range ri {
		delete(ri, k)
	}
	fc := floodCounter.Add(1)
	for k := range n.DirectImports.ns {
		if k != replace {
			k.findRecursiveImports(fc, n, ri, replace, n)
		}
	}
	if replace != nil {
		for k := range replace.DirectImports.ns {
			if k != n {
				k.findRecursiveImports(fc, n, ri, replace, n)
			}
		}
	}
}

func (n *InternalNamespace) findRecursiveImports(floodCounter int64, parent *InternalNamespace, ri map[*InternalNamespace][]*InternalNamespace, replace *InternalNamespace, with *InternalNamespace) {
	if n.FloodCounter >= floodCounter {
		return // visited already
	}
	n.FloodCounter = floodCounter
	ri[n] = append(ri[n], parent)
	for k := range n.DirectImports.ns {
		kk := k.replace(replace, with)
		kk.findRecursiveImports(floodCounter, n, ri, replace, with)
	}
}

func (n InternalNamespace) String() string {
	var s strings.Builder
	s.WriteString(fmt.Sprintf("id %d types: ", n.DebugID))
	s.WriteString(strings.Join(n.sortedElements(), ":"))
	s.WriteString("\nnamespaces: ")
	s.WriteString(strings.Join(n.sortedNamespaces(), ","))
	s.WriteString(fmt.Sprintf(" fc=%d\ndirect: ", n.FloodCounter))
	s.WriteString(strings.Join(n.sortedDirectElements(), ","))
	s.WriteString("\nrecursive: ")
	s.WriteString(strings.Join(n.sortedRecursiveElements(), ","))
	s.WriteString("\n")
	return s.String()
}

func (n *InternalNamespace) replace(replace *InternalNamespace, with *InternalNamespace) *InternalNamespace {
	if n == replace {
		return with
	}
	return n
}

// do not forget to remove from []*InternalNamespace after call
func (n *InternalNamespace) mergeFrom(from *InternalNamespace, internalNamespaces []*InternalNamespace) {
	into := n
	for _, t := range from.Types {
		into.Types = append(into.Types, t)
		t.ins = into
	}
	for nn := range from.Namespaces {
		n.Namespaces[nn] = struct{}{}
	}
	for nn := range from.DirectImports.ns {
		if nn != into {
			into.DirectImports.ns[nn] = struct{}{}
		}
	}
	into.DirectImports.importSort = into.DirectImports.importSort || from.DirectImports.importSort
	for _, ins := range internalNamespaces {
		if _, ok := ins.DirectImports.ns[from]; ok {
			if ins != into {
				ins.DirectImports.ns[into] = struct{}{}
			}
			// for k2 := range n.DirectImports {
			//	ins.DirectImports[k2] = struct{}{}
			// }
			delete(ins.DirectImports.ns, from)
		}
	}
}

func (n *InternalNamespace) sortedElements() []string {
	var elements []string
	for _, t := range n.Types {
		elements = append(elements, t.TypeString(false))
	}
	slices.Sort(elements)
	return elements
}

func (n *InternalNamespace) sortedRecursiveElements() []string {
	var elements []string
	ri := map[*InternalNamespace][]*InternalNamespace{}
	n.FindRecursiveImports(ri, nil)
	for r := range ri {
		var inside []string
		for _, t := range r.Types {
			inside = append(inside, t.TypeString(false))
		}
		slices.Sort(inside)
		elements = append(elements, strings.Join(inside, ":"))
	}
	slices.Sort(elements)
	return elements
}

func (n *InternalNamespace) sortedDirectElements() []string {
	var elements []string
	for r := range n.DirectImports.ns {
		var inside []string
		for _, t := range r.Types {
			inside = append(inside, t.TypeString(false))
		}
		slices.Sort(inside)
		elements = append(elements, strings.Join(inside, ":"))
	}
	slices.Sort(elements)
	return elements
}

func (n *InternalNamespace) sortedNamespaces() []string {
	var elements []string
	for n := range n.Namespaces {
		elements = append(elements, n)
	}
	slices.Sort(elements)
	return elements
}

type Namespace struct {
	types []*TypeRWWrapper
	dec   Deconflicter
}

type Gen2Options struct {
	TypesWhileList       string
	BytesVersions        string
	TLPackageNameFull    string
	BasicPackageNameFull string // if empty, will be created
	Verbose              bool
	GenerateRPCCode      bool
	BasicRPCPath         string
	TLOPath              string
	GenerateRandomCode   bool
	SchemaDocumentation  bool
	SplitInternal        bool
	Language             string
	RootCPPNamespace     string
	CopyrightFilePath    string
	IgnoreGeneratedCode  bool // ignores generated code, tlo and documentation will be generated with related flags
}

type Gen2 struct {
	// options
	options *Gen2Options // pointer so code modifying options in GenerateCode refers to the same structure

	// artifacts
	RootPackageName string

	// golang specific
	BasicPackageNameFull string // basic types are in separate namespace to minimize conflicts
	GlobalPackageName    string // we generate all go types in this package, because we need circular dependencies
	FactoryPackageName   string
	MetaPackageName      string

	// c++ specific
	RootCPPNamespaceElements    []string
	DetailsCPPNamespaceElements []string
	DetailsCPPNamespace         string // basictl::details

	// parsed TL
	supportedModifierBits map[string]int
	typeDescriptors       map[string][]*tlast.Combinator
	singleConstructors    map[string]*tlast.Combinator // only types with 1 constructor, no functions
	allConstructors       map[string]*tlast.Combinator // for printing beautiful errors

	// generation
	generatedTypes     map[string]*TypeRWWrapper
	generatedTypesList []*TypeRWWrapper // we need more deterministic order than sort predicate can establish

	globalDec  Deconflicter
	Namespaces map[string]*Namespace // Handlers Code is inside

	// result
	TLO           []byte            // schema represented in tlo format, described using tls.* combinator
	Code          map[string]string // fileName->Content, split by file names relative to output dir
	copyrightText string
}

func (gen *Gen2) InternalPrefix() string {
	if gen.options.SplitInternal {
		return "internal."
	}
	return ""
}

func canonicalGoName(name tlast.Name, insideNamespace string) string {
	if name.Namespace == insideNamespace {
		return CNameToCamelName(name.Name)
	}
	return CNameToCamelName(name.Namespace) + CNameToCamelName(name.Name)
}

func canonicalCPPName(name tlast.Name, insideNamespace string) string { // TODO
	if name.Namespace == insideNamespace {
		return name.Name
	}
	return name.Namespace + "_" + name.Name
}

// canonical string, used as a key in instantiated types map
func resolvedT2String(rt ResolvedType) string {
	b := strings.Builder{}
	b.WriteString(rt.Type.String())
	for _, a := range rt.Args {
		b.WriteString("|")
		if a.IsNat {
			if a.isArith {
				b.WriteString(strconv.FormatUint(uint64(a.Arith.Res), 10))
			}
		} else {
			b.WriteString(resolvedT2String(a.T))
			if !a.T.Bare {
				b.WriteString("Boxed")
			}
		}
	}
	return b.String()
}

func resolvedT2GoName(rt ResolvedType, insideNamespace string) (head, tail string) {
	b := strings.Builder{}
	for _, a := range rt.Args {
		if a.IsNat {
			if a.isArith {
				b.WriteString(strconv.FormatUint(uint64(a.Arith.Res), 10))
			}
		} else {
			h, t := resolvedT2GoName(a.T, insideNamespace)
			b.WriteString(h)
			b.WriteString(t)
			if !a.T.Bare {
				b.WriteString("Boxed")
			}
		}
	}
	return canonicalGoName(rt.Type, insideNamespace), b.String()
}

func fullyResolvedClassCppSuffixArgs(rt ResolvedType) (string, []string) { // name in namespace, arguments decl
	cppSuffix := strings.Builder{}
	var cppArgsDecl []string
	for _, a := range rt.Args {
		if a.IsNat {
			if a.isArith {
				cppSuffix.WriteString(a.TemplateArgName)
				cppArgsDecl = append(cppArgsDecl, "uint32_t "+a.TemplateArgName)
			}
		} else {
			cppArgsDecl = append(cppArgsDecl, "typename "+a.TemplateArgName)
		}
	}
	return cppSuffix.String(), cppArgsDecl
}

func resolvedT2CamelName(rt2 ResolvedType, insideNamespace string) string {
	head, tail := resolvedT2GoName(rt2, insideNamespace)
	return head + tail
}

func (gen *Gen2) getNamespace(n string) *Namespace {
	na, ok := gen.Namespaces[n]
	if !ok {
		na = &Namespace{}
		gen.Namespaces[n] = na
		// TODO - ALL golang-specific names
		na.dec.deconflictName("Handler")
		na.dec.deconflictName("Handle")
		na.dec.deconflictName("Client")
		// TODO - if we want lowercase C++ identifiers, we need to add ~100 reserved keywords here
		// na.dec.deconflictName("double")
		// na.dec.deconflictName("int")
		// etc...
	}
	return na
}

func (gen *Gen2) getType(localContext LocalResolveContext, t tlast.TypeRef) (*TypeRWWrapper, ResolvedType, []ActualNatArg, error) {
	return gen.getTypeWithPrefix("nat_", localContext, t)
}

func (gen *Gen2) getTypeWithPrefix(prefix string, localContext LocalResolveContext, t tlast.TypeRef) (*TypeRWWrapper, ResolvedType, []ActualNatArg, error) {
	resolvedType, natArgs, err := gen.resolveType(prefix, localContext, t)
	if err != nil {
		return nil, ResolvedType{}, nil, err
	}
	rNameT2 := resolvedT2String(resolvedType)
	wr, ok := gen.generatedTypes[rNameT2]
	if !ok {
		wr = &TypeRWWrapper{gen: gen, resolvedType: resolvedType, isTopLevel: len(resolvedType.Args) == 0} // TODO -  fix isTopLevel condition
		gen.generatedTypes[rNameT2] = wr
		gen.generatedTypesList = append(gen.generatedTypesList, wr)
		err = gen.generateType(wr, resolvedType)
		if err != nil {
			return nil, ResolvedType{}, nil, err
		}
		if localContext.overrideFileName != "" {
			wr.fileName = localContext.overrideFileName
		} else {
			if gen.options.Language == "cpp" { // Temporary solution to benchmark combined tl
				if resolvedType.Type.Namespace == "" && len(resolvedType.Args) == 1 && !resolvedType.Args[0].IsNat {
					wr.fileName = resolvedType.Args[0].TRW.fileName
				}
			}
		}
		if wr.fileName == "" {
			// TODO - check this is impossible, then return LogicError
			log.Printf("Warning: empty type filename for canonical name %q, will move to 'builtin'", rNameT2)
			wr.fileName = "builtin"
		}
	}
	return wr, resolvedType, natArgs, nil
}

func (gen *Gen2) generateType(myWrapper *TypeRWWrapper, rt2 ResolvedType) error {
	tlType, ok := gen.typeDescriptors[rt2.Type.String()]
	if !ok {
		// we are OK with generating by constructor reference
		// resolveType must prohibit such references depending on its own logic
		if lt, ok := gen.allConstructors[rt2.Type.String()]; ok {
			tlType = append(tlType[:0], lt)
		} else {
			return rt2.PR.LogicError(fmt.Errorf("attempt to generate unknown type %q", rt2.Type.String()))
		}
	}
	lrc, natParams, err := gen.fillLocalResolveContext(tlType[0], rt2)
	if err != nil {
		return err
	}
	myWrapper.NatParams = natParams
	myWrapper.origTL = tlType
	myWrapper.cppNamespaceQualifier = "::" + gen.options.RootCPPNamespace + "::"
	if rt2.Type.Namespace != "" {
		myWrapper.cppNamespaceQualifier += rt2.Type.Namespace + "::"
	}
	if len(tlType) == 1 {
		namespace := gen.getNamespace(rt2.Type.Namespace)
		namespace.types = append(namespace.types, myWrapper)
		myWrapper.ns = namespace
		myWrapper.tlName = tlType[0].Construct.Name
		myWrapper.fileName = tlType[0].Construct.Name.String()
		myWrapper.tlTag = tlType[0].Crc32()
		switch tlType[0].Construct.Name.String() {
		case BuiltinTupleName:
			_, tail := resolvedT2GoName(rt2, "")
			goGlobalName := gen.globalDec.deconflictName("Tuple" + tail)
			return gen.GenerateVectorTuple(myWrapper, false, tlType[0], rt2, goGlobalName, lrc)
		case BuiltinVectorName:
			_, tail := resolvedT2GoName(rt2, "")
			goGlobalName := gen.globalDec.deconflictName("Vector" + tail)
			return gen.GenerateVectorTuple(myWrapper, true, tlType[0], rt2, goGlobalName, lrc)
		}
		goGlobalName := gen.globalDec.deconflictName(resolvedT2CamelName(rt2, ""))
		goLocalName := namespace.dec.deconflictName(resolvedT2CamelName(rt2, rt2.Type.Namespace))
		return gen.generateTypeStruct(lrc, myWrapper, tlType[0], rt2, goGlobalName, goLocalName)
	}
	myWrapper.tlName = tlType[0].TypeDecl.Name
	myWrapper.fileName = tlType[0].TypeDecl.Name.String()
	if isBool, falseDesc, trueDesc := IsUnionBool(tlType); isBool { // TODO - test if parts of Bool are in different namespaces
		namespace := gen.getNamespace(myWrapper.tlName.Namespace)
		namespace.types = append(namespace.types, myWrapper)
		myWrapper.ns = namespace

		head, tail := resolvedT2GoName(rt2, "")
		goGlobalName := gen.globalDec.deconflictName(head + tail)
		myWrapper.trw = &TypeRWBool{
			wr:           myWrapper,
			goGlobalName: goGlobalName,
			falseGoName:  gen.globalDec.deconflictName(CNameToCamelName(falseDesc.Construct.Name.String())),
			trueGoName:   gen.globalDec.deconflictName(CNameToCamelName(trueDesc.Construct.Name.String())),
			falseTag:     falseDesc.Crc32(),
			trueTag:      trueDesc.Crc32(),
		}
		return nil
	}
	if isMaybe, emptyDesc, okDesc := IsUnionMaybe(tlType); isMaybe {
		rt2 = rt2.Args[0].T
		namespace := gen.getNamespace(rt2.Type.Namespace)
		namespace.types = append(namespace.types, myWrapper)
		myWrapper.ns = namespace

		suffix := ifString(rt2.Bare, "Maybe", "BoxedMaybe")
		goGlobalName := gen.globalDec.deconflictName(resolvedT2CamelName(rt2, "") + suffix)
		goLocalName := namespace.dec.deconflictName(resolvedT2CamelName(rt2, rt2.Type.Namespace) + suffix)

		elementT := tlast.TypeRef{Type: tlast.Name{Name: okDesc.TemplateArguments[0].FieldName}} // TODO - PR
		trw, elementResolvedType, elementNatArgs, err := gen.getType(lrc, elementT)
		if err != nil {
			return err
		}
		res := &TypeRWMaybe{
			wr:           myWrapper,
			goGlobalName: goGlobalName,
			goLocalName:  goLocalName,
			element: Field{
				t:            trw,
				originalType: elementT,
				resolvedType: elementResolvedType,
				natArgs:      elementNatArgs,
			},
			emptyTag: emptyDesc.Crc32(),
			okTag:    okDesc.Crc32(),
		}
		myWrapper.fileName = trw.fileName
		myWrapper.trw = res
		return nil
	}
	isEnum := true
	for _, typ := range tlType {
		isEnum = isEnum && len(typ.Fields) == 0
	}

	namespace := gen.getNamespace(rt2.Type.Namespace)
	namespace.types = append(namespace.types, myWrapper)
	myWrapper.ns = namespace

	suffix := ifString(isEnum, "", "Union") // Lesser evil to deconflict union constructor with union name, response = Response
	goGlobalName := gen.globalDec.deconflictName(resolvedT2CamelName(rt2, "") + suffix)
	goLocalName := namespace.dec.deconflictName(resolvedT2CamelName(rt2, rt2.Type.Namespace) + suffix)

	lrc.allowAnyConstructor = true
	lrc.overrideFileName = myWrapper.fileName
	if gen.options.Language == "cpp" {
		if isEnum {
			lrc.overrideFileName += "Items" // in C++ when items and union are in the same file, they msuy be sorted which is hard for us
		} else {
			lrc.overrideFileName = "" // each type must be in its own file to break circular dependencies
		}
	}

	res := &TypeRWUnion{
		wr:           myWrapper,
		goGlobalName: goGlobalName,
		goLocalName:  goLocalName,
		IsEnum:       isEnum,
	}
	res.fieldsDecCPP.fillCPPIdentifiers()
	myWrapper.trw = res

	// removing prefix common with union name.
	typePrefix := strings.ToLower(rt2.Type.Name) // not perfect, but good enough. Constructor starts from lower-case, type from upper-case
	for _, typ := range tlType {
		// if constructor is full prefix of type, we will shorten accessors
		// ab.saveStateOne = ab.SaveState; // item.AsOne()
		// ab.saveStateTwo = ab.SaveState; // item.AsTwo()
		if !strings.HasPrefix(strings.ToLower(typ.Construct.Name.Name), typePrefix) {
			typePrefix = ""
			break
		}
	}
	for i, typ := range tlType {
		// ---- We treat
		// ab.empty = ab.Response;
		// ab.code x:int = ab.Response;
		// ab.response x:int str:string = ab.Response;
		// ---- roughly as
		// ab.empty = _;
		// ab.code x:int = _;
		// ab.response x:int str:string = _;
		// _ tag:# empty:ab.empty code:ab.code response: ab.response = ab.Response;
		fieldType := tlast.TypeRef{
			Type:   typ.Construct.Name,
			Bare:   true,
			PR:     typ.Construct.NamePR,
			PRArgs: typ.TemplateArgumentsPR,
		}
		for _, arg := range typ.TemplateArguments {
			fieldType.Args = append(fieldType.Args, tlast.ArithmeticOrType{
				IsArith: false,
				T: tlast.TypeRef{
					Type:   tlast.Name{Name: arg.FieldName},
					PR:     arg.PR,
					PRArgs: arg.PR.CollapseToEnd(),
				},
			})
		}
		wr, fieldResolvedType, fieldNatArgs, err := gen.getType(lrc, fieldType)
		if err != nil {
			return err
		}
		wr.unionParent = myWrapper
		wr.unionIndex = i
		wr.unionIsEnum = isEnum
		if !fieldResolvedType.Bare {
			return fieldType.PR.LogicError(fmt.Errorf("union element resolved type %q cannot be boxed", fieldResolvedType.Type.String()))
		}
		typeConstructName := typ.Construct.Name
		if len(typePrefix) < len(typeConstructName.Name) {
			typeConstructName.Name = typeConstructName.Name[len(typePrefix):]
		}
		fieldGoName := canonicalGoName(typeConstructName, typ.Construct.Name.Namespace)
		if res.fieldsDec.hasConflict(fieldGoName) { // try global, if local is already used
			fieldGoName = canonicalGoName(typeConstructName, "")
		}
		fieldCPPName := canonicalCPPName(typeConstructName, typ.Construct.Name.Namespace)
		if res.fieldsDecCPP.hasConflict(fieldCPPName) { // try global, if local is already used
			fieldCPPName = canonicalCPPName(typeConstructName, "")
		}
		newField := Field{
			t:            wr,
			goName:       res.fieldsDec.deconflictName(fieldGoName),
			cppName:      res.fieldsDecCPP.deconflictName(fieldCPPName),
			originalName: fieldType.Type.String(),
			originalType: fieldType,
			resolvedType: fieldResolvedType,
			natArgs:      fieldNatArgs,
		}
		res.Fields = append(res.Fields, newField)
		wr.unionField = newField
	}
	return nil
}

func (gen *Gen2) fillLocalResolveContext(tlType *tlast.Combinator, myType2 ResolvedType) (LocalResolveContext, []string, error) {
	lrc := LocalResolveContext{
		localTypeArgs: map[string]LocalTypeArg{},
		localNatArgs:  map[string]LocalNatArg{},
	}
	var natParams []string
	for i, a := range tlType.TemplateArguments {
		if err := lrc.checkArgsCollision(a.FieldName, a.PR, errNatParamNameCollision); err != nil {
			return LocalResolveContext{}, nil, err
		}
		if a.IsNat {
			lrc.localNatArgs[a.FieldName] = LocalNatArg{
				NamePR: a.PR,
				TypePR: a.PR,
				natArg: ActualNatArg{
					isArith: myType2.Args[i].isArith,
					Arith:   myType2.Args[i].Arith,
					name:    "nat_" + a.FieldName,
				},
			}
			if OptimizeConstParameters && myType2.Args[i].isArith {
				continue
			}
			natParams = append(natParams, "nat_"+a.FieldName)
			continue
		}
		natArgsCount := collectNatParamFromResolvedType(myType2.Args[i].T)
		var natParams3 []string
		if natArgsCount == 1 {
			natParams3 = append(natParams3, "nat_"+a.FieldName) // do not add unnecessary "0"
		} else {
			for j := 0; j < natArgsCount; j++ {
				natParams3 = append(natParams3, "nat_"+a.FieldName+strconv.Itoa(j))
			}
		}
		natParams = append(natParams, natParams3...)
		lrc.localTypeArgs[a.FieldName] = LocalTypeArg{
			resolvedType: myType2.Args[i].T,
			natParams:    natParams3,
			PR:           a.PR,
		}
	}
	return lrc, natParams, nil
}

func (gen *Gen2) generateTypeStruct(lrc LocalResolveContext, myWrapper *TypeRWWrapper, tlType *tlast.Combinator, myType2 ResolvedType, goGlobalName string, goLocalName string) error {
	res := &TypeRWStruct{
		wr:           myWrapper,
		goGlobalName: goGlobalName,
		goLocalName:  goLocalName,
	}
	res.fieldsDecCPP.fillCPPIdentifiers()
	myWrapper.trw = res
	for i, field := range tlType.Fields {
		wr, fieldResolvedType, fieldNatArgs, err := gen.getType(lrc, field.FieldType)
		if err != nil {
			return err
		}
		fieldName := field.FieldName
		if fieldName == "" {
			// TODO - it would be nice to prohibit anonymous field name, unless it is single field
			fieldName = "a" + strconv.Itoa(i)
		}
		newField := Field{
			t:            wr,
			goName:       res.fieldsDec.deconflictName(CNameToCamelName(fieldName)),
			cppName:      res.fieldsDecCPP.deconflictName(fieldName),
			originalName: field.FieldName,
			originalType: field.FieldType,
			resolvedType: fieldResolvedType,
			natArgs:      fieldNatArgs,
		}
		if field.Mask != nil {
			if field.Mask.BitNumber >= 32 {
				return field.Mask.PRBits.BeautifulError(fmt.Errorf("bitmask (%d) must be in range [0..32)", field.Mask.BitNumber))
			}
			newField.BitNumber = field.Mask.BitNumber
			localArg, ok := lrc.localNatArgs[field.Mask.MaskName]
			if !ok {
				return field.Mask.PRName.BeautifulError(fmt.Errorf("failed to resolve field mask %q reference", field.Mask.MaskName))
			}
			if localArg.wrongTypeErr != nil {
				e1 := field.Mask.PRName.BeautifulError(fmt.Errorf("field mask %q reference to field of wrong type", field.Mask.MaskName))
				e2 := localArg.TypePR.BeautifulError(localArg.wrongTypeErr)
				return tlast.BeautifulError2(e1, e2)
			}
			newField.fieldMask = &localArg.natArg
		}
		res.Fields = append(res.Fields, newField)
		arg := LocalNatArg{
			NamePR: field.PRName,
			TypePR: field.FieldType.PR,
			natArg: ActualNatArg{isField: true, FieldIndex: i},
		}
		if field.FieldType.Type.String() != "#" {
			arg.wrongTypeErr = fmt.Errorf("referenced field %q must have type #", field.FieldName)
		}
		if field.FieldName == "" {
			continue
		}
		if err := lrc.checkArgsCollision(field.FieldName, field.PRName, errFieldNameCollision); err != nil {
			return err
		}
		lrc.localNatArgs[field.FieldName] = arg
	}
	if tlType.IsFunction {
		ftrw, resultResolvedType, resultNatArgs, err := gen.getType(lrc, tlType.FuncDecl)
		if err != nil {
			return err
		}
		if resultResolvedType.Bare {
			// @read a.TypeA = int;
			// @read a.TypeB = %Int;
			return tlType.FuncDecl.PR.BeautifulError(fmt.Errorf("function %q result cannot be bare", tlType.Construct.Name.String()))
		}
		res.ResultType = ftrw
		res.ResultNatArgs = resultNatArgs
		res.ResultResolvedType = resultResolvedType
	}
	return nil
}

func collectNatParamFromResolvedType(rt ResolvedType) int {
	result := 0
	for _, arg := range rt.Args {
		if arg.IsNat {
			if !arg.isArith || !OptimizeConstParameters {
				result++
			}
			continue
		}
		result += collectNatParamFromResolvedType(arg.T)
	}
	return result
}

// TODO - remove prefix
func (gen *Gen2) resolveType(prefix string, localContext LocalResolveContext, t tlast.TypeRef) (ResolvedType, []ActualNatArg, error) {
	var actualNatArgs []ActualNatArg
	var resolvedT ResolvedType
	tName := t.Type.String()
	// Each named reference is either global type, global constructor, local param or local field
	if localArg, ok := localContext.localNatArgs[tName]; ok {
		e1 := t.PR.BeautifulError(fmt.Errorf("reference to %s %q where type is required", ifString(localArg.natArg.isField, "field", "#-param"), tName))
		e2 := localArg.NamePR.BeautifulError(errSeeHere)
		return ResolvedType{}, nil, tlast.BeautifulError2(e1, e2)
	}
	if lt, ok := localContext.localTypeArgs[tName]; ok {
		if len(t.Args) != 0 {
			e1 := t.PR.BeautifulError(fmt.Errorf("reference to template type arg %q cannot have arguments", tName))
			e2 := lt.PR.BeautifulError(fmt.Errorf("defined here"))
			return ResolvedType{}, nil, tlast.BeautifulError2(e1, e2)
		}
		if t.Bare { // overwrite bare
			// myUnionA = MyUnion;
			// myUnionB b:int = MyUnion;
			// wrapper {T:Type} a:%T = Wrapper T;
			// useWarpper xx:(wrapper MyUnion) = UseWrapper;
			lt.resolvedType.Bare = true
		}
		for _, p := range lt.natParams {
			actualNatArgs = append(actualNatArgs, ActualNatArg{
				name: p,
			})
		}
		lt.resolvedType.OriginalName = tName
		return lt.resolvedType, actualNatArgs, nil
	}
	var td *tlast.Combinator
	if lt, ok := gen.typeDescriptors[tName]; ok { // order of this if-else chain is important for built-ins
		if len(lt) > 1 && t.Bare {
			// myUnionA = MyUnion;
			// myUnionB b:int = MyUnion;
			// useUnion a:%MyUnion = UseUnion;
			e1 := t.PR.BeautifulError(fmt.Errorf("reference to union %q cannot be bare", tName))
			e2 := lt[0].TypeDecl.NamePR.BeautifulError(fmt.Errorf("see more"))
			return ResolvedType{}, nil, tlast.BeautifulError2(e1, e2)
		}
		td = lt[0] // for type checking, any constructor is ok for us, because they all must have the same args
		conName := td.Construct.Name.String()
		if con2, ok := gen.singleConstructors[conName]; ok && t.Bare && !con2.IsFunction && con2.TypeDecl.Name.String() == "_" {
			// bare references to wrappers %int have int canonical form,
			// otherwise vectors, maybes and other templates will be generated twice
			t.Type = td.Construct.Name
		}
	} else if lt, ok := gen.singleConstructors[tName]; ok {
		td = lt
		t.Bare = true
		if td.TypeDecl.Name.String() != "_" {
			// We use "_" in type declaration for internal types which cannot be boxed
			// We could wish to extend this definition to user types in the future
			// If there is no boxed version, constructor name is canonical reference, otherwise
			// Type name is canonical reference. We need canonical references to avoid generating type more than once
			t.Type = td.TypeDecl.Name
		}
	} else if lt, ok := gen.allConstructors[tName]; ok {
		if !localContext.allowAnyConstructor {
			e1 := t.PR.BeautifulError(fmt.Errorf("reference to %s constructor %q is not allowed", ifString(lt.IsFunction, "function", "union"), tName))
			e2 := lt.Construct.NamePR.BeautifulError(fmt.Errorf("see more"))
			return ResolvedType{}, nil, tlast.BeautifulError2(e1, e2)
		}
		// Here type name is already in canonical form, because this code path is only internal for union members and functions
		td = lt
		t.Bare = true
	}
	if td == nil {
		return ResolvedType{}, nil, t.PR.BeautifulError(fmt.Errorf("error resolving name %q", tName))
	}
	if len(td.TemplateArguments) > len(t.Args) {
		arg := td.TemplateArguments[len(t.Args)]
		e1 := t.PRArgs.CollapseToEnd().BeautifulError(fmt.Errorf("missing template argument %q here", arg.FieldName))
		e2 := arg.PR.BeautifulError(fmt.Errorf("declared here"))
		return ResolvedType{}, nil, tlast.BeautifulError2(e1, e2)
	}
	if len(td.TemplateArguments) < len(t.Args) {
		arg := t.Args[len(td.TemplateArguments)]
		e1 := arg.T.PR.BeautifulError(fmt.Errorf("excess template argument %q here", arg.String()))
		e2 := td.TemplateArgumentsPR.BeautifulError(fmt.Errorf("arguments declared here"))
		return ResolvedType{}, nil, tlast.BeautifulError2(e1, e2)
	}
	t.Args = append([]tlast.ArithmeticOrType{}, t.Args...) // copy args to avoid damaging source type
	resolvedT.Type = t.Type
	resolvedT.Bare = t.Bare
	resolvedT.PR = t.PR
	for i, a := range t.Args {
		ta := td.TemplateArguments[i]
		aName := a.T.Type.String()
		p2 := prefix + ta.FieldName
		if ta.IsNat {
			if a.IsArith {
				if !OptimizeConstParameters {
					actualNatArgs = append(actualNatArgs, ActualNatArg{isArith: true, Arith: a.Arith})
				}
				resolvedT.Args = append(resolvedT.Args, ResolvedArg{TemplateArgName: ta.FieldName, IsNat: true, isArith: true, Arith: a.Arith})
				continue
			}
			if localArg, ok := localContext.localNatArgs[aName]; ok {
				if localArg.wrongTypeErr != nil {
					e1 := a.T.PR.BeautifulError(fmt.Errorf("error resolving reference %q to #-param %q", aName, ta.FieldName))
					e2 := localArg.TypePR.BeautifulError(localArg.wrongTypeErr)
					return ResolvedType{}, nil, tlast.BeautifulError2(e1, e2)
				}
				if !localArg.natArg.isArith || !OptimizeConstParameters {
					actualNatArgs = append(actualNatArgs, localArg.natArg)
				}
				resolvedT.Args = append(resolvedT.Args, ResolvedArg{TemplateArgName: ta.FieldName, IsNat: true, T: ResolvedType{OriginalName: aName}, isArith: localArg.natArg.isArith, Arith: localArg.natArg.Arith})
				continue
			}
			if localArg, ok := localContext.localTypeArgs[aName]; ok {
				e1 := a.T.PR.BeautifulError(fmt.Errorf("reference to local Type-arg %q where #-arg is required", aName))
				e2 := localArg.PR.BeautifulError(fmt.Errorf("arg declared here"))
				return ResolvedType{}, nil, tlast.BeautifulError2(e1, e2)
			}
			e1 := a.T.PR.BeautifulError(fmt.Errorf("error resolving reference %q to #-param %q", aName, ta.FieldName))
			e2 := ta.PR.BeautifulError(fmt.Errorf("see more"))
			return ResolvedType{}, nil, tlast.BeautifulError2(e1, e2)
		}
		if a.IsArith {
			e1 := a.T.PR.BeautifulError(fmt.Errorf("passing constant %q to Type-param %q is impossible", a.Arith.String(), ta.FieldName))
			e2 := ta.PR.BeautifulError(fmt.Errorf("declared here"))
			return ResolvedType{}, nil, tlast.BeautifulError2(e1, e2)
		}
		internalTRW, internalType, internalNatArgs, err := gen.getTypeWithPrefix(p2, localContext, a.T)
		if err != nil {
			return ResolvedType{}, nil, err
		}
		actualNatArgs = append(actualNatArgs, internalNatArgs...)
		resolvedT.Args = append(resolvedT.Args, ResolvedArg{TemplateArgName: ta.FieldName, T: internalType, TRW: internalTRW})
	}
	return resolvedT, actualNatArgs, nil
}

func checkTagCollisions(tl tlast.TL) error {
	constructorTags := map[uint32]*tlast.Combinator{}
	for _, typ := range tl {
		crc32 := typ.Crc32()
		if crc32 == 0 {
			// typeA#00000000 = TypeA;
			return typ.Construct.IDPR.BeautifulError(fmt.Errorf("constructor tag 0 is prohibited, even if generated implicitly"))
		}
		if col, ok := constructorTags[crc32]; ok {
			// typeA#dfc15abf = TypeA;
			// typeB#dfc15abf = TypeB;
			e1 := typ.Construct.IDPR.BeautifulError(fmt.Errorf("constructor tag #%08x used by %q is used again by %q", crc32, col.Construct.Name.String(), typ.Construct.Name.String()))
			e2 := col.Construct.IDPR.BeautifulError(errSeeHere)
			return tlast.BeautifulError2(e1, e2)
		}
		constructorTags[crc32] = typ
	}
	return nil
}

func (gen *Gen2) buildMapDescriptors(tl tlast.TL) error {
	// Collect unions, check that functions cannot form a union with each other or with normal singleConstructors
	for _, typ := range tl {
		for _, f := range typ.Fields {
			if len(f.FieldName) == 0 && (len(typ.Fields) != 1 || f.Mask != nil) {
				f.PR.BeautifulWarning(fmt.Errorf("anonymous fields are discouraged, except when used in '# a:[int]' pattern or when type has single anonymous field without fieldmask (typedef-like)")).ConsolePrint(nil)
				fmt.Printf("\n")
			}
		}
		conName := typ.Construct.Name.String()
		if col, ok := gen.allConstructors[conName]; ok {
			// typeA = TypeA;
			// typeA = TypeB;
			e1 := typ.Construct.NamePR.BeautifulError(fmt.Errorf("constructor name %q is used again here", conName))
			e2 := col.Construct.NamePR.BeautifulError(errSeeHere)
			return tlast.BeautifulError2(e1, e2)
		}
		gen.allConstructors[conName] = typ
		if !typ.IsFunction {
			typeName := typ.TypeDecl.Name.String()
			if typeName != "_" { // prohibit boxed type
				if len(typ.TemplateArguments) > len(typ.TypeDecl.Arguments) {
					// rightLeftArgs {X:Type} {Y:#} = RightLeftArgs X; <- bad
					arg := typ.TemplateArguments[len(typ.TypeDecl.Arguments)]
					return typ.TypeDecl.PR.CollapseToEnd().BeautifulError(fmt.Errorf("type declaration %q is missing template argument %q here", typeName, arg.FieldName))
				}
				if len(typ.TemplateArguments) < len(typ.TypeDecl.Arguments) {
					// rightLeftArgs {X:Type} {Y:#} = RightLeftArgs X Y Y; <- bad
					arg := typ.TypeDecl.Arguments[len(typ.TemplateArguments)]
					pr := typ.TypeDecl.ArgumentsPR[len(typ.TemplateArguments)]
					return pr.BeautifulError(fmt.Errorf("type declaration %q has excess template argument %q here", typeName, arg))
				}
				for j, t := range typ.TemplateArguments {
					if t.FieldName != typ.TypeDecl.Arguments[j] {
						// rightLeftArgs {X:Type} {Y:#} = RightLeftArgs Y X;   <- bad
						pr := typ.TypeDecl.ArgumentsPR[j]
						typArg := typ.TypeDecl.Arguments[j]
						e1 := pr.BeautifulError(fmt.Errorf("type declaration %q has wrong template argument name %q here", typeName, typArg))
						e2 := t.PR.BeautifulError(errSeeHere)
						return tlast.BeautifulError2(e1, e2)
					}
				}
				gen.typeDescriptors[typeName] = append(gen.typeDescriptors[typeName], typ)
			}
		} else {
			if len(typ.Modifiers) == 0 {
				typ.Construct.NamePR.CollapseToBegin().BeautifulWarning(fmt.Errorf("function constructor %q without modifier (identifier starting with '@') not recommended", typ.Construct.Name.String())).ConsolePrint(nil)
				fmt.Printf("\n")
			}
			for _, m := range typ.Modifiers {
				if _, ok := gen.supportedModifierBits[m.Name]; !ok {
					m.PR.BeautifulWarning(fmt.Errorf("modifier %q not known to tl compiler", m.Name)).ConsolePrint(nil)
					fmt.Printf("\n")
				}
			}
		}
	}
	for _, typ := range gen.typeDescriptors {
		if len(typ) == 1 { // here there is no functions
			conName := typ[0].Construct.Name.String()
			if col, ok := gen.singleConstructors[conName]; ok {
				e1 := typ[0].Construct.NamePR.LogicError(fmt.Errorf("constructor name %q is used again here", conName))
				e2 := col.Construct.NamePR.BeautifulError(errSeeHere)
				return tlast.BeautifulError2(e1, e2)
			}
			gen.singleConstructors[conName] = typ[0]
			continue
		}
		if err := checkUnionElementsCompatibility(typ); err != nil {
			return err
		}
	}
	return nil
}

func checkUnionElementsCompatibility(types []*tlast.Combinator) error {
	for _, typ := range types {
		s1 := strings.ToLower(typ.TypeDecl.Name.String())
		s2 := strings.ToLower(typ.Construct.Name.String())
		if s1 == s2 {
			e1 := typ.Construct.NamePR.BeautifulWarning(fmt.Errorf("union type name collision with constructor"))
			e2 := typ.TypeDecl.PR.BeautifulError(errSeeHere)
			tlast.BeautifulError2(e1, e2).ConsolePrint(nil)
			fmt.Printf("\n")
		}
	}
	base := types[0]
	for _, typ := range types[1:] {
		cur := typ.Construct.Name.String()
		if len(typ.TemplateArguments) < len(base.TemplateArguments) {
			baseArg := base.TemplateArguments[len(typ.TemplateArguments)]
			// unionArgs2 {A:Type} {B:#} a:A = UnionArgs A B;
			// unionArgs1 {X:Type} a:X = UnionArgs X;
			e1 := typ.TemplateArgumentsPR.CollapseToEnd().BeautifulError(fmt.Errorf("union constructor %q has missing argument %q here", cur, baseArg.FieldName))
			e2 := baseArg.PR.BeautifulError(errSeeHere)
			return tlast.BeautifulError2(e1, e2)
		}
		if len(typ.TemplateArguments) > len(base.TemplateArguments) {
			typArg := typ.TemplateArguments[len(base.TemplateArguments)]
			// unionArgs1 {X:Type} a:X = UnionArgs X;
			// unionArgs2 {A:Type} {B:#} a:A = UnionArgs A B;
			e1 := typArg.PR.BeautifulError(fmt.Errorf("union constructor %q has excess argument %q here", cur, typArg.FieldName))
			e2 := base.TemplateArgumentsPR.CollapseToEnd().BeautifulError(errSeeHere)
			return tlast.BeautifulError2(e1, e2)
		}
		for i, typArg := range typ.TemplateArguments {
			baseArg := base.TemplateArguments[i]
			// unionArgs1 {X:Type} {Y:#} a:X = UnionArgs X Y;
			// unionArgs2 {A:Type} {B:Type} a:A = UnionArgs A B;
			// We cannot support this, because resolveType replaces parameter names into names of first union field
			if baseArg.IsNat != typArg.IsNat || baseArg.FieldName != typArg.FieldName {
				e1 := typArg.PR.BeautifulError(fmt.Errorf("union constructor %q has different argument name or type here %q", cur, typArg.FieldName))
				e2 := baseArg.PR.BeautifulError(errSeeHere)
				return tlast.BeautifulError2(e1, e2)
			}
		}
	}
	return nil
}

func inBytesVersionFilter(name tlast.Name, filter string) bool {
	if strings.HasSuffix(filter, ".") && name.Namespace == strings.TrimSuffix(filter, ".") {
		return true
	}
	if !strings.HasSuffix(filter, ".") && name.String() == filter {
		return true
	}
	return false
}

func collectRelativePaths(absDirName string, relDirName string, relativeFiles map[string]bool, relativeDirs *[]string) error {
	fis, err := os.ReadDir(absDirName)
	if err != nil {
		return err
	}
	for _, fi := range fis { // try all snapshots, loading the latest
		relFilename := filepath.Join(relDirName, fi.Name())
		absFilename := filepath.Join(absDirName, fi.Name())
		if fi.IsDir() {
			*relativeDirs = append(*relativeDirs, relFilename)
			if err = collectRelativePaths(absFilename, relFilename, relativeFiles, relativeDirs); err != nil {
				return err
			}
			continue
		}
		relativeFiles[relFilename] = true
	}
	return nil
}

// WriteToDir Most common action with generated code, so clients do not repeat it
func (gen *Gen2) WriteToDir(outdir string) error {
	if gen.options.IgnoreGeneratedCode {
		return nil
	}
	if err := os.Mkdir(outdir, 0755); err != nil && !os.IsExist(err) { // we thus require parent directory to exist
		return fmt.Errorf("error creating outdir %q: %w", outdir, err)
	}
	// We do not want to touch files which did not change at all.
	relativeFiles := map[string]bool{}
	var relativeDirs []string
	if err := collectRelativePaths(outdir, "", relativeFiles, &relativeDirs); err != nil {
		return fmt.Errorf("error reading outdir content %q: %w", outdir, err)
	}
	if len(relativeFiles) != 0 && !relativeFiles[markerFile] {
		return fmt.Errorf("outdir %q not empty and has no %q marker file, please clean manually", outdir, markerFile)
	}
	notTouched := 0
	written := 0
	deleted := 0
	for filepathName, code := range gen.Code {
		d := filepath.Join(outdir, filepath.Dir(filepathName))
		if err := os.MkdirAll(d, 0755); err != nil && !os.IsExist(err) {
			return fmt.Errorf("error creating dir %q: %w", d, err)
		}
		f := filepath.Join(outdir, filepathName)
		if relativeFiles[filepathName] {
			delete(relativeFiles, filepathName)
			was, err := os.ReadFile(f)
			if err != nil {
				return fmt.Errorf("error reading previous file %q: %w", f, err)
			}
			if string(was) == code {
				notTouched++
				continue
			}
		}
		written++
		if err := os.WriteFile(f, []byte(code), 0644); err != nil {
			return fmt.Errorf("error writing file %q: %w", f, err)
		}
	}
	for filepathName := range relativeFiles {
		deleted++
		f := filepath.Join(outdir, filepathName)
		if err := os.Remove(f); err != nil {
			return fmt.Errorf("error deleting previous file %q: %w", f, err)
		}
	}
	for i := len(relativeDirs) - 1; i >= 0; i-- {
		f := filepath.Join(outdir, relativeDirs[i])
		_ = os.Remove(f) // non-empty dirs simply will not remove. This is good enough for us
	}
	fmt.Printf("%d target files did not change so were not touched, %d written, %d deleted\n", notTouched, written, deleted)
	return nil
}

func (gen *Gen2) addCodeFile(filepathName string, code string) error {
	if _, ok := gen.Code[filepathName]; ok {
		return fmt.Errorf("generator %sinternal error%s: source file %q is generated twice", color.Red, color.Reset, filepathName)
	}
	gen.Code[filepathName] = code
	return nil
}

func GenerateCode(tl tlast.TL, options Gen2Options) (*Gen2, error) {
	if options.TLPackageNameFull == "" { // for testing, empty path should be prohibited in main argv parsing
		options.TLPackageNameFull = "github.com/vkcom/tl/internal/tlcodegen/output/tl"
	}
	if options.RootCPPNamespace == "" {
		options.RootCPPNamespace = "tl2"
	}
	options.TLPackageNameFull = strings.TrimSpace(options.TLPackageNameFull)
	if options.Language == "" {
		options.Language = "go"
	}
	gen := &Gen2{
		options:    &options,
		Code:       map[string]string{},
		Namespaces: map[string]*Namespace{},
		// Files:                 map[string][]*TypeRWWrapper{},
		supportedModifierBits: map[string]int{}, // filled statically for now, will be read from TL file later
		typeDescriptors:       map[string][]*tlast.Combinator{},
		allConstructors:       map[string]*tlast.Combinator{},
		singleConstructors:    map[string]*tlast.Combinator{},
	}
	switch options.Language {
	case "go", "cpp":
		break
	default:
		return nil, fmt.Errorf("unsupported language %q, only 'go' and 'cpp' are supported", options.Language)
	}
	if options.Language == "go" {
		elements := strings.Split(options.TLPackageNameFull, "/")
		if len(elements) < 3 {
			return nil, fmt.Errorf("full go package name must have 2 non-empty rightmost path elements, for example '.../output/tl")
		}
		options.TLPackageNameFull = strings.Join(elements[:len(elements)-1], "/")
		gen.GlobalPackageName = elements[len(elements)-1]
		gen.RootPackageName = elements[len(elements)-2]
		gen.FactoryPackageName = strings.Join(append(elements[:len(elements)-1], FactoryGoPackageName), "/")
		gen.MetaPackageName = strings.Join(append(elements[:len(elements)-1], MetaGoPackageName), "/")
		if gen.GlobalPackageName == "" || elements[len(elements)-2] == "" {
			return nil, fmt.Errorf("full go package name must have 2 non-empty rightmost path elements, for example '.../output/tl")
		}
		if gen.options.BasicPackageNameFull == "" {
			gen.BasicPackageNameFull = strings.Join(append(elements[:len(elements)-1], BasicTLGoPackageName), "/")
		} else {
			elements = strings.Split(gen.options.BasicPackageNameFull, "/")
			if len(elements) < 2 || elements[len(elements)-1] != BasicTLGoPackageName {
				return nil, fmt.Errorf("basictl go package name must end with '/%s'", BasicTLGoPackageName)
			}
			gen.BasicPackageNameFull = gen.options.BasicPackageNameFull
		}
	}
	if options.Language == "cpp" {
		gen.RootCPPNamespaceElements = strings.Split(options.RootCPPNamespace, "::")
		gen.DetailsCPPNamespaceElements = []string{options.RootCPPNamespace, "details"} // TODO - rename to prevent collisions with TL namespace details
		gen.DetailsCPPNamespace = options.RootCPPNamespace + "::details"
	}
	typesWhiteList := strings.Split(options.TypesWhileList, ",")
	for i := 0; i < len(typesWhiteList); i++ {
		typesWhiteList[i] = strings.TrimSpace(typesWhiteList[i])
		if len(typesWhiteList[i]) == 0 {
			typesWhiteList = append(typesWhiteList[:i], typesWhiteList[i+1:]...)
		}
	}
	generateByteVersions := strings.Split(options.BytesVersions, ",")
	for i := 0; i < len(generateByteVersions); i++ {
		generateByteVersions[i] = strings.TrimSpace(generateByteVersions[i])
		if len(generateByteVersions[i]) == 0 {
			generateByteVersions = append(generateByteVersions[:i], generateByteVersions[i+1:]...)
		}
	}
	gen.supportedModifierBits = map[string]int{"@read": 0, "@any": 1, "@internal": 2, "@write": 3, "@readwrite": 4, "@kphp": 5}
	rootNamespace := gen.getNamespace("")
	gen.generatedTypes = map[string]*TypeRWWrapper{
		"#": {trw: &TypeRWPrimitive{
			primitiveType:     "uint32",
			cppPrimitiveType:  "uint32_t",
			cppDefaultInit:    " = 0",
			cppFunctionSuffix: "nat",
			cppResetValue:     "%s = 0;",
			writeJSONValue:    "basictl.JSONWriteUint32",
			readJSONValue:     gen.InternalPrefix() + "JsonReadUint32",
			resetValue:        "%s = 0",
			randomValue:       "basictl.RandomNat",
			writeValue:        "basictl.NatWrite",
			readValue:         "basictl.NatRead"}, fileName: "nat", ns: rootNamespace, gen: gen},
		"int": {trw: &TypeRWPrimitive{
			primitiveType:     "int32",
			cppPrimitiveType:  "int32_t",
			cppDefaultInit:    " = 0",
			cppFunctionSuffix: "int",
			cppResetValue:     "%s = 0;",
			writeJSONValue:    "basictl.JSONWriteInt32",
			readJSONValue:     gen.InternalPrefix() + "JsonReadInt32",
			resetValue:        "%s = 0",
			randomValue:       "basictl.RandomInt",
			writeValue:        "basictl.IntWrite",
			readValue:         "basictl.IntRead"}, fileName: "int", ns: rootNamespace, gen: gen},
		"long": {trw: &TypeRWPrimitive{
			primitiveType:     "int64",
			cppPrimitiveType:  "int64_t",
			cppDefaultInit:    " = 0",
			cppFunctionSuffix: "long",
			cppResetValue:     "%s = 0;",
			writeJSONValue:    "basictl.JSONWriteInt64",
			readJSONValue:     gen.InternalPrefix() + "JsonReadInt64",
			resetValue:        "%s = 0",
			randomValue:       "basictl.RandomLong",
			writeValue:        "basictl.LongWrite",
			readValue:         "basictl.LongRead"}, fileName: "long", ns: rootNamespace, gen: gen},
		"float": {trw: &TypeRWPrimitive{
			primitiveType:     "float32",
			cppPrimitiveType:  "float",
			cppDefaultInit:    " = 0",
			cppFunctionSuffix: "float",
			cppResetValue:     "%s = 0;",
			writeJSONValue:    "basictl.JSONWriteFloat32",
			readJSONValue:     gen.InternalPrefix() + "JsonReadFloat32",
			resetValue:        "%s = 0",
			randomValue:       "basictl.RandomFloat",
			writeValue:        "basictl.FloatWrite",
			readValue:         "basictl.FloatRead",
			isFloat:           true}, fileName: "float", ns: rootNamespace, gen: gen},
		"double": {trw: &TypeRWPrimitive{
			primitiveType:     "float64",
			cppPrimitiveType:  "double",
			cppDefaultInit:    " = 0",
			cppFunctionSuffix: "double",
			cppResetValue:     "%s = 0;",
			writeJSONValue:    "basictl.JSONWriteFloat64",
			readJSONValue:     gen.InternalPrefix() + "JsonReadFloat64",
			resetValue:        "%s = 0",
			randomValue:       "basictl.RandomDouble",
			writeValue:        "basictl.DoubleWrite",
			readValue:         "basictl.DoubleRead",
			isFloat:           true}, fileName: "double", ns: rootNamespace, gen: gen},
		"string": {trw: &TypeRWPrimitive{
			primitiveType:     "string",
			cppPrimitiveType:  "std::string",
			cppDefaultInit:    "",
			cppFunctionSuffix: "string",
			cppResetValue:     "%s.clear();",
			writeJSONValue:    "basictl.JSONWriteString",
			readJSONValue:     gen.InternalPrefix() + "JsonReadString",
			resetValue:        "%s = \"\"",
			randomValue:       "basictl.RandomString",
			writeValue:        "basictl.StringWrite",
			readValue:         "basictl.StringRead",
			writeHasError:     true,
			isString:          true}, fileName: "string", ns: rootNamespace, gen: gen},
	}
	builtinBeautifulText := fmt.Sprintf(`
%s {t:Type} {n:#} ? = _ t n; // builtin tuple
%s {t:Type} # [t] = _ t; // builtin vector
`, BuiltinTupleName, BuiltinVectorName)
	builtinTypes := map[string]bool{}
	var builtinNames []string
	for cn, t := range gen.generatedTypes {
		builtinNames = append(builtinNames, cn)
		gen.generatedTypesList = append(gen.generatedTypesList, t) // order does not matter, as names are different enough for our predicate
	}
	slices.Sort(builtinNames) // technically order of lines does not matter, but...
	for _, cn := range builtinNames {
		builtinBeautifulText += fmt.Sprintf("%s ? = _; // builtin primitive type\n", cn)
		builtinTypes[cn] = true
	}
	btl, err := tlast.ParseTL2(builtinBeautifulText, "<builtin>", true) // We need references to token positions for beautification
	if err != nil {
		return nil, fmt.Errorf("failed to parse internal builtin type representation for beautification: %w", err)
	}
	for i, typ := range tl { // replace built-in
		tName := typ.Construct.Name.String()
		// convert that old syntax to new syntax.
		if !typ.Builtin {
			continue
		}
		if len(typ.TemplateArguments) != 0 {
			return nil, typ.TemplateArgumentsPR.BeautifulError(fmt.Errorf("builtin wrapper %q cannot have template parameters", tName))
		}
		if !builtinTypes[tName] {
			return nil, typ.Construct.NamePR.BeautifulError(fmt.Errorf("builtin wrapper %q must have constructor name equal to some builtin type", tName))
		}
		newDesc := &tlast.Combinator{}
		*newDesc = *tl[i]
		newDesc.OriginalDescriptor = typ
		newDesc.Fields = append(newDesc.Fields, tlast.Field{
			FieldType: tlast.TypeRef{
				Type: tlast.Name{Name: tName},
				Bare: true,
			},
		})
		newDesc.Builtin = false
		tl[i] = newDesc
	}
	if options.Verbose {
		log.Printf("checking tags collisions...")
	}
	if err := checkTagCollisions(tl); err != nil {
		return nil, err
	}
	if options.Verbose {
		log.Printf("transforming collections into canonical tuples...")
	}

	// for _, c := range tl {
	//	fmt.Printf("%s\n", c.String())
	// }
	tlTLO, err := ReplaceSquareBracketsElem(tl, true)
	if err != nil {
		return nil, fmt.Errorf("replacing with canonical tuples: %w", err)
	}
	// for _, c := range tlTLO {
	//	fmt.Printf("%s\n", c.String())
	// }
	if options.TLOPath != "" {
		filepathName := gen.RootPackageName + tloExt + jsonExt
		if options.Verbose {
			log.Printf("generating tlo to %s", filepathName)
		}
		err = gen.buildMapDescriptors(tlTLO)
		if err != nil {
			return nil, err
		}
		tlo, tloJSON, err := gen.generateTLO()
		if err != nil {
			return gen, fmt.Errorf("can't generate TLO: %v", err)
		}
		gen.TLO = tlo
		if err := gen.addCodeFile(filepathName, string(utils.JsonPrettyPrint(tloJSON))); err != nil {
			return gen, err
		}
		// Clear map descriptors, we will build them again after replacing square brackets
		gen.typeDescriptors = map[string][]*tlast.Combinator{}
		gen.allConstructors = map[string]*tlast.Combinator{}
		gen.singleConstructors = map[string]*tlast.Combinator{}
	}

	// ReplaceSquareBrackets will generate types with id 0, we will not generate boxed methods for such types
	if tl, err = ReplaceSquareBracketsElem(tl, false); err != nil {
		return nil, fmt.Errorf("replacing with canonical tuples: %w", err)
	}
	if options.Verbose {
		log.Printf("checking name collisions...")
	}
	err = gen.buildMapDescriptors(tl)
	if err != nil {
		return nil, err
	}

	// Now we replace all builtin legitimate builtin wrapper constructors to constructors of builtins
	// Int and %Int will reference wrappers, while int will reference builtin constructor.
	// To avoid 2 canonical forms, resolveType will replace %Int to int for wrappers
	for _, bt := range btl {
		tName := bt.Construct.Name.String()
		typ, ok := gen.allConstructors[tName]
		var zero uint32
		bt.Construct.ID = &zero
		if ok {
			// vasya ? = Int;
			// vasya {T:Type} {N:#} ? = Int T N;
			// int {T:Type} {N:#} int = Int T N;
			// int = Int;
			// int int int = Int;
			// int vasya:int = Int;
			// int n.0?int = Int;
			// int (int 5) = Int;
			// int (%Int) = Int;
			// int (Int) = Int;
			// int ? = Int;   <-- allowed, but deprecated shape. TODO - prohibit in TL2
			// int int = Int; <-- allowed shape
			if len(typ.TemplateArguments) != 0 {
				return nil, typ.TemplateArgumentsPR.BeautifulError(fmt.Errorf("builtin wrapper %q cannot have template parameters", tName))
			}
			if len(typ.Fields) == 0 {
				return nil, typ.TemplateArgumentsPR.CollapseToEnd().BeautifulError(fmt.Errorf("builtin wrapper %q must have exactly 1 field", tName))
			}
			if len(typ.Fields) > 1 {
				return nil, typ.Fields[1].FieldType.PR.BeautifulError(fmt.Errorf("builtin wrapper %q has excess field, must have exactly 1", tName))
			}
			if typ.Fields[0].FieldName != "" {
				return nil, typ.Fields[0].PRName.BeautifulError(fmt.Errorf("builtin wrapper %q field must be anonymous", tName))
			}
			if typ.Fields[0].Mask != nil {
				return nil, typ.Fields[0].Mask.PRName.BeautifulError(fmt.Errorf("builtin wrapper %q field must not use field mask", tName))
			}
			if typ.Fields[0].FieldType.Type.String() != tName || len(typ.Fields[0].FieldType.Args) != 0 { // do not check Bare, because int === %int
				return nil, typ.Fields[0].FieldType.PR.BeautifulError(fmt.Errorf("builtin wrapper %q field type must match constructor name", tName))
			}
			if !builtinTypes[tName] {
				return nil, typ.Construct.NamePR.BeautifulError(fmt.Errorf("builtin wrapper %q must have constructor name equal to some builtin type", tName))
			}
		}
		gen.allConstructors[tName] = bt
		gen.singleConstructors[tName] = bt // will overwrite without checking, because they all are in allConstructors
	}

	// tupleDesc := btl[0]
	// vectorDesc := btl[1]
	// gen.singleConstructors[tupleDesc.Construct.Name.String()] = tupleDesc
	// gen.allConstructors[tupleDesc.Construct.Name.String()] = tupleDesc
	// gen.singleConstructors[vectorDesc.Construct.Name.String()] = vectorDesc
	// gen.allConstructors[vectorDesc.Construct.Name.String()] = vectorDesc
	if options.Verbose {
		log.Printf("type checking and templates instantiation...")
	}
	skippedDueToWhitelist := 0
	for _, typ := range tl {
		// TODO - after rpcInvokeReq is fixed, remove this
		if len(typ.TemplateArguments) == 1 && typ.TemplateArguments[0].IsNat && !typ.IsFunction && (typ.Construct.Name.String() == "rpcInvokeReqExtra" || typ.Construct.Name.String() == "rpcReqResultExtra") {
			fmt.Printf("Special treatment for %q, will be removed some day\n", typ.Construct.Name.String())
			t := tlast.TypeRef{Type: typ.TypeDecl.Name, PR: typ.TypeDecl.PR}
			argT := tlast.TypeRef{Type: tlast.Name{
				Namespace: "",
				Name:      "ArgumentN",
			}}
			t.Args = append(t.Args, tlast.ArithmeticOrType{
				IsArith: false,
				T:       argT,
			})
			lrc := LocalResolveContext{allowAnyConstructor: true, localNatArgs: map[string]LocalNatArg{}}
			lrc.localNatArgs["ArgumentN"] = LocalNatArg{
				natArg: ActualNatArg{isField: true, FieldIndex: 0},
			}
			_, _, _, err = gen.getType(lrc, t)
			if err != nil {
				return nil, err
			}
		}
		shouldGenerate := options.TypesWhileList == ""
		whiteListName := typ.Construct.Name
		if !typ.IsFunction {
			whiteListName = typ.TypeDecl.Name
		}
		for _, bv := range generateByteVersions {
			if inBytesVersionFilter(whiteListName, bv) {
				shouldGenerate = true
			}
		}
		for _, bv := range typesWhiteList {
			if inBytesVersionFilter(whiteListName, bv) {
				shouldGenerate = true
			}
		}
		if !shouldGenerate {
			skippedDueToWhitelist++
			continue
		}
		if len(typ.TemplateArguments) == 0 {
			t := tlast.TypeRef{Type: typ.Construct.Name, PR: typ.Construct.NamePR}
			if !typ.IsFunction {
				t = tlast.TypeRef{Type: typ.TypeDecl.Name, PR: typ.TypeDecl.PR}
			}
			_, _, _, err = gen.getType(LocalResolveContext{allowAnyConstructor: true}, t)
			if err != nil {
				return nil, err
			}
		}
	}
	bytesChildren := map[*TypeRWWrapper]bool{}
	typesCounterMarkBytes := 0
	// This loop can be before or after loops below, it is convenient to fill sortedTypes inside, so this loop is here
	for _, v := range gen.generatedTypesList {
		for _, bv := range generateByteVersions {
			if inBytesVersionFilter(v.tlName, bv) {
				v.MarkWantsBytesVersion(bytesChildren)
				typesCounterMarkBytes++
			}
		}
	}
	slices.SortStableFunc[*TypeRWWrapper](gen.generatedTypesList, func(a, b *TypeRWWrapper) bool { //  TODO - better idea?
		return TypeRWWrapperLessGlobal(a, b)
	})
	sortedTypes := gen.generatedTypesList
	// for _, st := range sortedTypes {
	//	fmt.Printf("sorted type %q\n", st.localTypeArg.rt.String())
	// }
	for _, v := range sortedTypes {
		// r # [r] = S;
		visitedNodes := map[*TypeRWWrapper]bool{}
		v.trw.fillRecursiveUnwrap(visitedNodes)
		v.preventUnwrap = visitedNodes[v]
		if v.preventUnwrap {
			fmt.Printf("prevented unwrap of %v\n", v.tlName)
		}
	}
	// in BeforeCodeGenerationStep we split recursion. Which links will be broken depends on order of nodes visited
	for _, v := range sortedTypes {
		if err := v.trw.BeforeCodeGenerationStep(); err != nil {
			return nil, err
		}
	}
	// in BeforeCodeGenerationStep2 we split recursion in unions.
	for _, v := range sortedTypes {
		v.trw.BeforeCodeGenerationStep2()
	}
	// Order of these 2 loops is important, for example see TypeRWTuple where bytes version depends on whether it is dict_like
	for _, v := range sortedTypes {
		visitedNodes := map[*TypeRWWrapper]bool{}
		v.hasBytesVersion = v.MarkHasBytesVersion(visitedNodes)
	}
	// detect recursion loops first
	if options.Verbose {
		if skippedDueToWhitelist != 0 {
			log.Printf("skipped %d object roots by the whitelist filter: %s", skippedDueToWhitelist, strings.Join(typesWhiteList, ", "))
		}
		log.Printf("found %d object roots for byte-optimized versions of types by the following filter: %s", typesCounterMarkBytes, strings.Join(generateByteVersions, ", "))
		log.Printf("generating serialization code...")
	}
	if gen.options.CopyrightFilePath != "" {
		buf, err := os.ReadFile(gen.options.CopyrightFilePath)
		if err != nil {
			return nil, fmt.Errorf("failed to open copyright text file: %w", err)
		}
		gen.copyrightText = string(buf)
	}
	if !options.IgnoreGeneratedCode {
		switch options.Language {
		case "go":
			if err := gen.generateCodeGolang(generateByteVersions); err != nil {
				return nil, err
			}
		case "cpp":
			if err := gen.generateCodeCPP(generateByteVersions); err != nil {
				return nil, err
			}
		default:
			log.Panicf("uknown language, though language was checked before")
		}
	}

	if options.SchemaDocumentation {
		if err := gen.addCodeFile(TlJSONHTML, tlJSON(gen, buildSHA256Checksum)); err != nil {
			return gen, err
		}
	}

	if err := gen.addCodeFile(markerFile, buildVersionString+strings.TrimSpace(buildSHA256Checksum)+"\n"); err != nil { // some stupid editors insist on empty line at the end
		return nil, err
	}
	return gen, nil
}

type InsFile struct {
	ins      *InternalNamespace
	fileName string
}

func (gen *Gen2) generateCodeGolang(generateByteVersions []string) error {
	sortedTypes := gen.generatedTypesList
	if !gen.options.SplitInternal {
		globalIns := &InternalNamespace{DebugID: 1, Name: "internal", SubPath: "internal", Namespaces: map[string]struct{}{}, DirectImports: &DirectImports{ns: map[*InternalNamespace]struct{}{}}}
		for _, v := range sortedTypes { // start with each type in its own internal namespace
			if _, ok := v.trw.(*TypeRWPrimitive); ok {
				continue // leave namespace nil
			}
			globalIns.Types = append(globalIns.Types, v)
			globalIns.Namespaces[v.tlName.Namespace] = struct{}{}
			v.ins = globalIns
		}
	} else {
		var internalNamespaces []*InternalNamespace
		printSortedNamespaces := func() {
			// fmt.Printf("----sortedTypes----\n")
			// for _, ins := range internalNamespaces {
			//	fmt.Printf("recursive import namespace %s", ins)
			// }
		}
		nextDebugID := 0
		for _, v := range sortedTypes { // start with each type in its own internal namespace
			if _, ok := v.trw.(*TypeRWPrimitive); ok {
				continue // leave namespace nil
			}
			nextDebugID++
			e := &InternalNamespace{DebugID: nextDebugID, Types: []*TypeRWWrapper{v}, Namespaces: map[string]struct{}{}, DirectImports: &DirectImports{ns: map[*InternalNamespace]struct{}{}}}
			e.Namespaces[v.tlName.Namespace] = struct{}{}
			v.ins = e
			internalNamespaces = append(internalNamespaces, e)
		}
		// we start with each type in its own internal namespace
		// we then generate code to assemble information on which is imported by which
		for _, v := range sortedTypes {
			if v.ins == nil {
				continue
			}
			_ = v.trw.GenerateCode(false, v.ins.DirectImports)
			if v.wantsBytesVersion && v.hasBytesVersion {
				_ = v.trw.GenerateCode(true, v.ins.DirectImports)
			}
		}
		printSortedNamespaces()
		// now := time.Now()
		recursiveImports := map[*InternalNamespace][]*InternalNamespace{}
		for i := 0; i < len(internalNamespaces); {
			from := internalNamespaces[i]
			from.FindRecursiveImports(recursiveImports, nil)
			if importMe, ok := recursiveImports[from]; ok && len(importMe) != 0 {
				into := importMe[0]
				// if options.Verbose {
				// log.Printf("----merging cycle namespace %sinto  %s (total %d)", from, into, len(internalNamespaces))
				// }
				into.mergeFrom(from, internalNamespaces)
				copy(internalNamespaces[i:], internalNamespaces[i+1:])
				internalNamespaces = internalNamespaces[:len(internalNamespaces)-1]
				// if options.Verbose {
				// log.Printf("result %s", into)
				// }
				continue
			}
			i++
		}
		for _, ins := range internalNamespaces {
			if len(ins.Types) == 1 {
				t := ins.Types[0]
				ins.Name = "tl" + t.TypeString(false)
				ins.SubPath = "internal/tl" + t.tlName.Namespace + "/" + ins.Name
				continue
			}
			sha := sha1.Sum([]byte(strings.Join(ins.sortedElements(), ":")))
			ins.Name = "cycle_" + hex.EncodeToString(sha[:16])
			ins.SubPath = "internal/" + ins.Name
		}
	}
	typesCounter := 0
	typesCounterBytes := 0

	internalFiles := map[InsFile][]*TypeRWWrapper{}
	for _, typeRw := range gen.generatedTypesList {
		if typeRw.ins == nil {
			continue
		}
		ff := InsFile{ins: typeRw.ins, fileName: typeRw.fileName}
		internalFiles[ff] = append(internalFiles[ff], typeRw)
	}
	var s strings.Builder
	for ff, types := range internalFiles {
		directImports := &DirectImports{ns: map[*InternalNamespace]struct{}{}}
		for _, typeRw := range types {
			_ = typeRw.trw.GenerateCode(false, directImports)
			if typeRw.wantsBytesVersion && typeRw.hasBytesVersion {
				_ = typeRw.trw.GenerateCode(true, directImports)
			}
		}
		s.WriteString(fmt.Sprintf(`%s
package %s 
import (
`,
			HeaderComment, ff.ins.Name))
		if directImports.importSort {
			s.WriteString("\"sort\"\n\n")
		}
		s.WriteString(fmt.Sprintf("\"%s\"\n", gen.BasicPackageNameFull))
		if gen.options.SplitInternal {
			s.WriteString(fmt.Sprintf("    \"%s/%s\"\n", gen.options.TLPackageNameFull, "internal"))
		}
		var sortedNames []string
		for im := range directImports.ns { // Imports of this file.
			if im != ff.ins {
				sortedNames = append(sortedNames, im.SubPath)
			}
		}
		slices.Sort(sortedNames)
		for _, n := range sortedNames {
			s.WriteString(fmt.Sprintf("    \"%s/%s\"\n", gen.options.TLPackageNameFull, n))
		}
		s.WriteString(`)

var _ = basictl.NatWrite
`)
		if gen.options.SplitInternal {
			s.WriteString("var _ = internal.ErrorInvalidEnumTag\n")
		}
		for _, typeRw := range types {
			typesCounter++
			s.WriteString("\n")
			s.WriteString(typeRw.trw.GenerateCode(false, directImports))
			if typeRw.wantsBytesVersion && typeRw.hasBytesVersion {
				typesCounterBytes++
				s.WriteString("\n")
				s.WriteString(typeRw.trw.GenerateCode(true, directImports))
			}
		}
		filepathName := filepath.Join(ff.ins.SubPath, ff.fileName+goExt)
		if err := gen.addCodeFile(filepathName, gen.copyrightText+s.String()); err != nil {
			return err
		}
		s.Reset()
	}
	if gen.options.Verbose {
		log.Printf("generation of serialization code finished, %d constructors processed, %d types generated", len(gen.allConstructors), typesCounter)
		if len(generateByteVersions) != 0 {
			log.Printf("    also generated byte-optimized versions of %d types by the following filter: %s", typesCounterBytes, strings.Join(generateByteVersions, ", "))
		}
	}
	if gen.options.Verbose {
		log.Printf("generating RPC code...")
	}
	for name, namespace := range gen.Namespaces {
		slices.SortFunc[*TypeRWWrapper](namespace.types, func(a, b *TypeRWWrapper) bool {
			return TypeRWWrapperLessLocal(a, b)
		})
		anyTypeAlias := false
		anyEnumElementAlias := false
		anyFunction := false
		for _, wr := range namespace.types {
			if wr.ShouldWriteTypeAlias() {
				anyTypeAlias = true
			}
			if wr.ShouldWriteEnumElementAlias() {
				anyEnumElementAlias = true
			}
			if fun, ok := wr.trw.(*TypeRWStruct); ok && fun.ResultType != nil {
				anyFunction = true
			}
		}
		if !anyTypeAlias && !anyEnumElementAlias && !anyFunction {
			continue
		}
		directImports := &DirectImports{ns: map[*InternalNamespace]struct{}{}}
		var sortedNames []string
		_ = gen.generateNamespacesCode(anyTypeAlias, anyFunction, name, namespace, sortedNames, directImports)
		for im := range directImports.ns { // Imports of this file.
			sortedNames = append(sortedNames, im.SubPath)
		}
		slices.Sort(sortedNames)
		filepathName := filepath.Join(gen.GlobalPackageName+name, gen.GlobalPackageName+name+goExt)
		code := gen.generateNamespacesCode(anyTypeAlias, anyFunction, name, namespace, sortedNames, directImports)
		if code == "" {
			continue
		}
		if err := gen.addCodeFile(filepathName, gen.copyrightText+code); err != nil {
			return err
		}
	}
	if gen.options.Verbose {
		log.Printf("generation of RPC code finished, %d namespaces generated", len(gen.Namespaces))
	}
	{
		filepathName := filepath.Join(ConstantsPackageName, ConstantsPackageName+goExt) // TODO if contains GlobalPackgeName as prefix, there could be name collisions
		code := gen.generateConstants(HeaderComment, ConstantsPackageName)
		if err := gen.addCodeFile(filepathName, gen.copyrightText+code); err != nil {
			return err
		}
		if gen.options.BasicPackageNameFull == "" {
			filepathName = filepath.Join(BasicTLGoPackageName, BasicTLGoPackageName+goExt) // TODO if contains GlobalPackgeName as prefix, there could be name collisions
			code = fmt.Sprintf(basicTLCodeHeader, HeaderComment, BasicTLGoPackageName) + basicTLCodeBody
			if err := gen.addCodeFile(filepathName, gen.copyrightText+code); err != nil {
				return err
			}
		} else if gen.options.Verbose {
			log.Printf("basictl code not written, expected to be available at %q", gen.options.BasicPackageNameFull)
		}
		directImports := &DirectImports{ns: map[*InternalNamespace]struct{}{}}
		var sortedNames []string
		_ = gen.generateFactory(sortedNames, directImports)
		for im := range directImports.ns { // Imports of this file.
			sortedNames = append(sortedNames, im.SubPath)
		}
		slices.Sort(sortedNames)
		if err := gen.addCodeFile(filepath.Join(FactoryGoPackageName, FactoryGoPackageName+goExt), gen.copyrightText+gen.generateFactory(sortedNames, directImports)); err != nil {
			return err
		}
		if err := gen.addCodeFile(filepath.Join(MetaGoPackageName, MetaGoPackageName+goExt), gen.copyrightText+gen.generateMeta()); err != nil {
			return err
		}
		filepathName = filepath.Join("internal", "a_tlgen_helpers_code.go") // TODO decollision
		code = fmt.Sprintf(internalTLCodeHeader, HeaderComment, "internal") + internalTLCodeBody
		if err := gen.addCodeFile(filepathName, gen.copyrightText+code); err != nil {
			return err
		}
	}
	if gen.options.Verbose {
		log.Printf("formating generated code...")
	}
	for filepathName, code := range gen.Code {
		if !strings.HasSuffix(filepathName, goExt) {
			continue
		}
		formattedCode, err := format.Source([]byte(code))
		if err != nil {
			// We generate code still, because it will be easy to debug when the wrong file is written out
			fmt.Printf("generator %sinternal error%s: source file %q will not compile due to error: %v", color.Red, color.Reset, filepathName, err)
			continue
		}
		gen.Code[filepathName] = string(formattedCode)
	}
	return nil
}

func cppStartNamespace(s *strings.Builder, ns []string) {
	for _, n := range ns {
		s.WriteString(fmt.Sprintf("namespace %s { ", n))
	}
	s.WriteString("\n")
}

func cppFinishNamespace(s *strings.Builder, ns []string) {
	s.WriteString(fmt.Sprintf("\n%s // namespace %s\n\n", strings.Repeat("}", len(ns)), strings.Join(ns, "::")))
}

func (gen *Gen2) generateCodeCPP(generateByteVersions []string) error {
	const basicTLFilepathName = "a_tlgen_helpers_code" + hppExt // TODO decollision

	cppAllInc := &DirectIncludesCPP{ns: map[string]struct{}{}}
	var hpp strings.Builder
	var hppDet strings.Builder
	var cppDet strings.Builder
	typesCounter := 0
	typesCounterBytes := 0
	internalFiles := map[InsFile][]*TypeRWWrapper{}
	for _, typeRw := range gen.generatedTypesList {
		ff := InsFile{ins: typeRw.ins, fileName: typeRw.fileName}
		internalFiles[ff] = append(internalFiles[ff], typeRw)
	}
	for ff, types := range internalFiles {
		hppInc := &DirectIncludesCPP{ns: map[string]struct{}{}}
		hppIncFwd := &DirectIncludesCPP{ns: map[string]struct{}{}}
		hppDetInc := &DirectIncludesCPP{ns: map[string]struct{}{}}
		cppDetInc := &DirectIncludesCPP{ns: map[string]struct{}{}}
		multipleDefinitions := map[string]struct{}{}
		for _, typeRw := range types {
			// log.Printf("type: %s\n", typeRw.tlName.String())
			// log.Printf("      %s\n", typeRw.resolvedType.String())
			typesCounter++
			var hppDefinition strings.Builder
			typeRw.trw.CPPGenerateCode(&hppDefinition, hppInc, hppIncFwd, &hppDet, hppDetInc, &cppDet, cppDetInc, false, false)
			def := hppDefinition.String()
			if _, ok := multipleDefinitions[def]; !ok {
				multipleDefinitions[def] = struct{}{}
				hpp.WriteString(def)
			}
			if typeRw.wantsBytesVersion && typeRw.trw.CPPHasBytesVersion() {
				hppDefinition.Reset()
				typesCounterBytes++
				typeRw.trw.CPPGenerateCode(&hppDefinition, hppInc, hppIncFwd, &hppDet, hppDetInc, &cppDet, cppDetInc, true, false)
				def = hppDefinition.String()
				if _, ok := multipleDefinitions[def]; !ok {
					multipleDefinitions[def] = struct{}{}
					hpp.WriteString(def)
				}
			}
		}
		if hpp.Len() == 0 && hppDet.Len() == 0 && cppDet.Len() == 0 {
			continue
		}
		cppAllInc.ns[ff.fileName] = struct{}{}
		hppStr := hpp.String()
		hppDetStr := hppDet.String()
		cppDetStr := cppDet.String()
		hpp.Reset()
		hppDet.Reset()
		cppDet.Reset()
		hpp.WriteString("#pragma once\n\n")
		hppDet.WriteString("#pragma once\n\n")
		hpp.WriteString(fmt.Sprintf("#include \"%s\"\n", basicTLFilepathName))
		for _, n := range hppInc.sortedNames() {
			hpp.WriteString(fmt.Sprintf("#include \"%s%s\"\n", n, hppExt))
		}
		hpp.WriteString("\n\n")
		hppDet.WriteString(fmt.Sprintf("#include \"../%s%s\"\n", ff.fileName, hppExt))
		hppDet.WriteString(fmt.Sprintf("#include \"../%s\"\n", basicTLFilepathName))
		hpp.WriteString(hppStr)
		// for _, n := range hppIncFwd.sortedNames() {
		//	hpp.WriteString(fmt.Sprintf("#include \"%s%s\"\n", n, hppExt))
		// }
		for _, n := range hppDetInc.sortedNames() {
			hppDet.WriteString(fmt.Sprintf("#include \"../%s%s\"\n", n, hppExt))
		}
		cppDet.WriteString(fmt.Sprintf("#include \"%s_details%s\"\n", ff.fileName, hppExt))
		for _, n := range cppDetInc.sortedNames() {
			cppDet.WriteString(fmt.Sprintf("#include \"%s_details%s\"\n", n, hppExt))
		}
		filepathName := ff.fileName + hppExt
		if err := gen.addCodeFile(filepathName, gen.copyrightText+hpp.String()); err != nil {
			return err
		}
		hpp.Reset()
		filepathName = filepath.Join("details", ff.fileName+"_details"+hppExt)
		if err := gen.addCodeFile(filepathName, gen.copyrightText+hppDet.String()+hppDetStr); err != nil {
			return err
		}
		hppDet.Reset()
		filepathName = filepath.Join("details", ff.fileName+"_details"+cppExt)
		if err := gen.addCodeFile(filepathName, gen.copyrightText+cppDet.String()+cppDetStr); err != nil {
			return err
		}
		cppDet.Reset()
	}
	var cppAll strings.Builder
	var cppMake strings.Builder
	var cppMakeO strings.Builder
	var cppMake1 strings.Builder
	for _, n := range cppAllInc.sortedNames() {
		cppAll.WriteString(fmt.Sprintf("#include \"details/%s%s\"\n", n+"_details", cppExt))
		cppMake1.WriteString(fmt.Sprintf("%s.o: details/%s%s details/%s%s\n", n+"_details", n+"_details", cppExt, n+"_details", hppExt))
		cppMake1.WriteString(fmt.Sprintf("\t$(CC) $(CFLAGS) -c details/%s%s\n", n+"_details", cppExt))
		cppMakeO.WriteString(fmt.Sprintf("%s.o ", n+"_details"))
	}
	cppMake.WriteString(`
CC = g++
CFLAGS = -std=c++17 -O3 -Wno-noexcept-type -g -Wall -Wextra -Werror=return-type -Wno-unused-parameter
`)
	cppMake.WriteString(fmt.Sprintf("all: main.o %s\n", cppMakeO.String()))
	cppMake.WriteString(fmt.Sprintf("\t$(CC) $(CFLAGS) -o all main.o %s\n", cppMakeO.String()))
	cppMake.WriteString(`
main.o: main.cpp
	$(CC) $(CFLAGS) -c main.cpp
`)
	cppMake.WriteString(cppMake1.String())
	if err := gen.addCodeFile("all.cpp", cppAll.String()); err != nil {
		return err
	}
	if err := gen.addCodeFile("main.cpp", "int main() { return 0; }"); err != nil {
		return err
	}
	if err := gen.addCodeFile("Makefile", cppMake.String()); err != nil {
		return err
	}
	// if gen.options.Verbose {
	//	log.Printf("generation of serialization code finished, %d constructors processed, %d types generated", len(gen.allConstructors), typesCounter)
	//	if len(generateByteVersions) != 0 {
	//		log.Printf("    also generated byte-optimized versions of %d types by the following filter: %s", typesCounterBytes, strings.Join(generateByteVersions, ", "))
	//	}
	// }
	// if gen.options.Verbose {
	//	log.Printf("generating RPC code...")
	// }
	// if gen.options.GenerateRPCCode {
	//	for name, namespace := range gen.Namespaces {
	//		filepathName := filepath.Join(gen.GlobalPackageName+name, gen.GlobalPackageName+name+".go")
	//		// TODO - if no functions and no aliases, do not write namespace file at all
	//		code := gen.GenerateNamespacesCode(name, namespace)
	//		if _, ok := gen.Code[filepathName]; ok {
	//			return fmt.Errorf("generator %sinternal error%s: source file %q is generated twice", tlast.ColorRed, tlast.ColorReset, filepathName)
	//		}
	//		gen.Code[filepathName] = code
	//	}
	// }
	// if gen.options.Verbose {
	//	log.Printf("generation of RPC code finished, %d namespaces generated", len(gen.Namespaces))
	// }
	{
		//	filepathName := filepath.Join(BasicTLGoPackageName, BasicTLGoPackageName+".go") // TODO if contains GlobalPackgeName as prefix, there could be name collisions
		//	gen.Code[filepathName] = fmt.Sprintf(basicTLCodeHeader, HeaderComment, BasicTLGoPackageName) + basicTLCodeBody
		//	filepathName = "factory.go"
		//	gen.Code[filepathName] = gen.GenerateFactory()
		code := fmt.Sprintf(basicCPPTLCodeHeader, HeaderComment, BasicTLCPPNamespaceName) + basicCPPTLCodeBody +
			fmt.Sprintf(basicCPPTLCodeFooter, BasicTLCPPNamespaceName)
		if err := gen.addCodeFile(basicTLFilepathName, code); err != nil {
			return err
		}
	}
	// if gen.options.Verbose {
	//	log.Printf("formating generated code...")
	// }
	// for filepathName, code := range gen.Code {
	//	formattedCode, err := format.Source([]byte(code))
	//	if err != nil {
	//		// We generate code still, because it will be easy to debug when the wrong file is written out
	//		fmt.Printf("generator %sinternal error%s: source file %q will not compile due to error: %v", tlast.ColorRed, tlast.ColorReset, filepathName, err)
	//		continue
	//	}
	//	gen.Code[filepathName] = string(formattedCode)
	// }
	return nil
}
