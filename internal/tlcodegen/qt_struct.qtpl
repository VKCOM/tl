{% package tlcodegen %}

{% import "fmt" %}

{%- func (struct_ *TypeRWStruct)GenerateCode(bytesVersion bool, directImports *DirectImports) -%}
    {%- code
        goName := addBytes(struct_.wr.goGlobalName, bytesVersion)
        tlTag := fmt.Sprintf("0x%08x", struct_.wr.tlTag)
        natArgsDecl := formatNatArgsDecl(struct_.wr.NatParams)
        natArgsCall := formatNatArgsDeclCall(struct_.wr.NatParams)
        writeNeedsError := struct_.wr.hasErrorInWriteMethods
    -%}
    {%- if struct_.wr.unionParent != nil -%}
    {%- code
        ep := struct_.wr.unionParent.wr.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false)
    -%}
    {%- if struct_.wr.unionParent.IsEnum -%}
func {%s= goName %}() {%s= ep %} { return {%s= ep %}__MakeEnum({%d struct_.wr.unionIndex %}) }
    {%- return -%}
    {%- else -%}
func (item {%s= goName %}) AsUnion() {%s= ep %} {
    var ret {%s= ep %}
    ret.Set{%s= struct_.wr.unionParent.Fields[struct_.wr.unionIndex].goName %}({%s= ifString(struct_.wr.IsTrueType(), "", "item") %})
    return ret
}

    {%- endif -%}
    {%- endif -%}
{%= struct_.typeDefinition(bytesVersion, directImports) %}
    {%- if struct_.wr.tlTag != 0 -%}
        {%- code // anonymous square brackets citizens or other exotic type -%}
func ({%s= goName %}) TLName() string { return {%q= struct_.wr.tlName.String() %} }
func ({%s= goName %}) TLTag() uint32  { return {%s= tlTag %} }

    {%- endif -%}
    {%= struct_.fieldMaskGettersAndSetters(bytesVersion, directImports) %}
func (item *{%s= goName %}) Reset() { {%= struct_.resetFields(bytesVersion, directImports) %} }

        {%- if struct_.wr.gen.options.GenerateRandomCode -%}
func (item *{%s= goName %}) FillRandom(rg *basictl.RandGenerator{%s= natArgsDecl %}) { {%= struct_.randomFields(bytesVersion, directImports) %} }
        {%- endif -%}

func (item *{%s= goName %}) Read(w []byte{%s= natArgsDecl %}) (_ []byte, err error) { {%= struct_.readFields(bytesVersion, directImports) %} }

// This method is general version of Write, use it instead!
func (item *{%s= goName %}) WriteGeneral(w []byte{%s= natArgsDecl %}) (_ []byte, err error) {
    {%- if writeNeedsError -%}
    return item.Write(w{%s= natArgsCall %})
    {%- else -%}
    return item.Write(w{%s= natArgsCall %}), nil
    {%- endif -%}
}

func (item *{%s= goName %}) Write(w []byte{%s= natArgsDecl %}) {%s= wrapWithError(writeNeedsError, "[]byte") %} { {%= struct_.writeFields(bytesVersion, directImports) %} }

    {%- if struct_.wr.tlTag != 0 -%}
func (item *{%s= goName %}) ReadBoxed(w []byte{%s= natArgsDecl %}) (_ []byte, err error) {
    if w, err = basictl.NatReadExactTag(w, {%s= tlTag %}); err != nil {
        return w, err
    }
    return item.Read(w{%s= natArgsCall %})
}

// This method is general version of WriteBoxed, use it instead!
func (item *{%s= goName %}) WriteBoxedGeneral(w []byte{%s= natArgsDecl %}) (_ []byte, err error) {
    {%- if writeNeedsError -%}
    return item.WriteBoxed(w{%s= natArgsCall %})
    {%- else -%}
    return item.WriteBoxed(w{%s= natArgsCall %}), nil
    {%- endif -%}
}

func (item *{%s= goName %}) WriteBoxed(w []byte{%s= natArgsDecl %}) {%s= wrapWithError(writeNeedsError, "[]byte") %} {
    w = basictl.NatWrite(w, {%s= tlTag %})
    return item.Write(w{%s= natArgsCall %})
}

    {%- endif -%}
{%= struct_.functionCode(bytesVersion, directImports) %}
    {%- if len(struct_.wr.NatParams) == 0 -%}

func (item {%s= goName %}) String({%s= formatNatArgsDeclNoComma(struct_.wr.NatParams) %}) string {
    {%- if writeNeedsError -%}
    w, err := item.WriteJSON(nil{%s= natArgsCall %})
    if err != nil {
        return err.Error()
    }
    return string(w)
    {%- else -%}
    return string(item.WriteJSON(nil{%s= natArgsCall %}))
    {%- endif -%}
}
    {%- endif -%}
{%= struct_.generateJSONCode(bytesVersion, directImports) %}
{%- endfunc -%}

{%- func (struct_ *TypeRWStruct)typeDefinition(bytesVersion bool, directImports *DirectImports) -%}
    {%- code goName := addBytes(struct_.wr.goGlobalName, bytesVersion) -%}
    {%- if struct_.isTypeDef() -%}
        {%- code
            asterisk := ifString(struct_.Fields[0].recursive, "*", "") // actually never recursive due to condition in struct_.isTypeDef()
            fieldTypeString :=  struct_.Fields[0].t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false)
        -%}
type {%s= goName %} {%s= asterisk %}{%s= fieldTypeString %}
        {%- return -%}
    {%- endif -%}
type {%s= goName %} struct {
    {%- for _, field := range struct_.Fields -%}
        {%- code
            asterisk := ifString(field.recursive, "*", "")
            fieldTypeString := ""
            fieldsMaskComment := ""
            if field.fieldMask != nil {
                fieldsMaskComment = fmt.Sprintf(" // Conditional: %s.%d", formatNatArg(struct_.Fields, *field.fieldMask), field.BitNumber)
            }
            prefixComment := ""
            if field.t.IsTrueType() {
                prefixComment = "// "
                fieldTypeString = "(TrueType)"
            } else {
                fieldTypeString = field.t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false)
            }
        -%}
    {%s= prefixComment %}{%s= field.goName %} {%s= asterisk %}{%s= fieldTypeString %}{%s= fieldsMaskComment %}
    {%- endfor -%}
}
{%- endfunc -%}

{%- func (struct_ *TypeRWStruct)fieldMaskGettersAndSetters(bytesVersion bool, directImports *DirectImports) -%}
    {%- code goName := addBytes(struct_.wr.goGlobalName, bytesVersion) -%}
    {%- for i, field := range struct_.Fields -%}
        {%- if field.fieldMask == nil -%} {%- continue -%} {%- endif -%}
        {%- code
            fieldTypeString := ""
            isTrueType := "bool"
            maskFunArg := !field.fieldMask.isField && !field.fieldMask.isArith
            natArgUse := formatNatArg(struct_.Fields, *field.fieldMask)
            asterisk := addAsterisk(field.recursive, "")
        -%}
        {%- if !field.t.IsTrueType() -%}
        {%- code
            fieldTypeString = field.t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false)
            isTrueType = fieldTypeString
        -%}
        {%- endif -%}
        {%- if !field.fieldMask.isArith -%}
            {%- code
                // Example
                //     notify.notification#461f4ce2 {mode:#} removed:mode.0?Bool = notify.Notification mode;
                //     @any notify.getScheduledNotifications#f53ad7bd  = notify.Notification 0;
                // We skip generating Set and Clear altogether in this case, but still generate IsSet
                setName := struct_.setNames[i]
                if setName == "" {
                    setName = struct_.fieldsDec.deconflictName("Set" + field.goName)
                    struct_.setNames[i] = setName
                }
            -%}
            {%- if maskFunArg -%}

func (item *{%s= goName %}) {%s= setName %}(v {%s= isTrueType %}, {%s= natArgUse %} *uint32) {
            {%- else -%}
func (item *{%s= goName %}) {%s= setName %}(v {%s= isTrueType %}) {
            {%- endif -%}
            {%- if !field.t.IsTrueType() -%}
                {%- if field.recursive -%}
    if item.{%s= field.goName %} == nil {
        var value {%s= fieldTypeString %}
        item.{%s= field.goName %} = &value
    }
                {%- endif -%}
    {%s= asterisk %}item.{%s= field.goName %} = v
            {%- endif -%}
            {%- if maskFunArg -%}
    if {%s= natArgUse %} != nil {
            {%- endif -%}
            {%- if field.t.IsTrueType() -%}
        if v {
            {%s= addAsterisk(maskFunArg, natArgUse)  %} |= 1 << {%v field.BitNumber %}
        } else {
            {%s= addAsterisk(maskFunArg, natArgUse)  %} &^= 1 << {%v field.BitNumber %}
        }
            {%- else -%}
        {%s= addAsterisk(maskFunArg, natArgUse) %} |= 1 << {%v field.BitNumber %}
            {%- endif -%}
            {%- if maskFunArg -%}
    }
            {%- endif -%}
}
            {%- if !field.t.IsTrueType() -%}
                {%- code clearName := struct_.clearNames[i]
                if clearName == "" {
                        clearName = struct_.fieldsDec.deconflictName("Clear" + field.goName)
                        struct_.clearNames[i] = clearName
                    }
                -%}
                {%- if maskFunArg -%}
func (item *{%s= goName %}) {%s= clearName %}({%s= natArgUse %} *uint32) {
                {%- else -%}
func (item *{%s= goName %}) {%s= clearName %}() {
                {%- endif -%}
                {%- if field.recursive -%}
    if item.{%s= field.goName %} != nil { {%s= field.t.TypeResettingCode(bytesVersion, directImports, struct_.wr.ins, fmt.Sprintf("item.%s", field.goName), field.recursive) %} }
                {%- else -%}
    {%s= field.t.TypeResettingCode(bytesVersion, directImports, struct_.wr.ins, fmt.Sprintf("item.%s", field.goName), field.recursive) %}
                {%- endif -%}
                {%- if maskFunArg-%}
    if {%s= natArgUse %} != nil {
                {%- endif -%}
    {%s= addAsterisk(maskFunArg, natArgUse) %} &^= 1 << {%v field.BitNumber %}
                {%- if maskFunArg-%}
    }
                {%- endif -%}
}
            {%- endif -%}
        {%- endif -%}
        {%- code
            isSetName := struct_.isSetNames[i]
            if isSetName == "" {
                isSetName = struct_.fieldsDec.deconflictName("IsSet" + field.goName)
                struct_.isSetNames[i] = isSetName
            }
        -%}
        {%- if maskFunArg -%}
func (item {%s= goName %}) {%s= isSetName %}({%s= natArgUse %} uint32) bool { return {%s= natArgUse %} & (1 << {%v field.BitNumber %}) != 0 }
        {%- else -%}
func (item {%s= goName %}) {%s= isSetName %}() bool { return {%s= natArgUse %} & (1 << {%v field.BitNumber %}) != 0 }
        {%- endif -%}


    {%- endfor -%}
{%- endfunc -%}

{%- func (struct_ *TypeRWStruct)generateJSONCode(bytesVersion bool, directImports *DirectImports) -%}
    {%- code
        goName := addBytes(struct_.wr.goGlobalName, bytesVersion)
        natArgsDecl := formatNatArgsDecl(struct_.wr.NatParams)
        natArgsCall := formatNatArgsDeclCall(struct_.wr.NatParams)
        writeNeedsError := struct_.wr.hasErrorInWriteMethods
    -%}
    {%- if struct_.isTypeDef() -%}
        {%- code
            field := struct_.Fields[0]
            fieldTypeString := field.t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false)
        -%}

        {%- if struct_.wr.gen.options.GenerateLegacyJsonRead -%}
func (item *{%s= goName %}) ReadJSONLegacy(legacyTypeNames bool, j interface{}{%s= natArgsDecl %}) error {
    ptr := (*{%s= fieldTypeString %})(item)
    {%s= field.t.TypeJSONReadingCode(bytesVersion, directImports, struct_.wr.ins, "j", "ptr", formatNatArgs(struct_.Fields, field.natArgs), true) %}
    return nil
}

        {%- endif -%}
func (item *{%s= goName %}) ReadJSON(legacyTypeNames bool, in *basictl.JsonLexer{%s= natArgsDecl %}) error {
    ptr := (*{%s= fieldTypeString %})(item)
    {%s= field.t.TypeJSON2ReadingCode(bytesVersion, directImports, struct_.wr.ins, "in", "ptr", formatNatArgs(struct_.Fields, field.natArgs), true) %}
    return nil
}

// This method is general version of WriteJSON, use it instead!
func (item *{%s= goName %}) WriteJSONGeneral(w []byte{%s= natArgsDecl %}) (_ []byte, err error) {
    {%- if writeNeedsError -%}
    return item.WriteJSON(w{%s= natArgsCall %})
    {%- else -%}
    return item.WriteJSON(w{%s= natArgsCall %}), nil
    {%- endif -%}
}

func (item *{%s= goName %}) WriteJSON(w []byte{%s= natArgsDecl %}) {%s= wrapWithError(writeNeedsError, "[]byte") %} {
    return item.WriteJSONOpt(true, false, w{%s= natArgsCall %})
}

func (item *{%s= goName %}) WriteJSONOpt(newTypeNames bool, short bool, w []byte{%s= natArgsDecl %}) {%s= wrapWithError(writeNeedsError, "[]byte") %} {
    ptr := (*{%s= fieldTypeString %})(item)
    {%s= field.t.TypeJSONWritingCode(bytesVersion, directImports, struct_.wr.ins, "ptr", formatNatArgs(struct_.Fields, field.natArgs), true, writeNeedsError) %}
    {%- if writeNeedsError -%}
    return w, nil
    {%- else -%}
    return w
    {%- endif -%}
}
    {%- else -%}
        {%- code
// Sorting fields is bad idea. Most efficient parsing is if they are in TL order, because no look ahead required
        -%}

{%= struct_.readJSONCode(bytesVersion, directImports) %}
{%= struct_.writeJSONCode(bytesVersion, directImports) %}
    {%- endif -%}
    {%- if len(struct_.wr.NatParams) == 0 -%}
func (item *{%s= goName %}) MarshalJSON() ([]byte, error) {
        {%- if writeNeedsError -%}
      return item.WriteJSON(nil)
        {%- else -%}
      return item.WriteJSON(nil), nil
        {%- endif -%}
}

func (item *{%s= goName %}) UnmarshalJSON(b []byte) error {
    if err := item.ReadJSON(true, &basictl.JsonLexer{Data: b}); err != nil {
        return {%s= struct_.wr.gen.InternalPrefix()%}ErrorInvalidJSON({%q= struct_.wr.tlName.String() %}, err.Error())
    }
    return nil
}
    {%- endif -%}

{%- endfunc -%}

{%- func (struct_ *TypeRWStruct)readJSONCode(bytesVersion bool, directImports *DirectImports) -%}
    {%- code
        goName := addBytes(struct_.wr.goGlobalName, bytesVersion)
        natArgsDecl := formatNatArgsDecl(struct_.wr.NatParams)
    -%}
{%- if struct_.wr.gen.options.GenerateLegacyJsonRead -%}

func (item *{%s= goName %}) ReadJSONLegacy(legacyTypeNames bool, j interface{}{%s= natArgsDecl %}) error {
    _jm, _ok := j.(map[string]interface{})
    if j != nil && !_ok {
        return {%s= struct_.wr.gen.InternalPrefix()%}ErrorInvalidJSON({%q= struct_.wr.tlName.String() %}, "expected json object")
    }
    {%- code
// first we read everything that could be field mask (primitives)
// then we set explicit/check implicit field masks depending on which keys json object has
// then we read the rest, passing the same field masks to every field reader
    -%}
    {%- for _, field := range struct_.Fields -%}
        {%- code // field names will be mandatory soon, except for typedefs which are processed separately
        -%}
        {%- if field.originalName == "" -%} {%- continue -%} {%- endif -%}
        {%- code
            jsonField := fmt.Sprintf("_j%s", field.goName)
            itemField := fmt.Sprintf("item.%s", field.goName)
        -%}
    {%s= jsonField %} := _jm[{%q= field.originalName %}]
    delete(_jm,{%q= field.originalName %})
        {%- if field.fieldMask != nil -%} {%- continue %} {%- endif -%}
        {%- if _, isScalar := field.t.trw.(*TypeRWPrimitive); !isScalar -%}
            {%- continue %}
        {%- endif -%}
    {%s= field.t.TypeJSONReadingCode(bytesVersion, directImports, struct_.wr.ins, jsonField, itemField, formatNatArgs(struct_.Fields, field.natArgs), field.recursive) %}
    {%- endfor -%}
    for k := range _jm {
        return {%s= struct_.wr.gen.InternalPrefix()%}ErrorInvalidJSONExcessElement({%q= struct_.wr.tlName.String() %}, k)
    }
    {%- for _, field := range struct_.Fields -%}
        {%- code // field names will be mandatory soon, except for typedefs which are processed separately
        -%}
        {%- if field.originalName == "" -%} {%- continue -%} {%- endif -%}
        {%- if field.fieldMask == nil -%} {%- continue -%} {%- endif -%}
        {%- code
             // If field depends on implicit field mask and set in json, but field mask bit not set, this is error
             // Otherwise field will be silently ignored, to caller surprise
             //
             // If field depends on explicit field mask and set in json, we set the bit
             // Setting field is convenient to set field mask bits. Also works for true-types
             //
             // We must first set all bits, only then read fields, so that all fields depend on te same set of bits

            jsonField := fmt.Sprintf("_j%s", field.goName)
        -%}
        {%- if field.t.IsTrueType() -%}
            {%- if !field.fieldMask.isField -%}
    if {%s= jsonField %} != nil {
        return {%s= struct_.wr.gen.InternalPrefix()%}ErrorInvalidJSON({%q= struct_.wr.tlName.String() %}, "implicit true field '{%s= field.originalName %}' cannot be defined, set fieldmask instead")
    }
            {%- else -%}
    if {%s= jsonField %} != nil {
        _bit := false
        if err := {%s= struct_.wr.gen.InternalPrefix()%}JsonReadBool({%s= jsonField %}, &_bit); err != nil {
            return err
        }
        if _bit {
            {%s= formatNatArg(struct_.Fields, *field.fieldMask) %} |= 1 << {%v field.BitNumber %}
        } else {
            {%s= formatNatArg(struct_.Fields, *field.fieldMask) %} &^= 1 << {%v field.BitNumber %}
        }
    }
            {%- endif -%}
        {%- else -%}
            {%- if !field.fieldMask.isField -%}
    if {%s= formatNatArg(struct_.Fields, *field.fieldMask) %} & (1 << {%v field.BitNumber %}) == 0 && {%s= jsonField %} != nil {
        return {%s= struct_.wr.gen.InternalPrefix()%}ErrorInvalidJSON({%q= struct_.wr.tlName.String() %}, "field '{%s= field.originalName %}' is defined, while corresponding implicit fieldmask bit is 0")
    }
            {%- else -%}
    if {%s= jsonField %} != nil {
        {%s= formatNatArg(struct_.Fields, *field.fieldMask) %} |= 1 << {%v field.BitNumber %}
    }
            {%- endif -%}
        {%- endif -%}
    {%- endfor -%}
    {%- for _, field := range struct_.Fields -%}
        {%- code // field names will be mandatory soon, except for typedefs which are processed separately
        -%}
        {%- if field.originalName == "" -%} {%- continue -%} {%- endif -%}
        {%- code
            jsonField := fmt.Sprintf("_j%s", field.goName)
            itemField := fmt.Sprintf("item.%s", field.goName)
        -%}
        {%- if field.t.IsTrueType() -%}
            {%- if field.fieldMask == nil -%}
                {%- code
                    tmpName := fmt.Sprintf("_%s", field.goName)
                    readingCode := field.t.TypeJSONReadingCode(bytesVersion, directImports, struct_.wr.ins, jsonField, tmpName, formatNatArgs(struct_.Fields, field.natArgs), field.recursive)
                -%}
        {%- code fieldTypeString := field.t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false) -%}
    var {%s= tmpName %} {%s= fieldTypeString %}
    {%s= readingCode %}
            {%- endif -%}
            {%- continue -%}
        {%- endif -%}
        {%- code
            readingCode := field.t.TypeJSONReadingCode(bytesVersion, directImports, struct_.wr.ins, jsonField, itemField, formatNatArgs(struct_.Fields, field.natArgs), field.recursive)
            // TODO - for recursive field, add initialization
            resettingCode := field.t.TypeResettingCode(bytesVersion, directImports, struct_.wr.ins, itemField, field.recursive)
        -%}
        {%- if field.fieldMask != nil -%}
            {%- if !field.fieldMask.isField -%}
    if {%s= formatNatArg(struct_.Fields, *field.fieldMask) %} & (1 << {%v field.BitNumber %}) != 0 {
        {%- if field.recursive -%}
            {%- code fieldTypeString := field.t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false) -%}
        if item.{%s= field.goName %} == nil {
            var value {%s= fieldTypeString %}
            item.{%s= field.goName %} = &value
        }
        {%- endif -%}
        {%s= readingCode %}
    } else {
        {%- if field.recursive -%}
        if item.{%s= field.goName %} != nil {
            {%s= resettingCode %}
        }
        {%- else -%}
        {%s= resettingCode %}
        {%- endif -%}
    }
            {%- else -%}
    if {%s= jsonField %} != nil {
        {%- if field.recursive -%}
        {%- code fieldTypeString := field.t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false) -%}
        if item.{%s= field.goName %} == nil {
            var value {%s= fieldTypeString %}
            item.{%s= field.goName %} = &value
        }
        {%- endif -%}
        {%s= readingCode %}
    } else {
        {%- if field.recursive -%}
        if item.{%s= field.goName %} != nil {
            {%s= resettingCode %}
        }
        {%- else -%}
        {%s= resettingCode %}
        {%- endif -%}
    }
        {%- endif -%}
        {%- else -%}
            {%- if _, isScalar := field.t.trw.(*TypeRWPrimitive); !isScalar -%}
    {%s= readingCode %}
            {%- endif -%}
        {%- endif -%}
    {%- endfor -%}
    return nil
}

{%- endif -%}
func (item *{%s= goName %}) ReadJSON(legacyTypeNames bool, in *basictl.JsonLexer{%s= natArgsDecl %}) error {
    {%-
        code // init values for after read processing
        needSomeRaw := false
    -%}
    {%- for _, field := range struct_.Fields -%}
        {%- code /* TODO: skip anonymous names */ -%}
        {%- if field.originalName == "" -%} {%- continue -%} {%- endif -%}
        {%- if field.t.IsTrueType() && field.fieldMask == nil -%} {%- continue -%} {%- endif -%}
        {%- if field.t.IsTrueType() && !field.fieldMask.isField -%} {%- continue -%} {%- endif -%}
        {%- if field.t.IsTrueType() -%}
    var trueType{%s= field.goName %}Presented bool
    var trueType{%s= field.goName %}Value     bool
        {%- elseif !field.HasNatArguments() -%}
            {%- code /* TODO: can be optimized to read with only external nats */ -%}
    var prop{%s= field.goName %}Presented bool
        {%- else -%}
    var raw{%s= field.goName %} []byte
        {%- endif -%}
        {%- code needSomeRaw = true -%}
    {%- endfor -%}
    {%- if needSomeRaw -%}

    {%- endif -%}
    {%- code /* BLOCK: main read */ -%}
    if in != nil {
        in.Delim('{')
        if !in.Ok() {
            return in.Error()
        }
        for !in.IsDelim('}') {
    {%- if len(struct_.Fields) == 0 -%}
            return {%s= struct_.wr.gen.InternalPrefix()%}ErrorInvalidJSON({%q= struct_.wr.tlName.String() %}, "this object can't have properties")
    {%- else -%}
            key := in.UnsafeFieldName(true)
            in.WantColon()
            switch key {
        {%- for _, field := range struct_.Fields -%}
            {%- code /* TODO: skip anonymous names */ -%}
            {%- if field.originalName == "" -%} {%- continue -%} {%- endif -%}
                case "{%s= field.originalName %}":
            {%- code
                reader := "in"
                itemField := fmt.Sprintf("item.%s", field.goName)
            -%}
            {%- if field.t.IsTrueType() -%}
                {%- if field.fieldMask == nil -%}
                    var tmp{%s= field.goName %} {%s= field.t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false) %}
                    {%s= field.t.TypeJSON2ReadingCode(bytesVersion, directImports, struct_.wr.ins, "in", "tmp" + field.goName, formatNatArgs(struct_.Fields, field.natArgs), field.recursive) %}
                {%- elseif !field.fieldMask.isField -%}
                    return {%s= struct_.wr.gen.InternalPrefix()%}ErrorInvalidJSON({%q= struct_.wr.tlName.String() %}, "implicit true field '{%s= field.originalName %}' cannot be defined, set fieldmask instead")
                {%- else -%}
                    if trueType{%s= field.goName %}Presented {
                        return {%s= struct_.wr.gen.InternalPrefix()%}ErrorInvalidJSONWithDuplicatingKeys({%q= struct_.wr.tlName.String() %}, {%q= field.originalName %})
                    }
                    if err := {%s= struct_.wr.gen.InternalPrefix()%}Json2ReadBool(in, &trueType{%s= field.goName %}Value); err != nil {
                        return err
                    }
                    trueType{%s= field.goName %}Presented = true
                {%- endif -%}
            {%- elseif !field.HasNatArguments() -%}
                    if prop{%s= field.goName %}Presented {
                        return {%s= struct_.wr.gen.InternalPrefix()%}ErrorInvalidJSONWithDuplicatingKeys({%q= struct_.wr.tlName.String() %}, {%q= field.originalName %})
                    }
                {%- if field.recursive -%}
                    if {%s= itemField %} == nil {
                        var value {%s= field.t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false) %}
                        {%s= itemField %} = &value
                    }
                {%- endif -%}
                {%- if field.IsAffectedByExternalFieldMask() -%}
                    if {%s= formatNatArg(struct_.Fields, *field.fieldMask) %} & (1 << {%v field.BitNumber %}) == 0 {
                        return {%s= struct_.wr.gen.InternalPrefix()%}ErrorInvalidJSON({%q= struct_.wr.tlName.String() %}, "field '{%s= field.originalName %}' is defined, while corresponding implicit fieldmask bit is 0")
                    }
                {%- endif -%}
                    {%s= field.t.TypeJSON2ReadingCode(bytesVersion, directImports, struct_.wr.ins, reader, itemField, formatNatArgs(struct_.Fields, field.natArgs), field.recursive) %}
                    prop{%s= field.goName %}Presented = true
            {%- else -%}
                    if raw{%s= field.goName %} != nil {
                        return {%s= struct_.wr.gen.InternalPrefix()%}ErrorInvalidJSONWithDuplicatingKeys({%q= struct_.wr.tlName.String() %}, {%q= field.originalName %})
                    }
                    raw{%s= field.goName %} = in.Raw()
                    if !in.Ok() {
                        return in.Error()
                    }
            {%- endif -%}
        {%- endfor -%}
                default: return {%s= struct_.wr.gen.InternalPrefix()%}ErrorInvalidJSONExcessElement({%q= struct_.wr.tlName.String() %}, key)
            }
            in.WantComma()
    {%- endif -%}
        }
        in.Delim('}')
        if !in.Ok() {
            return in.Error()
        }
    }
    {%- code /* BLOCK: reset independent props with they are absent */ -%}
    {%- for _, field := range struct_.Fields -%}
            {%- code /* TODO: skip anonymous names */ -%}
            {%- if field.originalName == "" -%} {%- continue -%} {%- endif -%}
            {%- if field.t.IsTrueType() -%} {%- continue -%} {%- endif -%}
            {%- if !field.HasNatArguments() -%}
    if !prop{%s= field.goName %}Presented {
                {%- if field.recursive -%}
        if item.{%s= field.goName %} != nil {
            {%s= field.t.TypeResettingCode(bytesVersion, directImports, struct_.wr.ins, "item." + field.goName, field.recursive) %}
        }
                {%- else -%}
        {%s= field.t.TypeResettingCode(bytesVersion, directImports, struct_.wr.ins, "item." + field.goName, field.recursive) %}
                {%- endif -%}
    }
            {%- endif -%}
    {%- endfor -%}
    {%- code /* BLOCK: bit fix */ -%}
    {%- for _, field := range struct_.Fields -%}
        {%- code /* TODO: skip anonymous names */ -%}
        {%- if field.originalName == "" -%} {%- continue -%} {%- endif -%}
        {%- if field.IsAffectingLocalFieldMasks() -%}
            {%- code
                presentCondition := "true"
                if field.t.IsTrueType() {
                    presentCondition = "trueType" + field.goName + "Presented"
                } else if !field.HasNatArguments() {
                    presentCondition = "prop" + field.goName + "Presented"
                } else {
                    presentCondition = "raw" + field.goName + " != nil"
                }
                affectedFields, bits := struct_.AllAffectedFieldMasks(field)
            -%}
    if {%s= presentCondition %} {
        {%- code firstAffectedNat := 0 -%}
        {%- if field.t.IsTrueType() -%}
            {%- code
                /* COMMENT: if trueType value is false bit sets to zero */
                firstAffectedNat = 1
            -%}
        if trueType{%s= field.goName %}Value {
            {%s= formatNatArg(struct_.Fields, *field.fieldMask) %} |= 1 << {%v field.BitNumber %}
        }
        {%- endif -%}
        {%- for i := firstAffectedNat; i < len(affectedFields); i++-%}
        item.{%s= affectedFields[i].goName %} |= 1 << {%v bits[i] %}
        {%- endfor -%}
    }
        {%- endif -%}
    {%- endfor -%}
    {%- code /* BLOCK: read rest fields */ -%}
    {%- for _, field := range struct_.Fields -%}
        {%- code /* TODO: skip anonymous names */ -%}
        {%- if field.originalName == "" -%} {%- continue -%} {%- endif -%}
        {%- if field.t.IsTrueType() || !field.HasNatArguments() -%} {%- continue -%} {%- endif -%}
        {%- code presentCondition := "raw" + field.goName + " != nil" -%}
        {%- if field.fieldMask != nil -%}
        if {%s= formatNatArg(struct_.Fields, *field.fieldMask) %} & (1 << {%v field.BitNumber %}) == 0 {
            {%- if field.IsAffectedByExternalFieldMask() -%}
            if {%s= presentCondition %} {
                return {%s= struct_.wr.gen.InternalPrefix()%}ErrorInvalidJSON({%q= struct_.wr.tlName.String() %}, "field '{%s= field.originalName %}' is defined, while corresponding implicit fieldmask bit is 0")
            }
            {%- endif -%}
            {%- code resetCode := field.t.TypeResettingCode(bytesVersion, directImports, struct_.wr.ins, fmt.Sprintf("item.%s", field.goName), field.recursive) -%}
            {%- if field.recursive -%}
            if item.{%s= field.goName %} != nil {
                {%s= resetCode %}
            }
            {%- else -%}
            {%s= resetCode %}
            {%- endif -%}
        } else {
            {%= struct_.readJsonWithResetForRaw(field, bytesVersion, directImports) %}
        }
        {%- else -%}
        {%= struct_.readJsonWithResetForRaw(field, bytesVersion, directImports) %}
        {%- endif -%}
    {%- endfor -%}
    {%- code /* BLOCK: trueType with false values validation */ -%}
    {%- for _, field := range struct_.Fields -%}
        {%- if !field.t.IsTrueType() || field.fieldMask == nil || !field.fieldMask.isField -%} {%- continue -%} {%- endif -%}
        {%- code
            fieldMask := struct_.Fields[field.fieldMask.FieldIndex]
            fieldMaskName := fieldMask.goName
            bit := field.BitNumber
        -%}
        // tries to set bit to zero if it is 1
        if trueType{%s= field.goName %}Presented && !trueType{%s= field.goName %}Value && (item.{%s= fieldMaskName %} & (1 << {%v bit %}) != 0) {
            return {%s= struct_.wr.gen.InternalPrefix()%}ErrorInvalidJSON({%q= struct_.wr.tlName.String() %}, "fieldmask bit {%s= fieldMask.originalName %}.{%d= field.fieldMask.FieldIndex %} is indefinite because of the contradictions in values")
        }
    {%- endfor -%}
    return nil
}

{%- endfunc -%}
{%- func (struct_ *TypeRWStruct)readJsonWithResetForRaw(field Field, bytesVersion bool, directImports *DirectImports) -%}
        var in{%s= field.goName %}Pointer *basictl.JsonLexer
        in{%s= field.goName %} := basictl.JsonLexer{Data:raw{%s= field.goName %}}
        if raw{%s= field.goName %} != nil {
            in{%s= field.goName %}Pointer = &in{%s= field.goName %}
        }
        {%- code readingCode := field.t.TypeJSON2ReadingCode(bytesVersion, directImports, struct_.wr.ins, "in" + field.goName + "Pointer", "item." + field.goName, formatNatArgs(struct_.Fields, field.natArgs), field.recursive) -%}
        {%- if field.recursive -%}
        if item.{%s= field.goName %} == nil {
            var value {%s= field.t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false) %}
            item.{%s= field.goName %} = &value
        }
        {%- endif -%}
        {%s= readingCode %}
{%- endfunc -%}
{%- func (struct_ *TypeRWStruct)writeJSONCode(bytesVersion bool, directImports *DirectImports) -%}
    {%- code
        goName := addBytes(struct_.wr.goGlobalName, bytesVersion)
        natArgsDecl := formatNatArgsDecl(struct_.wr.NatParams)
        natArgsCall := formatNatArgsDeclCall(struct_.wr.NatParams)
        writeNeedsError := struct_.wr.hasErrorInWriteMethods
    -%}

// This method is general version of WriteJSON, use it instead!
func (item *{%s= goName %}) WriteJSONGeneral(w []byte{%s= natArgsDecl %}) (_ []byte, err error) {
    {%- if writeNeedsError -%}
    return item.WriteJSONOpt(true, false, w{%s= natArgsCall %})
    {%- else -%}
    return item.WriteJSONOpt(true, false, w{%s= natArgsCall %}), nil
    {%- endif -%}
}

func (item *{%s= goName %}) WriteJSON(w []byte{%s= natArgsDecl %}) {%s= wrapWithError(writeNeedsError, "[]byte") %} {
    return item.WriteJSONOpt(true, false, w{%s= natArgsCall %})
}
func (item *{%s= goName %}) WriteJSONOpt(newTypeNames bool, short bool, w []byte{%s= natArgsDecl %}) {%s= wrapWithError(writeNeedsError, "[]byte") %} {
    w = append(w, '{')
    {%- for _, field := range struct_.Fields -%}
        {%- code // field names will be mandatory soon, except for typedefs which are processed separately
        -%}
        {%- if field.originalName == "" -%} {%- continue -%} {%- endif -%}
        {%- if field.t.IsTrueType() -%}
            {%- if field.fieldMask != nil && (field.fieldMask.isField || field.fieldMask.isArith) -%}
    if {%s= formatNatArg(struct_.Fields, *field.fieldMask) %} & (1<<{%v field.BitNumber %}) != 0 {
        w = basictl.JSONAddCommaIfNeeded(w)
        w = append(w, `{%q= field.originalName %}:true`...)
    }
            {%- endif -%}
        {%- else -%}
            {%- if field.fieldMask != nil -%}
    if {%s= formatNatArg(struct_.Fields, *field.fieldMask) %} & (1<<{%v field.BitNumber %}) != 0 {
            {%- endif -%}
{%- comment %}
if value is under mask and is empty and mask bit is set, we want it to be explicitly set, for example
vru.replicaState#3d74578e fields_mask:# pre_vote_demote  :fields_mask.10?string = vru.ReplicaState;

{"fields_mask":1024} // we do not want this, as it is hard to say "pre_vote_demote" is set
{"fields_mask":1024, "pre_vote_demote": ""} // we want this, viewer knows immediately that "pre_vote_demote" is set
{% endcomment -%}
            {%- if field.fieldMask == nil && field.t.TypeJSONEmptyCondition(bytesVersion, fmt.Sprintf("item.%s", field.goName), field.recursive, ) != "" -%}
                backupIndex{%s= field.goName %} := len(w)
            {%- endif -%}
                w = basictl.JSONAddCommaIfNeeded(w)
                w = append(w, `"{%s field.originalName %}":`...)
        {%s= field.t.TypeJSONWritingCode(bytesVersion, directImports, struct_.wr.ins, fmt.Sprintf("item.%s", field.goName), formatNatArgs(struct_.Fields, field.natArgs), field.recursive, field.t.hasErrorInWriteMethods) %}
            {%- if field.fieldMask == nil && field.t.TypeJSONEmptyCondition(bytesVersion, fmt.Sprintf("item.%s", field.goName), field.recursive, ) != "" -%}
                if ({%s= field.t.TypeJSONEmptyCondition(bytesVersion, fmt.Sprintf("item.%s", field.goName), field.recursive, ) %}) == false {
                        w = w[:backupIndex{%s= field.goName %}]
                }
            {%- endif -%}
            {%- if field.fieldMask != nil -%}
    }
            {%- endif -%}
        {%- endif -%}
    {%- endfor -%}
    {%- if writeNeedsError -%}
    return append(w, '}'), nil
    {%- else -%}
    return append(w, '}')
    {%- endif -%}
}
{%- endfunc -%}

{%- func (struct_ *TypeRWStruct)functionCode(bytesVersion bool, directImports *DirectImports) -%}
    {%- if struct_.ResultType == nil -%}{%- return -%}{%- endif -%}
    {%- code
        goName :=  addBytes(struct_.wr.goGlobalName, bytesVersion)
        retArg := struct_.ResultType.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false)
    -%}
func (item *{%s= goName %}) ReadResult(w []byte, ret *{%s= retArg %}) (_ []byte, err error) {
    {%s= struct_.ResultType.TypeReadingCode(bytesVersion, directImports, struct_.wr.ins, "ret", false, formatNatArgs(struct_.Fields, struct_.ResultNatArgs), true, true) %}
}

func (item *{%s= goName %}) WriteResult(w []byte, ret {%s= retArg %}) (_ []byte, err error) {
    {%s= struct_.ResultType.TypeWritingCode(bytesVersion, directImports, struct_.wr.ins, "ret", false, formatNatArgs(struct_.Fields, struct_.ResultNatArgs), false, false, struct_.ResultType.hasErrorInWriteMethods) %}
    return w, nil
}

func (item *{%s= goName %}) ReadResultJSON(legacyTypeNames bool, in *basictl.JsonLexer, ret *{%s= retArg  %}) error {
    {%s= struct_.ResultType.TypeJSON2ReadingCode(bytesVersion, directImports, struct_.wr.ins, "in", "ret", formatNatArgs(struct_.Fields, struct_.ResultNatArgs), true) %}
    return nil
}

func (item *{%s= goName %}) WriteResultJSON(w []byte, ret {%s= retArg  %}) (_ []byte, err error) {
    return item.writeResultJSON(true, false, w, ret)
}

func (item *{%s= goName %}) writeResultJSON(newTypeNames bool, short bool, w []byte, ret {%s= retArg  %}) (_ []byte, err error) {
    {%s= struct_.ResultType.TypeJSONWritingCode(bytesVersion, directImports, struct_.wr.ins, "ret", formatNatArgs(struct_.Fields, struct_.ResultNatArgs), false, struct_.ResultType.hasErrorInWriteMethods) %}
    return w, nil
}

func (item *{%s= goName %}) ReadResultWriteResultJSON(r []byte, w []byte) (_ []byte, _ []byte, err error) {
  var ret {%s= retArg %}
  if r, err = item.ReadResult(r, &ret); err != nil {
    return r, w, err
  }
  w, err = item.WriteResultJSON(w, ret)
  return r, w, err
}

func (item *{%s= goName %}) ReadResultWriteResultJSONOpt(newTypeNames bool, short bool, r []byte, w []byte) (_ []byte, _ []byte, err error) {
  var ret {%s= retArg %}
  if r, err = item.ReadResult(r, &ret); err != nil {
    return r, w, err
  }
  w, err = item.writeResultJSON(newTypeNames, short, w, ret)
  return r, w, err
}

func (item *{%s= goName %}) ReadResultJSONWriteResult(r []byte, w []byte) ([]byte, []byte, error) {
  var ret {%s= retArg %}
  err := item.ReadResultJSON(true, &basictl.JsonLexer{Data: r}, &ret)
  if err != nil {
    return r, w, err
  }
  w, err = item.WriteResult(w, ret)
  return r, w, err
}

{%- endfunc -%}

{%- func (struct_ *TypeRWStruct)resetFields(bytesVersion bool, directImports *DirectImports) -%}
    {%- if struct_.isTypeDef() -%}
        {%- code field := struct_.Fields[0] -%}
ptr := (*{%s= field.t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false) %})(item)
{%s= field.t.TypeResettingCode(bytesVersion, directImports, struct_.wr.ins, "ptr", true) %}
        {%- return -%}
    {%- endif -%}
    {%- for _, field := range struct_.Fields -%}
        {%- code
            if field.t.IsTrueType() {
                continue
            }
            resetCode := field.t.TypeResettingCode(bytesVersion, directImports, struct_.wr.ins, fmt.Sprintf("item.%s", field.goName), field.recursive)
        -%}
        {%- if field.recursive -%}
if item.{%s= field.goName %} != nil { {%s= resetCode %} }
        {%- else -%}
{%s= resetCode %}
        {%- endif -%}
    {%- endfor -%}
{%- endfunc -%}

{%- func (struct_ *TypeRWStruct)randomFields(bytesVersion bool, directImports *DirectImports) -%}
    {%- if struct_.isTypeDef() -%}
        {%- code field := struct_.Fields[0] -%}
ptr := (*{%s= field.t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false) %})(item)
{%s= field.t.TypeRandomCode(bytesVersion, directImports, struct_.wr.ins, "ptr", formatNatArgs(struct_.Fields, field.natArgs), true) %}
        {%- return -%}
    {%- endif -%}
    {%- for fieldId, field := range struct_.Fields -%}
        {%- if field.t.IsTrueType() -%} {%- continue -%} {%- endif -%}
        {%- if field.fieldMask != nil -%}
if {%s= formatNatArg(struct_.Fields, *field.fieldMask) %} & (1<<{%v field.BitNumber %}) != 0 {
        {%- endif -%}
        {%- if field.recursive -%}
rg.IncreaseDepth()
if item.{%s= field.goName %} == nil {
    var value {%s= field.t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false) %}
    item.{%s= field.goName %} = &value
}
        {%- endif -%}
        {%- if fieldProps, indexes := struct_.GetFieldNatProperties(fieldId); (fieldProps & (FieldIsNat | FieldUsedAsFieldMask | FieldUsedAsSize)) != 0 -%}
            {%- if (fieldProps & FieldUsedAsFieldMask) != 0 -%}
var mask{%s= field.goName %} uint32
{%s= field.t.TypeRandomCode(bytesVersion, directImports, struct_.wr.ins, "mask"+field.goName, formatNatArgs(struct_.Fields, field.natArgs), field.recursive) %}
                {%- if (fieldProps & FieldUsedAsSize) != 0 -%}
mask{%s= field.goName %} = rg.LimitValue(mask{%s= field.goName %})
                {%- endif -%}
item.{%s= field.goName %} = 0
                {%- for index, indexPosition := range indexes -%}
if mask{%s= field.goName %} & (1<<{%v= index %}) != 0 {
    item.{%s= field.goName %} |= (1<<{%v= indexPosition %})
}
                {%- endfor -%}
            {%- elseif (fieldProps & FieldUsedAsSize) != 0 -%}
{%s= field.t.TypeRandomCode(bytesVersion, directImports, struct_.wr.ins, "item."+field.goName, formatNatArgs(struct_.Fields, field.natArgs), field.recursive) %}
item.{%s= field.goName %} = rg.LimitValue(item.{%s= field.goName %})
            {%- endif -%}
        {%- else -%}
{%s= field.t.TypeRandomCode(bytesVersion, directImports, struct_.wr.ins, "item."+field.goName, formatNatArgs(struct_.Fields, field.natArgs), field.recursive) %}
        {%- endif -%}
        {%- if field.recursive -%}
rg.DecreaseDepth()
        {%- endif -%}
        {%- if field.fieldMask != nil -%}
} else {
    {%- code resetCode := field.t.TypeResettingCode(bytesVersion, directImports, struct_.wr.ins, fmt.Sprintf("item.%s", field.goName), field.recursive) -%}
            {%- if field.recursive -%}
    if item.{%s= field.goName %} != nil {
        {%s= resetCode %}
    }
            {%- else -%}
    {%s= resetCode %}
            {%- endif -%}
}
        {%- endif -%}
    {%- endfor -%}
{%- endfunc -%}

{%- func (struct_ *TypeRWStruct)writeFields(bytesVersion bool, directImports *DirectImports) -%}
    {%- if struct_.isTypeDef() -%}
        {%- code field := struct_.Fields[0] -%}
ptr := (*{%s= field.t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false) %})(item)
{%s= field.t.TypeWritingCode(bytesVersion, directImports, struct_.wr.ins, "ptr", field.Bare(), formatNatArgs(struct_.Fields, field.natArgs), true, true, struct_.wr.hasErrorInWriteMethods) %}
        {%- return -%}
    {%- endif -%}
    {%- for _, field := range struct_.Fields -%}
        {%- code
            writingCode := ""
            if field.t.IsTrueType() {
                if field.Bare() {
                    continue
                }
                writingCode = fmt.Sprintf("w = basictl.NatWrite(w, 0x%08x)", field.t.tlTag)
            } else {
                writingCode = field.t.TypeWritingCode(bytesVersion, directImports, struct_.wr.ins, fmt.Sprintf("item.%s", field.goName), field.Bare(), formatNatArgs(struct_.Fields, field.natArgs), field.recursive, false, field.t.hasErrorInWriteMethods)
            }
        -%}
        {%- if field.fieldMask != nil -%}
        if {%s= formatNatArg(struct_.Fields, *field.fieldMask) %} & (1<<{%v field.BitNumber %}) != 0 {
            {%s= writingCode %}
        }
        {%- else -%}
        {%s= writingCode %}
        {%- endif -%}
    {%- endfor -%}
    {%- if struct_.wr.hasErrorInWriteMethods -%}
return w, nil
    {%- else -%}
return w
    {%- endif -%}
{%- endfunc -%}

{%- func (struct_ *TypeRWStruct)readFields(bytesVersion bool, directImports *DirectImports) -%}
    {%- if struct_.isTypeDef() -%}
        {%- code field := struct_.Fields[0] -%}
ptr := (*{%s= field.t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false) %})(item)
{%s= field.t.TypeReadingCode(bytesVersion, directImports, struct_.wr.ins, "ptr", field.Bare(), formatNatArgs(struct_.Fields, field.natArgs), true, true) %}
        {%- return -%}
    {%- endif -%}
    {%- code lastWritten := false -%}
    {%- for i, field := range struct_.Fields -%}
        {%- if field.t.IsTrueType() && field.Bare() -%} {%- continue -%} {%- endif -%}
        {%- if field.fieldMask != nil -%}
if {%s= formatNatArg(struct_.Fields, *field.fieldMask) %} & (1<<{%v field.BitNumber %}) != 0 {
        {%- endif -%}
        {%- if field.recursive -%}
if item.{%s= field.goName %} == nil {
    var value {%s= field.t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false) %}
    item.{%s= field.goName %} = &value
}
        {%- endif -%}
        {%- code
            last := i == len(struct_.Fields)-1 && field.fieldMask == nil
            lastWritten = lastWritten || last
        -%}
        {%- if field.t.IsTrueType() -%}
{%s= wrapLastW(last, fmt.Sprintf("basictl.NatReadExactTag(w, 0x%08x)", field.t.tlTag), true) %}
        {%- else -%}
{%s= field.t.TypeReadingCode(bytesVersion, directImports, struct_.wr.ins, "item."+field.goName, field.Bare(), formatNatArgs(struct_.Fields, field.natArgs), field.recursive, last) %}
        {%- endif -%}
        {%- if field.fieldMask != nil -%}
{%- if field.t.IsTrueType() -%}
}
{%- else -%}
} else {
        {%- if field.recursive -%}
        if item.{%s= field.goName %} != nil {
        {%- endif -%}
            {%s= field.t.TypeResettingCode(bytesVersion, directImports, struct_.wr.ins, fmt.Sprintf("item.%s", field.goName), field.recursive) %}
        {%- if field.recursive -%}
        }
        {%- endif -%}
}
{%- endif -%}
        {%- endif -%}
    {%- endfor -%}
    {%- if !lastWritten -%}
return w, nil {%- endif -%}{%- code // keeps all function body on the same line -%}
{%- endfunc -%}
