{% package tlcodegen %}

{% import "fmt" %}

{%- func (struct_ *TypeRWStruct)GenerateCode(bytesVersion bool, directImports *DirectImports) -%}
    {%- code
        goName := addBytes(struct_.goGlobalName, bytesVersion)
        tlTag := fmt.Sprintf("%#x", struct_.wr.tlTag)
        natArgsDecl := formatNatArgsDecl(struct_.wr.NatParams)
        natArgsCall := formatNatArgsCall(struct_.wr.NatParams)
    -%}
    {%- if struct_.wr.unionParent != nil -%}
    {%- code
        ep := struct_.wr.unionParent.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false)
    -%}
    {%- if struct_.wr.unionIsEnum -%}
func {%s= goName %}() {%s= ep %} { return {%s= ep %}__MakeEnum({%d struct_.wr.unionIndex %}) }
    {%- return -%}
    {%- else -%}
func (item {%s= goName %}) AsUnion() {%s= ep %} {
    var ret {%s= ep %}
    ret.Set{%s= struct_.wr.unionField.goName %}({%s= ifString(struct_.wr.IsTrueType(), "", "item") %})
    return ret
}

// AsUnion will be here
    {%- endif -%}
    {%- endif -%}
{%= struct_.typeDefinition(bytesVersion, directImports) %}
    {%- if struct_.wr.tlTag != 0 -%}
        {%- code // anonymous square brackets citizens or other exotic type -%}
func ({%s= goName %}) TLName() string { return {%q= struct_.wr.tlName.String() %} }
func ({%s= goName %}) TLTag() uint32  { return {%s= tlTag %} }

    {%- endif -%}
    {%= struct_.fieldMaskGettersAndSetters(bytesVersion, directImports) %}
    {%- if len(struct_.Fields) == 0 -%}
        {%- code // compact code is good -%}
func (item *{%s= goName %}) Reset() {}
        {%- if struct_.wr.gen.options.GenerateRandomCode -%}
func (item *{%s= goName %}) FillRandom(rand basictl.Rand{%s= natArgsDecl %}) { }
        {%- endif -%}
func (item *{%s= goName %}) Read(w []byte{%s= natArgsDecl %}) ([]byte, error) { return w, nil }
func (item *{%s= goName %}) Write(w []byte{%s= natArgsDecl %}) ([]byte, error) { return w, nil }
    {%- else -%}
func (item *{%s= goName %}) Reset() { {%= struct_.resetFields(bytesVersion, directImports) %} }
        {%- if struct_.wr.gen.options.GenerateRandomCode -%}
func (item *{%s= goName %}) FillRandom(rand basictl.Rand{%s= natArgsDecl %}) { {%= struct_.randomFields(bytesVersion, directImports) %} }
        {%- endif -%}

func (item *{%s= goName %}) Read(w []byte{%s= natArgsDecl %}) (_ []byte, err error) { {%= struct_.readFields(bytesVersion, directImports) %} }

func (item *{%s= goName %}) Write(w []byte{%s= natArgsDecl %}) (_ []byte, err error) { {%= struct_.writeFields(bytesVersion, directImports) %} }

    {%- endif -%}
    {%- if struct_.wr.tlTag != 0 -%}
        {%- if len(struct_.Fields) == 0 -%}
            {%- code // compact code is good -%}
func (item *{%s= goName %}) ReadBoxed(w []byte{%s= natArgsDecl %}) ([]byte, error) { return basictl.NatReadExactTag(w, {%s= tlTag %}) }
func (item *{%s= goName %}) WriteBoxed(w []byte{%s= natArgsDecl %}) ([]byte, error) { return basictl.NatWrite(w, {%s= tlTag %}), nil }


        {%- else -%}
func (item *{%s= goName %}) ReadBoxed(w []byte{%s= natArgsDecl %}) (_ []byte, err error) {
    if w, err = basictl.NatReadExactTag(w, {%s= tlTag %}); err != nil {
        return w, err
    }
    return item.Read(w{%s= natArgsCall %})
}

func (item *{%s= goName %}) WriteBoxed(w []byte{%s= natArgsDecl %}) ([]byte, error) {
    w = basictl.NatWrite(w, {%s= tlTag %})
    return item.Write(w{%s= natArgsCall %})
}

        {%- endif -%}
    {%- endif -%}
{%= struct_.functionCode(bytesVersion, directImports) %}
    {%- if len(struct_.wr.NatParams) == 0 -%}

func (item {%s= goName %}) String({%s= formatNatArgsDeclNoComma(struct_.wr.NatParams) %}) string {
    w, err := item.WriteJSON(nil{%s= natArgsCall %})
    if err != nil {
        return err.Error()
    }
    return string(w)
}
    {%- endif -%}
{%= struct_.generateJSONCode(bytesVersion, directImports) %}
{%- endfunc -%}

{%- func (struct_ *TypeRWStruct)typeDefinition(bytesVersion bool, directImports *DirectImports) -%}
    {%- code goName := addBytes(struct_.goGlobalName, bytesVersion) -%}
    {%- if struct_.isTypeDef() -%}
        {%- code
            asterisk := ifString(struct_.Fields[0].recursive, "*", "")
            fieldTypeString :=  struct_.Fields[0].t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false)
        -%}
type {%s= goName %} {%s= asterisk %}{%s= fieldTypeString %}
        {%- return -%}
    {%- endif -%}
type {%s= goName %} struct {
    {%- for _, field := range struct_.Fields -%}
        {%- code
            asterisk := ifString(field.recursive, "*", "")
            fieldTypeString := ""
            fieldsMaskComment := ""
            if field.fieldMask != nil {
                fieldsMaskComment = fmt.Sprintf(" // Conditional: %s.%d", formatNatArg(struct_.Fields, *field.fieldMask), field.BitNumber)
            }
            prefixComment := ""
            if field.t.IsTrueType() {
                prefixComment = "// "
                fieldTypeString = "(TrueType)"
            } else {
                fieldTypeString = field.t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false)
            }
        -%}
    {%s= prefixComment %}{%s= field.goName %} {%s= asterisk %}{%s= fieldTypeString %}{%s= fieldsMaskComment %}
    {%- endfor -%}
}
{%- endfunc -%}

{%- func (struct_ *TypeRWStruct)fieldMaskGettersAndSetters(bytesVersion bool, directImports *DirectImports) -%}
    {%- code goName := addBytes(struct_.goGlobalName, bytesVersion) -%}
    {%- for i, field := range struct_.Fields -%}
        {%- if field.fieldMask == nil -%} {%- continue -%} {%- endif -%}
        {%- code
            fieldTypeString := ""
            isTrueType := "bool"
            maskFunArg := !field.fieldMask.isField && !field.fieldMask.isArith
            natArgUse := formatNatArg(struct_.Fields, *field.fieldMask)
            asterisk := addAsterisk(field.recursive, "")
        -%}
        {%- if !field.t.IsTrueType() -%}
        {%- code
            fieldTypeString = field.t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false)
            isTrueType = fieldTypeString
        -%}
        {%- endif -%}
        {%- if !field.fieldMask.isArith -%}
            {%- code
                // Example
                //     notify.notification#461f4ce2 {mode:#} removed:mode.0?Bool = notify.Notification mode;
                //     @any notify.getScheduledNotifications#f53ad7bd  = notify.Notification 0;
                // We skip generating Set and Clear altogether in this case, but still generate IsSet
                setName := struct_.setNames[i]
                if setName == "" {
                    setName = struct_.fieldsDec.deconflictName("Set" + field.goName)
                    struct_.setNames[i] = setName
                }
            -%}
            {%- if maskFunArg -%}

func (item *{%s= goName %}) {%s= setName %}(v {%s= isTrueType %}, {%s= natArgUse %} *uint32) {
            {%- else -%}
func (item *{%s= goName %}) {%s= setName %}(v {%s= isTrueType %}) {
            {%- endif -%}
            {%- if !field.t.IsTrueType() -%}
                {%- if field.recursive -%}
    if item.{%s= field.goName %} == nil {
        var value {%s= fieldTypeString %}
        item.{%s= field.goName %} = &value
    }
                {%- endif -%}
    {%s= asterisk %}item.{%s= field.goName %} = v
            {%- endif -%}
            {%- if maskFunArg -%}
    if {%s= natArgUse %} != nil {
            {%- endif -%}
            {%- if field.t.IsTrueType() -%}
        if v {
            {%s= addAsterisk(maskFunArg, natArgUse)  %} |= 1 << {%v field.BitNumber %}
        } else {
            {%s= addAsterisk(maskFunArg, natArgUse)  %} &^= 1 << {%v field.BitNumber %}
        }
            {%- else -%}
        {%s= addAsterisk(maskFunArg, natArgUse) %} |= 1 << {%v field.BitNumber %}
            {%- endif -%}
            {%- if maskFunArg -%}
    }
            {%- endif -%}
}
            {%- if !field.t.IsTrueType() -%}
                {%- code clearName := struct_.clearNames[i]
                if clearName == "" {
                        clearName = struct_.fieldsDec.deconflictName("Clear" + field.goName)
                        struct_.clearNames[i] = clearName
                    }
                -%}
                {%- if maskFunArg -%}
func (item *{%s= goName %}) {%s= clearName %}({%s= natArgUse %} *uint32) {
                {%- else -%}
func (item *{%s= goName %}) {%s= clearName %}() {
                {%- endif -%}
                {%- if field.recursive -%}
    if item.{%s= field.goName %} != nil { {%s= field.t.TypeResettingCode(bytesVersion, directImports, struct_.wr.ins, fmt.Sprintf("item.%s", field.goName), field.recursive) %} }
                {%- else -%}
    {%s= field.t.TypeResettingCode(bytesVersion, directImports, struct_.wr.ins, fmt.Sprintf("item.%s", field.goName), field.recursive) %}
                {%- endif -%}
                {%- if maskFunArg-%}
    if {%s= natArgUse %} != nil {
                {%- endif -%}
    {%s= addAsterisk(maskFunArg, natArgUse) %} &^= 1 << {%v field.BitNumber %}
                {%- if maskFunArg-%}
    }
                {%- endif -%}
}
            {%- endif -%}
        {%- endif -%}
        {%- code
            isSetName := struct_.isSetNames[i]
            if isSetName == "" {
                isSetName = struct_.fieldsDec.deconflictName("IsSet" + field.goName)
                struct_.isSetNames[i] = isSetName
            }
        -%}
        {%- if maskFunArg -%}
func (item {%s= goName %}) {%s= isSetName %}({%s= natArgUse %} uint32) bool { return {%s= natArgUse %} & (1 << {%v field.BitNumber %}) != 0 }
        {%- else -%}
func (item {%s= goName %}) {%s= isSetName %}() bool { return {%s= natArgUse %} & (1 << {%v field.BitNumber %}) != 0 }
        {%- endif -%}


    {%- endfor -%}
{%- endfunc -%}

{%- func (struct_ *TypeRWStruct)generateJSONCode(bytesVersion bool, directImports *DirectImports) -%}
    {%- code
        goName := addBytes(struct_.goGlobalName, bytesVersion)
        natArgsDecl := formatNatArgsDecl(struct_.wr.NatParams)
        natArgsCall := formatNatArgsCall(struct_.wr.NatParams)
    -%}
    {%- if struct_.isTypeDef() -%}
        {%- code
            field := struct_.Fields[0]
            fieldTypeString := field.t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false)
        -%}

func {%s= goName %}__ReadJSON(item *{%s= goName %}, j interface{}{%s= natArgsDecl %}) error { return item.readJSON(j{%s= natArgsCall %}); }
func (item *{%s= goName %}) readJSON(j interface{}{%s= natArgsDecl %}) error {
    ptr := (*{%s= fieldTypeString %})(item)
    {%s= field.t.TypeJSONReadingCode(bytesVersion, directImports, struct_.wr.ins, "j", "ptr", formatNatArgs(struct_.Fields, field.natArgs), true) %}
    return nil
}

func (item *{%s= goName %}) WriteJSON(w []byte{%s= natArgsDecl %}) (_ []byte, err error) {
    return item.WriteJSONOpt(false, w{%s= natArgsCall %})
}

func (item *{%s= goName %}) WriteJSONOpt(short bool, w []byte{%s= natArgsDecl %}) (_ []byte, err error) {
    ptr := (*{%s= fieldTypeString %})(item)
    {%s= field.t.TypeJSONWritingCode(bytesVersion, directImports, struct_.wr.ins, "ptr", formatNatArgs(struct_.Fields, field.natArgs), true) %}
    return w, nil
}
    {%- else -%}
        {%- code
// Sorting fields is bad idea. It is convenient when they are in TL order
        -%}

{%= struct_.readJSONCode(bytesVersion, directImports) %}
{%= struct_.writeJSONCode(bytesVersion, directImports) %}
    {%- endif -%}
    {%- if len(struct_.wr.NatParams) == 0 -%}
func (item *{%s= goName %}) MarshalJSON() ([]byte, error) {
  return item.WriteJSON(nil)
}

func (item *{%s= goName %}) UnmarshalJSON(b []byte) error {
    j, err := {%s= struct_.wr.gen.InternalPrefix()%}JsonBytesToInterface(b)
    if err != nil {
        return {%s= struct_.wr.gen.InternalPrefix()%}ErrorInvalidJSON({%q= struct_.wr.tlName.String() %}, err.Error())
    }
    if err = item.readJSON(j); err != nil {
        return {%s= struct_.wr.gen.InternalPrefix()%}ErrorInvalidJSON({%q= struct_.wr.tlName.String() %}, err.Error())
    }
    return nil
}
    {%- endif -%}

{%- endfunc -%}

{%- func (struct_ *TypeRWStruct)readJSONCode(bytesVersion bool, directImports *DirectImports) -%}
    {%- code
        goName := addBytes(struct_.goGlobalName, bytesVersion)
        natArgsDecl := formatNatArgsDecl(struct_.wr.NatParams)
        natArgsCall := formatNatArgsCall(struct_.wr.NatParams)
    -%}
func {%s= goName %}__ReadJSON(item *{%s= goName %}, j interface{}{%s= natArgsDecl %}) error { return item.readJSON(j{%s= natArgsCall %}); }
func (item *{%s= goName %}) readJSON(j interface{}{%s= natArgsDecl %}) error {
    _jm, _ok := j.(map[string]interface{})
    if j != nil && !_ok {
        return {%s= struct_.wr.gen.InternalPrefix()%}ErrorInvalidJSON({%q= struct_.wr.tlName.String() %}, "expected json object")
    }
    {%- code
// first we read everything that could be field mask (primitives)
// then we set explicit/check implicit field masks depending on which keys json object has
// then we read the rest, passing the same field masks to every field reader
    -%}
    {%- for _, field := range struct_.Fields -%}
        {%- code
            jsonField := fmt.Sprintf("_j%s", field.goName)
            itemField := fmt.Sprintf("item.%s", field.goName)
        -%}
    {%s= jsonField %} := _jm[{%q= field.originalName %}]
    delete(_jm,{%q= field.originalName %})
        {%- if field.fieldMask != nil -%} {%- continue %} {%- endif -%}
        {%- if _, isScalar := field.t.trw.(*TypeRWPrimitive); !isScalar -%}
            {%- continue %}
        {%- endif -%}
    {%s= field.t.TypeJSONReadingCode(bytesVersion, directImports, struct_.wr.ins, jsonField, itemField, formatNatArgs(struct_.Fields, field.natArgs), field.recursive) %}
    {%- endfor -%}
    for k := range _jm {
        return {%s= struct_.wr.gen.InternalPrefix()%}ErrorInvalidJSONExcessElement({%q= struct_.wr.tlName.String() %}, k)
    }
    {%- for _, field := range struct_.Fields -%}
        {%- if field.fieldMask == nil -%} {%- continue -%} {%- endif -%}
        {%- code
             // If field depends on implicit field mask and set in json, but field mask bit not set, this is error
             // Otherwise field will be silently ignored, to caller surprise
             //
             // If field depends on explicit field mask and set in json, we set the bit
             // Setting field is convenient to set field mask bits. Also works for true-types
             //
             // We must first set all bits, only then read fields, so that all fields depend on te same set of bits

            jsonField := fmt.Sprintf("_j%s", field.goName)
        -%}
        {%- if field.t.IsTrueType() -%}
            {%- if !field.fieldMask.isField -%}
    if {%s= jsonField %} != nil {
        return {%s= struct_.wr.gen.InternalPrefix()%}ErrorInvalidJSON({%q= struct_.wr.tlName.String() %}, "implicit true field '{%s= field.originalName %}' cannot be defined, set fieldmask instead")
    }
            {%- else -%}
    if {%s= jsonField %} != nil {
        _bit := false
        if err := {%s= struct_.wr.gen.InternalPrefix()%}JsonReadBool({%s= jsonField %}, &_bit); err != nil {
            return err
        }
        if _bit {
            {%s= formatNatArg(struct_.Fields, *field.fieldMask) %} |= 1 << {%v field.BitNumber %}
        } else {
            {%s= formatNatArg(struct_.Fields, *field.fieldMask) %} &^= 1 << {%v field.BitNumber %}
        }
    }
            {%- endif -%}
        {%- else -%}
            {%- if !field.fieldMask.isField -%}
    if {%s= formatNatArg(struct_.Fields, *field.fieldMask) %} & (1 << {%v field.BitNumber %}) == 0 && {%s= jsonField %} != nil {
        return {%s= struct_.wr.gen.InternalPrefix()%}ErrorInvalidJSON({%q= struct_.wr.tlName.String() %}, "field '{%s= field.originalName %}' is defined, while corresponding implicit fieldmask bit is 0")
    }
            {%- else -%}
    if {%s= jsonField %} != nil {
        {%s= formatNatArg(struct_.Fields, *field.fieldMask) %} |= 1 << {%v field.BitNumber %}
    }
            {%- endif -%}
        {%- endif -%}
    {%- endfor -%}
    {%- for _, field := range struct_.Fields -%}
        {%- code
            jsonField := fmt.Sprintf("_j%s", field.goName)
            itemField := fmt.Sprintf("item.%s", field.goName)
        -%}
        {%- if field.t.IsTrueType() -%}
            {%- if field.fieldMask == nil -%}
                {%- code
                    tmpName := fmt.Sprintf("_%s", field.goName)
                    readingCode := field.t.TypeJSONReadingCode(bytesVersion, directImports, struct_.wr.ins, jsonField, tmpName, formatNatArgs(struct_.Fields, field.natArgs), field.recursive)
                -%}
        {%- code fieldTypeString := field.t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false) -%}
    var {%s= tmpName %} {%s= fieldTypeString %}
    {%s= readingCode %}
            {%- endif -%}
            {%- continue -%}
        {%- endif -%}
        {%- code
            readingCode := field.t.TypeJSONReadingCode(bytesVersion, directImports, struct_.wr.ins, jsonField, itemField, formatNatArgs(struct_.Fields, field.natArgs), field.recursive)
            // TODO - for recursive field, add initialization
            resettingCode := field.t.TypeResettingCode(bytesVersion, directImports, struct_.wr.ins, itemField, field.recursive)
        -%}
        {%- if field.fieldMask != nil -%}
            {%- if !field.fieldMask.isField -%}
    if {%s= formatNatArg(struct_.Fields, *field.fieldMask) %} & (1 << {%v field.BitNumber %}) != 0 {
        {%s= readingCode %}
    } else {
        {%s= resettingCode %}
    }
            {%- else -%}
    if {%s= jsonField %} != nil {
        {%s= readingCode %}
    } else {
        {%s= resettingCode %}
    }
            {%- endif -%}
        {%- else -%}
            {%- if _, isScalar := field.t.trw.(*TypeRWPrimitive); !isScalar -%}
    {%s= readingCode %}
            {%- endif -%}
        {%- endif -%}
    {%- endfor -%}
    return nil
}
{%- endfunc -%}

{%- func (struct_ *TypeRWStruct)writeJSONCode(bytesVersion bool, directImports *DirectImports) -%}
func (item *{%s= addBytes(struct_.goGlobalName, bytesVersion) %}) WriteJSON(w []byte{%s= formatNatArgsDecl(struct_.wr.NatParams) %}) (_ []byte, err error) {
    return item.WriteJSONOpt(false, w{%s= formatNatArgsCall(struct_.wr.NatParams) %})
}
func (item *{%s= addBytes(struct_.goGlobalName, bytesVersion) %}) WriteJSONOpt(short bool, w []byte{%s= formatNatArgsDecl(struct_.wr.NatParams) %}) (_ []byte, err error) {
    w = append(w, '{')
    {%- for _, field := range struct_.Fields -%}
        {%- if field.t.IsTrueType() -%}
            {%- if field.fieldMask != nil && (field.fieldMask.isField || field.fieldMask.isArith) -%}
    if {%s= formatNatArg(struct_.Fields, *field.fieldMask) %} & (1<<{%v field.BitNumber %}) != 0 {
        w = basictl.JSONAddCommaIfNeeded(w)
        w = append(w, `{%q= field.originalName %}:true`...)
    }
            {%- endif -%}
        {%- else -%}
            {%- if field.fieldMask != nil -%}
    if {%s= formatNatArg(struct_.Fields, *field.fieldMask) %} & (1<<{%v field.BitNumber %}) != 0 {
            {%- endif -%}
            {%- if field.t.TypeJSONEmptyCondition(bytesVersion, fmt.Sprintf("item.%s", field.goName), field.recursive, ) != "" -%}
                if {%s= field.t.TypeJSONEmptyCondition(bytesVersion, fmt.Sprintf("item.%s", field.goName), field.recursive, ) %} {
            {%- endif -%}
                w = basictl.JSONAddCommaIfNeeded(w)
                w = append(w, `"{%s field.originalName %}":`...)
        {%s= field.t.TypeJSONWritingCode(bytesVersion, directImports, struct_.wr.ins, fmt.Sprintf("item.%s", field.goName), formatNatArgs(struct_.Fields, field.natArgs), field.recursive) %}
            {%- if field.t.TypeJSONEmptyCondition(bytesVersion, fmt.Sprintf("item.%s", field.goName), field.recursive, ) != "" -%}
                }
            {%- endif -%}
            {%- if field.fieldMask != nil -%}
    }
            {%- endif -%}
        {%- endif -%}
    {%- endfor -%}
    return append(w, '}'), nil
}
{%- endfunc -%}

{%- func (struct_ *TypeRWStruct)functionCode(bytesVersion bool, directImports *DirectImports) -%}
    {%- if struct_.ResultType == nil -%}{%- return -%}{%- endif -%}
    {%- code
        goGlobalName :=  addBytes(struct_.goGlobalName, bytesVersion)
        retArg := struct_.ResultType.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false)
    -%}
func (item *{%s= goGlobalName %}) ReadResult(w []byte, ret *{%s= retArg %}) (_ []byte, err error) {
    {%s= struct_.ResultType.TypeReadingCode(bytesVersion, directImports, struct_.wr.ins, "ret", false, formatNatArgs(struct_.Fields, struct_.ResultNatArgs), true, true) %}
}

func (item *{%s= goGlobalName %}) WriteResult(w []byte, ret {%s= retArg %}) (_ []byte, err error) {
    {%s= struct_.ResultType.TypeWritingCode(bytesVersion, directImports, struct_.wr.ins, "ret", false, formatNatArgs(struct_.Fields, struct_.ResultNatArgs), false, true) %}
}

func (item *{%s= goGlobalName %}) ReadResultJSON(j interface{}, ret *{%s= retArg  %}) error {
    {%s= struct_.ResultType.TypeJSONReadingCode(bytesVersion, directImports, struct_.wr.ins, "j", "ret", formatNatArgs(struct_.Fields, struct_.ResultNatArgs), true) %}
    return nil
}

func (item *{%s= goGlobalName %}) WriteResultJSON(w []byte, ret {%s= retArg  %}) (_ []byte, err error) {
    return item.writeResultJSON(false, w, ret)
}

func (item *{%s= goGlobalName %}) writeResultJSON(short bool, w []byte, ret {%s= retArg  %}) (_ []byte, err error) {
    {%s= struct_.ResultType.TypeJSONWritingCode(bytesVersion, directImports, struct_.wr.ins, "ret", formatNatArgs(struct_.Fields, struct_.ResultNatArgs), false) %}
    return w, nil
}

func (item *{%s= goGlobalName %}) ReadResultWriteResultJSON(r []byte, w []byte) (_ []byte, _ []byte, err error) {
  var ret {%s= retArg %}
  if r, err = item.ReadResult(r, &ret); err != nil {
    return r, w, err
  }
  w, err = item.WriteResultJSON(w, ret)
  return r, w, err
}

func (item *{%s= goGlobalName %}) ReadResultWriteResultJSONShort(r []byte, w []byte) (_ []byte, _ []byte, err error) {
  var ret {%s= retArg %}
  if r, err = item.ReadResult(r, &ret); err != nil {
    return r, w, err
  }
  w, err = item.writeResultJSON(true, w, ret)
  return r, w, err
}

func (item *{%s= goGlobalName %}) ReadResultJSONWriteResult(r []byte, w []byte) ([]byte, []byte, error) {
  j, err := {%s= struct_.wr.gen.InternalPrefix()%}JsonBytesToInterface(r)
  if err != nil {
    return r, w, {%s= struct_.wr.gen.InternalPrefix()%}ErrorInvalidJSON({%q= struct_.wr.tlName.String()  %}, err.Error())
  }
  var ret {%s= retArg %}
  if err = item.ReadResultJSON(j, &ret); err != nil {
    return r, w, err
  }
  w, err = item.WriteResult(w, ret)
  return r, w, err
}

{%- endfunc -%}

{%- func (struct_ *TypeRWStruct)resetFields(bytesVersion bool, directImports *DirectImports) -%}
    {%- if struct_.isTypeDef() -%}
        {%- code field := struct_.Fields[0] -%}
ptr := (*{%s= field.t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false) %})(item)
{%s= field.t.TypeResettingCode(bytesVersion, directImports, struct_.wr.ins, "ptr", true) %}
        {%- return -%}
    {%- endif -%}
    {%- for _, field := range struct_.Fields -%}
        {%- code
            if field.t.IsTrueType() {
                continue
            }
            resetCode := field.t.TypeResettingCode(bytesVersion, directImports, struct_.wr.ins, fmt.Sprintf("item.%s", field.goName), field.recursive)
        -%}
        {%- if field.recursive -%}
if item.{%s= field.goName %} != nil { {%s= resetCode %} }
        {%- else -%}
{%s= resetCode %}
        {%- endif -%}
    {%- endfor -%}
{%- endfunc -%}

{%- func (struct_ *TypeRWStruct)randomFields(bytesVersion bool, directImports *DirectImports) -%}
    {%- if struct_.isTypeDef() -%}
        {%- code field := struct_.Fields[0] -%}
ptr := (*{%s= field.t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false) %})(item)
{%s= field.t.TypeRandomCode(bytesVersion, directImports, struct_.wr.ins, "ptr", formatNatArgs(struct_.Fields, field.natArgs), true) %}
        {%- return -%}
    {%- endif -%}
    {%- code lastWritten := false -%}
    {%- for i, field := range struct_.Fields -%}
        {%- if field.t.IsTrueType() -%} {%- continue -%} {%- endif -%}
        {%- code finishFieldsMask := false -%}
        {%- if field.fieldMask != nil -%}
            {%- code
            // Commented for now. compiler does the same without additional complexity
            // if field.fieldMask.isArith {
            //    res, err := strconv.Atoi(field.fieldMask.name)
            //    if err != nil {
            //        log.Panicf("constant field mask %q failed to parse as int - %v", field.fieldMask.name, err)
            //    }
            //    if res&(1<<field.BitNumber) == 0 {
            //        continue
            //    }
            // } else {
            finishFieldsMask = true -%}
if {%s= formatNatArg(struct_.Fields, *field.fieldMask) %} & (1<<{%v field.BitNumber %}) != 0 {
            {%- code // } -%}
        {%- endif -%}
        {%- if field.recursive -%}
if item.{%s= field.goName %} == nil {
    var value {%s= field.t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false) %}
    item.{%s= field.goName %} = &value
}
        {%- endif -%}
        {%- code
            last := i == len(struct_.Fields)-1 && !finishFieldsMask
            lastWritten = lastWritten || last
        -%}
{%s= field.t.TypeRandomCode(bytesVersion, directImports, struct_.wr.ins, "item."+field.goName, formatNatArgs(struct_.Fields, field.natArgs), field.recursive) %}
        {%- if finishFieldsMask -%}
} else { {%s= field.t.TypeResettingCode(bytesVersion, directImports, struct_.wr.ins, fmt.Sprintf("item.%s", field.goName), field.recursive) %} }
        {%- endif -%}
    {%- endfor -%}
{%- endfunc -%}

{%- func (struct_ *TypeRWStruct)writeFields(bytesVersion bool, directImports *DirectImports) -%}
    {%- if struct_.isTypeDef() -%}
        {%- code field := struct_.Fields[0] -%}
ptr := (*{%s= field.t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false) %})(item)
{%s= field.t.TypeWritingCode(bytesVersion, directImports, struct_.wr.ins, "ptr", field.Bare(), formatNatArgs(struct_.Fields, field.natArgs), true, true) %}
        {%- return -%}
    {%- endif -%}
    {%- code lastWritten := false -%}
    {%- for i, field := range struct_.Fields -%}
        {%- if field.t.IsTrueType() -%}{%- continue -%}{%- endif -%}
        {%- code finishFieldsMask := false -%}
        {%- if field.fieldMask != nil -%}
            {%- code
            // Commented for now. compiler does the same without additional complexity
            // if field.fieldMask.isArith {
            //    res, err := strconv.Atoi(field.fieldMask.name)
            //    if err != nil {
            //        log.Panicf("constant field mask %q failed to parse as int - %v", field.fieldMask.name, err)
            //    }
            //    if res&(1<<field.BitNumber) == 0 {
            //        continue
            //    }
            // } else {
            finishFieldsMask = true -%}
if {%s= formatNatArg(struct_.Fields, *field.fieldMask) %} & (1<<{%v field.BitNumber %}) != 0 {
            {%- code // } -%}
        {%- endif -%}
        {%- code
            last := i == len(struct_.Fields)-1 && !finishFieldsMask
            lastWritten = lastWritten || last
        -%}
    {%s= field.t.TypeWritingCode(bytesVersion, directImports, struct_.wr.ins, fmt.Sprintf("item.%s", field.goName), field.Bare(), formatNatArgs(struct_.Fields, field.natArgs), field.recursive, last) %}
        {%- if finishFieldsMask -%}
}
        {%- endif -%}
    {%- endfor -%}
    {%- if !lastWritten -%}
return w, nil
    {%- endif -%}
{%- endfunc -%}

{%- func (struct_ *TypeRWStruct)readFields(bytesVersion bool, directImports *DirectImports) -%}
    {%- if struct_.isTypeDef() -%}
        {%- code field := struct_.Fields[0] -%}
ptr := (*{%s= field.t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false) %})(item)
{%s= field.t.TypeReadingCode(bytesVersion, directImports, struct_.wr.ins, "ptr", field.Bare(), formatNatArgs(struct_.Fields, field.natArgs), true, true) %}
        {%- return -%}
    {%- endif -%}
    {%- code lastWritten := false -%}
    {%- for i, field := range struct_.Fields -%}
        {%- if field.t.IsTrueType() -%} {%- continue -%} {%- endif -%}
        {%- code finishFieldsMask := false -%}
        {%- if field.fieldMask != nil -%}
            {%- code
            // Commented for now. compiler does the same without additional complexity
            // if field.fieldMask.isArith {
            //    res, err := strconv.Atoi(field.fieldMask.name)
            //    if err != nil {
            //        log.Panicf("constant field mask %q failed to parse as int - %v", field.fieldMask.name, err)
            //    }
            //    if res&(1<<field.BitNumber) == 0 {
            //        continue
            //    }
            // } else {
            finishFieldsMask = true -%}
if {%s= formatNatArg(struct_.Fields, *field.fieldMask) %} & (1<<{%v field.BitNumber %}) != 0 {
            {%- code // } -%}
        {%- endif -%}
        {%- if field.recursive -%}
if item.{%s= field.goName %} == nil {
    var value {%s= field.t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false) %}
    item.{%s= field.goName %} = &value
}
        {%- endif -%}
        {%- code
            last := i == len(struct_.Fields)-1 && !finishFieldsMask
            lastWritten = lastWritten || last
        -%}
{%s= field.t.TypeReadingCode(bytesVersion, directImports, struct_.wr.ins, "item."+field.goName, field.Bare(), formatNatArgs(struct_.Fields, field.natArgs), field.recursive, last) %}
        {%- if finishFieldsMask -%}
} else { {%s= field.t.TypeResettingCode(bytesVersion, directImports, struct_.wr.ins, fmt.Sprintf("item.%s", field.goName), field.recursive) %} }
        {%- endif -%}
    {%- endfor -%}
    {%- if !lastWritten -%}
return w, nil
    {%- endif -%}
{%- endfunc -%}
