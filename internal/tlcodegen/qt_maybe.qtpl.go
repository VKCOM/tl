// Copyright 2022 V Kontakte LLC
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Code generated by qtc from "qt_maybe.qtpl". DO NOT EDIT.
// See https://github.com/valyala/quicktemplate for details.

package tlcodegen

import (
	"fmt"

	qtio422016 "io"

	qt422016 "github.com/valyala/quicktemplate"
)

var (
	_ = qtio422016.Copy
	_ = qt422016.AcquireByteBuffer
)

func (maybe *TypeRWMaybe) StreamGenerateCode(qw422016 *qt422016.Writer, bytesVersion bool, directImports *DirectImports) {
	goName := addBytes(maybe.wr.goGlobalName, bytesVersion)
	elementTypeString := maybe.element.t.TypeString2(bytesVersion, directImports, maybe.wr.ins, false, false)
	natArgsDecl := formatNatArgsDecl(maybe.wr.NatParams)
	natArgsCall := formatNatArgsDeclCall(maybe.wr.NatParams)
	emptyTag := fmt.Sprintf("%#x", maybe.emptyTag)
	okTag := fmt.Sprintf("%#x", maybe.okTag)

	qw422016.N().S(`type `)
	qw422016.N().S(goName)
	qw422016.N().S(` struct {
    Value `)
	qw422016.N().S(elementTypeString)
	qw422016.N().S(` // not deterministic if !Ok
    Ok    bool
}

func (item *`)
	qw422016.N().S(goName)
	qw422016.N().S(`) Reset() {
    item.Ok = false
}
`)
	if maybe.wr.gen.options.GenerateRandomCode {
		qw422016.N().S(`func (item *`)
		qw422016.N().S(goName)
		qw422016.N().S(`) FillRandom(rand basictl.Rand`)
		qw422016.N().S(natArgsDecl)
		qw422016.N().S(`) {
    if basictl.RandomNat(rand) & 1 == 1 {
        item.Ok = true
        `)
		qw422016.N().S(maybe.element.t.TypeRandomCode(bytesVersion, directImports, maybe.wr.ins, "item.Value", formatNatArgs(nil, maybe.element.natArgs), false))
		qw422016.N().S(`
    } else {
        item.Ok = false
    }
}
`)
	}
	qw422016.N().S(`
func (item *`)
	qw422016.N().S(goName)
	qw422016.N().S(`) ReadBoxed(w []byte`)
	qw422016.N().S(natArgsDecl)
	qw422016.N().S(`) (_ []byte, err error) {
    if w, err = basictl.ReadBool(w, &item.Ok, `)
	qw422016.N().S(emptyTag)
	qw422016.N().S(`, `)
	qw422016.N().S(okTag)
	qw422016.N().S(`); err != nil {
        return w, err
    }
    if item.Ok {
        `)
	qw422016.N().S(maybe.element.t.TypeReadingCode(bytesVersion, directImports, maybe.wr.ins, "item.Value", maybe.element.Bare(), formatNatArgs(nil, maybe.element.natArgs), false, true))
	qw422016.N().S(`
    }
    return w, nil
}


func (item *`)
	qw422016.N().S(goName)
	qw422016.N().S(`) WriteBoxed(w []byte`)
	qw422016.N().S(natArgsDecl)
	qw422016.N().S(`) (_ []byte, err error) {
    if item.Ok {
        w = basictl.NatWrite(w, `)
	qw422016.N().S(okTag)
	qw422016.N().S(`)
        `)
	qw422016.N().S(maybe.element.t.TypeWritingCode(bytesVersion, directImports, maybe.wr.ins, "item.Value", maybe.element.Bare(), formatNatArgs(nil, maybe.element.natArgs), false, true))
	qw422016.N().S(`
    }
    return basictl.NatWrite(w, `)
	qw422016.N().S(emptyTag)
	qw422016.N().S(`), nil
}

func `)
	qw422016.N().S(goName)
	qw422016.N().S(`__ReadJSON(item *`)
	qw422016.N().S(goName)
	qw422016.N().S(`, j interface{}`)
	qw422016.N().S(natArgsDecl)
	qw422016.N().S(`) error { return item.readJSON(j`)
	qw422016.N().S(natArgsCall)
	qw422016.N().S(`); }
func (item *`)
	qw422016.N().S(goName)
	qw422016.N().S(`) readJSON(j interface{}`)
	qw422016.N().S(natArgsDecl)
	qw422016.N().S(`) error {
  _ok, _jvalue, err := `)
	qw422016.N().S(maybe.wr.gen.InternalPrefix())
	qw422016.N().S(`JsonReadMaybe("`)
	maybe.wr.tlName.StreamString(qw422016)
	qw422016.N().S(`", j)
  if err != nil {
    return err
  }
  item.Ok = _ok
  if _ok {
    `)
	qw422016.N().S(maybe.element.t.TypeJSONReadingCode(bytesVersion, directImports, maybe.wr.ins, "_jvalue", "item.Value", formatNatArgs(nil, maybe.element.natArgs), false))
	qw422016.N().S(`
  }
  return nil
}

func (item *`)
	qw422016.N().S(goName)
	qw422016.N().S(`) WriteJSON(w []byte`)
	qw422016.N().S(natArgsDecl)
	qw422016.N().S(`) (_ []byte, err error) {
    return item.WriteJSONOpt(false, w`)
	qw422016.N().S(natArgsCall)
	qw422016.N().S(`)
}
func (item *`)
	qw422016.N().S(goName)
	qw422016.N().S(`) WriteJSONOpt(short bool, w []byte`)
	qw422016.N().S(natArgsDecl)
	qw422016.N().S(`) (_ []byte, err error) {
  if !item.Ok {
    return append(w, "{}"...), nil
  }
  w = append(w, `)
	qw422016.N().S("`")
	qw422016.N().S(`{"ok":true`)
	qw422016.N().S("`")
	qw422016.N().S(`...)
`)
	if maybe.element.t.TypeJSONEmptyCondition(bytesVersion, "item.Value", false) != "" {
		qw422016.N().S(`  if `)
		qw422016.N().S(maybe.element.t.TypeJSONEmptyCondition(bytesVersion, "item.Value", false))
		qw422016.N().S(` {
`)
	}
	qw422016.N().S(`    w = basictl.JSONAddCommaIfNeeded(w)
    w = append(w, `)
	qw422016.N().S("`")
	qw422016.N().S(`"value":`)
	qw422016.N().S("`")
	qw422016.N().S(`...)
  `)
	qw422016.N().S(maybe.element.t.TypeJSONWritingCode(bytesVersion, directImports, maybe.wr.ins, "item.Value", formatNatArgs(nil, maybe.element.natArgs), false))
	qw422016.N().S(`
`)
	if maybe.element.t.TypeJSONEmptyCondition(bytesVersion, "item.Value", false) != "" {
		qw422016.N().S(`    }
`)
	}
	qw422016.N().S(`  return append(w, '}'), nil
}
`)
	if len(maybe.wr.NatParams) == 0 {
		qw422016.N().S(`
func (item `)
		qw422016.N().S(goName)
		qw422016.N().S(`) String(`)
		qw422016.N().S(formatNatArgsDeclNoComma(maybe.wr.NatParams))
		qw422016.N().S(`) string {
    w, err := item.WriteJSON(nil`)
		qw422016.N().S(natArgsCall)
		qw422016.N().S(`)
    if err != nil {
        return err.Error()
    }
    return string(w) 
}

`)
	}
	qw422016.N().S(`
`)
}

func (maybe *TypeRWMaybe) WriteGenerateCode(qq422016 qtio422016.Writer, bytesVersion bool, directImports *DirectImports) {
	qw422016 := qt422016.AcquireWriter(qq422016)
	maybe.StreamGenerateCode(qw422016, bytesVersion, directImports)
	qt422016.ReleaseWriter(qw422016)
}

func (maybe *TypeRWMaybe) GenerateCode(bytesVersion bool, directImports *DirectImports) string {
	qb422016 := qt422016.AcquireByteBuffer()
	maybe.WriteGenerateCode(qb422016, bytesVersion, directImports)
	qs422016 := string(qb422016.B)
	qt422016.ReleaseByteBuffer(qb422016)
	return qs422016
}
