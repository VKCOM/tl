// Code generated by qtc from "qt_maybe.qtpl". DO NOT EDIT.
// See https://github.com/valyala/quicktemplate for details.

package tlcodegen

import "fmt"

import (
	qtio422016 "io"

	qt422016 "github.com/valyala/quicktemplate"
)

var (
	_ = qtio422016.Copy
	_ = qt422016.AcquireByteBuffer
)

func (maybe *TypeRWMaybe) StreamGenerateCode(qw422016 *qt422016.Writer, bytesVersion bool, directImports *DirectImports) {
	goName := addBytes(maybe.wr.goGlobalName, bytesVersion)
	tlName := maybe.wr.tlName.String()
	elementTypeString := maybe.element.t.TypeString2(bytesVersion, directImports, maybe.wr.ins, false, false)
	natArgsDecl := formatNatArgsDecl(maybe.wr.NatParams)
	natArgsCall := formatNatArgsDeclCall(maybe.wr.NatParams)
	emptyTag := fmt.Sprintf("%#x", maybe.emptyTag)
	okTag := fmt.Sprintf("%#x", maybe.okTag)
	writeElementNeedsError := maybe.element.t.hasErrorInWriteMethods
	isSizeConstant, trivialSize := maybe.element.t.trw.tl2TrivialSize("item.Value", false, maybe.element.recursive)

	qw422016.N().S(`type `)
	qw422016.N().S(goName)
	qw422016.N().S(` struct {
    Value `)
	qw422016.N().S(elementTypeString)
	qw422016.N().S(` // not deterministic if !Ok
    Ok    bool
}

func (item *`)
	qw422016.N().S(goName)
	qw422016.N().S(`) Reset() {
    item.Ok = false
}
`)
	if maybe.wr.gen.options.GenerateRandomCode {
		qw422016.N().S(`func (item *`)
		qw422016.N().S(goName)
		qw422016.N().S(`) FillRandom(rg *basictl.RandGenerator`)
		qw422016.N().S(natArgsDecl)
		qw422016.N().S(`) {
    if basictl.RandomUint(rg) & 1 == 1 {
        item.Ok = true
        `)
		qw422016.N().S(maybe.element.t.TypeRandomCode(bytesVersion, directImports, maybe.wr.ins, "item.Value", formatNatArgs(nil, maybe.element.natArgs), false))
		qw422016.N().S(`
    } else {
        item.Ok = false
    }
}
`)
	}
	qw422016.N().S(`
func (item *`)
	qw422016.N().S(goName)
	qw422016.N().S(`) ReadBoxed(w []byte`)
	qw422016.N().S(natArgsDecl)
	qw422016.N().S(`) (_ []byte, err error) {
    if w, err = basictl.ReadBool(w, &item.Ok, `)
	qw422016.N().S(emptyTag)
	qw422016.N().S(`, `)
	qw422016.N().S(okTag)
	qw422016.N().S(`); err != nil {
        return w, err
    }
    if item.Ok {
        `)
	qw422016.N().S(maybe.element.t.TypeReadingCode(bytesVersion, directImports, maybe.wr.ins, "item.Value", maybe.element.Bare(), formatNatArgs(nil, maybe.element.natArgs), false, true))
	qw422016.N().S(`
    }
    return w, nil
}

func (item *`)
	qw422016.N().S(goName)
	qw422016.N().S(`) WriteBoxedGeneral(w []byte`)
	qw422016.N().S(natArgsDecl)
	qw422016.N().S(`) (_ []byte, err error) {
`)
	if writeElementNeedsError {
		qw422016.N().S(`    return item.WriteBoxed(w`)
		qw422016.N().S(natArgsCall)
		qw422016.N().S(`)
`)
	} else {
		qw422016.N().S(`    return item.WriteBoxed(w`)
		qw422016.N().S(natArgsCall)
		qw422016.N().S(`), nil
`)
	}
	qw422016.N().S(`}

func (item *`)
	qw422016.N().S(goName)
	qw422016.N().S(`) WriteBoxed(w []byte`)
	qw422016.N().S(natArgsDecl)
	qw422016.N().S(`) `)
	qw422016.N().S(wrapWithError(writeElementNeedsError, "[]byte"))
	qw422016.N().S(` {
    if item.Ok {
        w = basictl.NatWrite(w, `)
	qw422016.N().S(okTag)
	qw422016.N().S(`)
        `)
	qw422016.N().S(maybe.element.t.TypeWritingCode(bytesVersion, directImports, maybe.wr.ins, "item.Value", maybe.element.Bare(), formatNatArgs(nil, maybe.element.natArgs), false, true, writeElementNeedsError))
	qw422016.N().S(`
    }
`)
	if writeElementNeedsError {
		qw422016.N().S(`    return basictl.NatWrite(w, `)
		qw422016.N().S(emptyTag)
		qw422016.N().S(`), nil
`)
	} else {
		qw422016.N().S(`    return basictl.NatWrite(w, `)
		qw422016.N().S(emptyTag)
		qw422016.N().S(`)
`)
	}
	qw422016.N().S(`}

`)
	if maybe.wr.gen.options.GenerateTL2 {
		if maybe.wr.wantsTL2 {
			qw422016.N().S(`func (item *`)
			qw422016.N().S(goName)
			qw422016.N().S(`) CalculateLayout(sizes []int`)
			qw422016.N().S(natArgsDecl)
			qw422016.N().S(`) []int {
    sizePosition := len(sizes)
    sizes = append(sizes, 0)
    if item.Ok {
        sizes[sizePosition] += 1
        sizes[sizePosition] += basictl.TL2CalculateSize(1)
`)
			if len(trivialSize) == 0 && !maybe.element.t.IsTrueType() {
				qw422016.N().S(`        currentPosition := len(sizes)
`)
			}
			nonEmptyCondition := maybe.element.t.TypeJSONEmptyCondition(false, "item.Value", maybe.element.recursive)

			if nonEmptyCondition != "" {
				qw422016.N().S(`        if `)
				qw422016.N().S(nonEmptyCondition)
				qw422016.N().S(` {
`)
			}
			qw422016.N().S(`        `)
			qw422016.N().S(maybe.element.t.CalculateLayoutCall(directImports, bytesVersion, "sizes", "item.Value", false, maybe.wr.ins, maybe.element.recursive, formatNatArgs(nil, maybe.element.natArgs)))
			qw422016.N().S(`
`)
			sizeValue := "sizes[currentPosition]"
			if len(trivialSize) != 0 {
				sizeValue = trivialSize
			}

			if !isSizeConstant {
				qw422016.N().S(`        if `)
				qw422016.N().S(sizeValue)
				qw422016.N().S(` != 0 {
`)
			}
			qw422016.N().S(`            sizes[sizePosition] += `)
			qw422016.N().S(sizeValue)
			qw422016.N().S(`
`)
			if maybe.element.t.trw.isSizeWrittenInData() {
				qw422016.N().S(`            sizes[sizePosition] += basictl.TL2CalculateSize(`)
				qw422016.N().S(sizeValue)
				qw422016.N().S(`)
`)
			}
			if !isSizeConstant {
				qw422016.N().S(`        }
`)
			}
			if nonEmptyCondition != "" {
				qw422016.N().S(`        }
`)
			}
			qw422016.N().S(`    }
    return sizes
}

func (item *`)
			qw422016.N().S(goName)
			qw422016.N().S(`) InternalWriteTL2(w []byte, sizes []int`)
			qw422016.N().S(natArgsDecl)
			qw422016.N().S(`) ([]byte, []int) {
    currentSize := sizes[0]
    sizes = sizes[1:]

    w = basictl.TL2WriteSize(w, currentSize)
    if currentSize == 0 {
        return w, sizes
    }

    if item.Ok {
        currentPosition := len(w)
        w = append(w, 1)
        w = basictl.TL2WriteSize(w, 1)
`)
			sizeValue = "sizes[0]"
			if len(trivialSize) != 0 {
				sizeValue = trivialSize
			}
			nonEmptyCondition = maybe.element.t.TypeJSONEmptyCondition(false, "item.Value", maybe.element.recursive)

			if nonEmptyCondition != "" {
				qw422016.N().S(`        if `)
				qw422016.N().S(nonEmptyCondition)
				qw422016.N().S(` {
`)
			}
			qw422016.N().S(`        if `)
			qw422016.N().S(sizeValue)
			qw422016.N().S(` != 0 {
        w[currentPosition] |= (1 << 1)
        `)
			qw422016.N().S(maybe.element.t.WriteTL2Call(directImports, bytesVersion, "sizes", "w", "item.Value", false, maybe.wr.ins, maybe.element.recursive, formatNatArgs(nil, maybe.element.natArgs)))
			qw422016.N().S(`
`)
			if len(trivialSize) == 0 {
				qw422016.N().S(`        } else {
            sizes = sizes[1:]
        }
`)
			} else {
				qw422016.N().S(`        }
`)
			}
			if nonEmptyCondition != "" {
				qw422016.N().S(`        }
`)
			}
			qw422016.N().S(`    }
    return w, sizes
}
`)
		}
		qw422016.N().S(`
func (item *`)
		qw422016.N().S(goName)
		qw422016.N().S(`) InternalReadTL2(r []byte`)
		qw422016.N().S(natArgsDecl)
		qw422016.N().S(`) (_ []byte, err error) {
`)
		if !maybe.wr.wantsTL2 {
			qw422016.N().S(`    return r, `)
			qw422016.N().S(maybe.wr.gen.InternalPrefix())
			qw422016.N().S(`ErrorTL2SerializersNotGenerated(`)
			qw422016.N().Q(tlName)
			qw422016.N().S(`)
`)
		} else {
			qw422016.N().S(`    saveR := r
    currentSize := 0
    if r, currentSize, err = basictl.TL2ParseSize(r); err != nil { return r, err }
    shift := currentSize + basictl.TL2CalculateSize(currentSize)

    if currentSize == 0 {
        item.Ok = false
    } else {
        var block byte
        if r, err = basictl.ByteReadTL2(r, &block); err != nil { return r, err }
        if block & 1 == 0 {
            return r, basictl.TL2Error("must have constructor bytes")
        }
        var index int
        if r, index, err = basictl.TL2ParseSize(r); err != nil { return r, err }
        if index != 1 {
            return r, basictl.TL2Error("expected 1")
        }
        item.Ok = true
        if block & (1 << 1) != 0 {
`)
			if maybe.element.recursive {
				qw422016.N().S(`        if item.Value == nil {
            var newValue `)
				qw422016.N().S(maybe.element.t.TypeString2(bytesVersion, directImports, maybe.wr.ins, false, false))
				qw422016.N().S(`
            item.Value = &newValue
        }
`)
			}
			qw422016.N().S(`        `)
			qw422016.N().S(maybe.element.t.ReadTL2Call(directImports, bytesVersion, "r", "item.Value", false, maybe.wr.ins, maybe.element.recursive, formatNatArgs(nil, maybe.element.natArgs)))
			qw422016.N().S(`
        } else {
        `)
			qw422016.N().S(maybe.element.t.TypeResettingCode(bytesVersion, directImports, maybe.wr.ins, "item.Value", maybe.element.recursive))
			qw422016.N().S(`
        }
    }
    if len(saveR) < len(r) + shift {
        r = saveR[shift:]
    }
`)
		}
		qw422016.N().S(`    return r, nil
}

`)
	}
	if maybe.wr.gen.options.GenerateLegacyJsonRead {
		qw422016.N().S(`func (item *`)
		qw422016.N().S(goName)
		qw422016.N().S(`) ReadJSONLegacy(legacyTypeNames bool, j interface{}`)
		qw422016.N().S(natArgsDecl)
		qw422016.N().S(`) error {
  _ok, _jvalue, err := `)
		qw422016.N().S(maybe.wr.gen.InternalPrefix())
		qw422016.N().S(`JsonReadMaybe(`)
		qw422016.N().Q(tlName)
		qw422016.N().S(`, j)
  if err != nil {
    return err
  }
  item.Ok = _ok
  if _ok {
    `)
		qw422016.N().S(maybe.element.t.TypeJSONReadingCode(bytesVersion, directImports, maybe.wr.ins, "_jvalue", "item.Value", formatNatArgs(nil, maybe.element.natArgs), false))
		qw422016.N().S(`
  }
  return nil
}

`)
	}
	qw422016.N().S(`func (item *`)
	qw422016.N().S(goName)
	qw422016.N().S(`) ReadJSON(legacyTypeNames bool, in *basictl.JsonLexer`)
	qw422016.N().S(natArgsDecl)
	qw422016.N().S(`) error {
  _ok, _jvalue, err := `)
	qw422016.N().S(maybe.wr.gen.InternalPrefix())
	qw422016.N().S(`Json2ReadMaybe(`)
	qw422016.N().Q(tlName)
	qw422016.N().S(`, in)
  if err != nil {
    return err
  }
  item.Ok = _ok
  if _ok {
    var in2Pointer *basictl.JsonLexer
    if _jvalue != nil {
        in2 := basictl.JsonLexer{Data: _jvalue}
        in2Pointer = &in2
    }
    `)
	qw422016.N().S(maybe.element.t.TypeJSON2ReadingCode(bytesVersion, directImports, maybe.wr.ins, "in2Pointer", "item.Value", formatNatArgs(nil, maybe.element.natArgs), false))
	qw422016.N().S(`
  }
  return nil
}

// This method is general version of WriteJSON, use it instead!
func (item *`)
	qw422016.N().S(goName)
	qw422016.N().S(`) WriteJSONGeneral(w []byte`)
	qw422016.N().S(natArgsDecl)
	qw422016.N().S(`) (_ []byte, err error) {
`)
	if writeElementNeedsError {
		qw422016.N().S(`    return item.WriteJSONOpt(true, false, w`)
		qw422016.N().S(natArgsCall)
		qw422016.N().S(`)
`)
	} else {
		qw422016.N().S(`    return item.WriteJSONOpt(true, false, w`)
		qw422016.N().S(natArgsCall)
		qw422016.N().S(`), nil
`)
	}
	qw422016.N().S(`}

func (item *`)
	qw422016.N().S(goName)
	qw422016.N().S(`) WriteJSON(w []byte`)
	qw422016.N().S(natArgsDecl)
	qw422016.N().S(`) `)
	qw422016.N().S(wrapWithError(writeElementNeedsError, "[]byte"))
	qw422016.N().S(` {
    return item.WriteJSONOpt(true, false, w`)
	qw422016.N().S(natArgsCall)
	qw422016.N().S(`)
}
func (item *`)
	qw422016.N().S(goName)
	qw422016.N().S(`) WriteJSONOpt(newTypeNames bool, short bool, w []byte`)
	qw422016.N().S(natArgsDecl)
	qw422016.N().S(`) `)
	qw422016.N().S(wrapWithError(writeElementNeedsError, "[]byte"))
	qw422016.N().S(` {
    if !item.Ok {
`)
	if writeElementNeedsError {
		qw422016.N().S(`        return append(w, "{}"...), nil
`)
	} else {
		qw422016.N().S(`        return append(w, "{}"...)
`)
	}
	qw422016.N().S(`    }
    w = append(w, `)
	qw422016.N().S("`")
	qw422016.N().S(`{"ok":true`)
	qw422016.N().S("`")
	qw422016.N().S(`...)
`)
	emptyCondition := maybe.element.t.TypeJSONEmptyCondition(bytesVersion, "item.Value", false)

	if emptyCondition != "" {
		qw422016.N().S(`    if `)
		qw422016.N().S(emptyCondition)
		qw422016.N().S(` {
`)
	}
	qw422016.N().S(`    w = append(w, `)
	qw422016.N().S("`")
	qw422016.N().S(`,"value":`)
	qw422016.N().S("`")
	qw422016.N().S(`...)
    `)
	qw422016.N().S(maybe.element.t.TypeJSONWritingCode(bytesVersion, directImports, maybe.wr.ins, "item.Value", formatNatArgs(nil, maybe.element.natArgs), false, writeElementNeedsError))
	qw422016.N().S(`
`)
	if emptyCondition != "" {
		qw422016.N().S(`    }
`)
	}
	if writeElementNeedsError {
		qw422016.N().S(`    return append(w, '}'), nil
`)
	} else {
		qw422016.N().S(`    return append(w, '}')
`)
	}
	qw422016.N().S(`}
`)
	if len(maybe.wr.NatParams) == 0 {
		qw422016.N().S(`
func (item `)
		qw422016.N().S(goName)
		qw422016.N().S(`) String(`)
		qw422016.N().S(formatNatArgsDeclNoComma(maybe.wr.NatParams))
		qw422016.N().S(`) string {
`)
		if writeElementNeedsError {
			qw422016.N().S(`    w, err := item.WriteJSON(nil`)
			qw422016.N().S(natArgsCall)
			qw422016.N().S(`)
    if err != nil {
        return err.Error()
    }
    return string(w)
`)
		} else {
			qw422016.N().S(`    return string(item.WriteJSON(nil`)
			qw422016.N().S(natArgsCall)
			qw422016.N().S(`))
`)
		}
		qw422016.N().S(`}

`)
	}
	qw422016.N().S(`
`)
}

func (maybe *TypeRWMaybe) WriteGenerateCode(qq422016 qtio422016.Writer, bytesVersion bool, directImports *DirectImports) {
	qw422016 := qt422016.AcquireWriter(qq422016)
	maybe.StreamGenerateCode(qw422016, bytesVersion, directImports)
	qt422016.ReleaseWriter(qw422016)
}

func (maybe *TypeRWMaybe) GenerateCode(bytesVersion bool, directImports *DirectImports) string {
	qb422016 := qt422016.AcquireByteBuffer()
	maybe.WriteGenerateCode(qb422016, bytesVersion, directImports)
	qs422016 := string(qb422016.B)
	qt422016.ReleaseByteBuffer(qb422016)
	return qs422016
}
