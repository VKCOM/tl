// Code generated by qtc from "qt_tljson_html.qtpl". DO NOT EDIT.
// See https://github.com/valyala/quicktemplate for details.

package tlcodegen

import "fmt"

import "strings"

import (
	qtio422016 "io"

	qt422016 "github.com/valyala/quicktemplate"
)

var (
	_ = qtio422016.Copy
	_ = qt422016.AcquireByteBuffer
)

func streamtlJSON(qw422016 *qt422016.Writer, gen *Gen2, tlgenVersion string) {
	qw422016.N().S(`<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>TL JSON help</title>
  </head>
  <body>
    <h1>Schema</h1>
    <ul>
      <li>tlgen version: `)
	qw422016.E().S(tlgenVersion)
	qw422016.N().S(`</li>
`)
	if gen.options.SchemaURL != "" {
		qw422016.N().S(`      <li><abbr>TL</abbr> <a href="`)
		qw422016.E().S(gen.options.SchemaURL)
		qw422016.N().S(`">schema</a></li>
`)
	}
	qw422016.N().S(`      <li><abbr>TL</abbr> ⟷ <abbr>JSON</abbr> mapping rules: <a href="https://github.com/VKCOM/tl/blob/master/TLJSON.md">TLJSON.md</a></li>
    </ul>
    <h1>Functions</h1>
    <ul>
`)
	for _, trww := range gen.generatedTypesList {
		if fun, ok := trww.trw.(*TypeRWStruct); ok && fun.ResultType != nil {
			qw422016.N().S(`      <li>
        <a href="#`)
			qw422016.E().S(trww.goGlobalName)
			qw422016.N().S(`">
        <code>`)
			qw422016.E().S(trww.JSONHelpString())
			qw422016.N().S(`</code></a>
        → <code>`)
			streamprintJSONHelpType2(qw422016, gen, fun.ResultType, false, fun.Fields, fun.ResultNatArgs)
			qw422016.N().S(`</code>
      </li>
`)
		}
	}
	qw422016.N().S(`    </ul>
    <h1>Types</h1>
<h2 id="#">#</h2>
Builtin type <code>#</code>. Represents <code>uint32</code>. Can be used as field mask or collection size.
`)
	for _, trww := range gen.generatedTypesList {
		streamprintHTMLHelp(qw422016, gen, trww)
		qw422016.N().S(`
`)
	}
	qw422016.N().S(`  </body>
</html>
`)
}

func writetlJSON(qq422016 qtio422016.Writer, gen *Gen2, tlgenVersion string) {
	qw422016 := qt422016.AcquireWriter(qq422016)
	streamtlJSON(qw422016, gen, tlgenVersion)
	qt422016.ReleaseWriter(qw422016)
}

func tlJSON(gen *Gen2, tlgenVersion string) string {
	qb422016 := qt422016.AcquireByteBuffer()
	writetlJSON(qb422016, gen, tlgenVersion)
	qs422016 := string(qb422016.B)
	qt422016.ReleaseByteBuffer(qb422016)
	return qs422016
}

func streamprintJSONHelpType2(qw422016 *qt422016.Writer, gen *Gen2, trww *TypeRWWrapper, bare bool, fields []Field, natArgs []ActualNatArg) {
	switch trw := trww.trw.(type) {
	case *TypeRWBool:
		qw422016.E().S("<bool>")
	case *TypeRWPrimitive:
		qw422016.E().S("<")
		qw422016.E().S(trw.goType)
		qw422016.E().S(">")
	case *TypeRWMaybe:
		streammakeRef(qw422016, trww.goGlobalName, trww.JSONHelpFullType(bare, fields, natArgs))
	case *TypeRWStruct:
		if trw.isTypeDef() {
			streamprintJSONHelpType2(qw422016, gen, trw.Fields[0].t, trw.Fields[0].bare, fields, trww.transformNatArgsToChild(natArgs, trw.Fields[0].natArgs))
		} else if trw.wr.IsTrueType() {
			qw422016.E().S("{}")
		} else {
			streammakeRef(qw422016, trww.goGlobalName, trww.JSONHelpFullType(bare, fields, natArgs))
		}
	case *TypeRWUnion:
		streammakeRef(qw422016, trww.goGlobalName, trww.JSONHelpFullType(bare, fields, natArgs))
	case *TypeRWBrackets:
		elementNatArgs := trww.transformNatArgsToChild(natArgs, trw.element.natArgs)

		switch {
		case trw.dictLike:
			qw422016.E().S("{")
			streamprintJSONHelpType2(qw422016, gen, trw.dictKeyField.t, trw.dictKeyField.bare, fields, trw.element.t.transformNatArgsToChild(elementNatArgs, trw.dictKeyField.natArgs))
			qw422016.E().S(": ")
			streamprintJSONHelpType2(qw422016, gen, trw.dictValueField.t, trw.dictValueField.bare, fields, trw.element.t.transformNatArgsToChild(elementNatArgs, trw.dictValueField.natArgs))
			qw422016.E().S("}")
		case trw.vectorLike:
			qw422016.E().S("[")
			streamprintJSONHelpType2(qw422016, gen, trw.element.t, trw.element.bare, fields, elementNatArgs)
			qw422016.E().S(", ...]")
		case trw.dynamicSize:
			qw422016.E().S("[")
			qw422016.E().S(trww.JSONHelpNatArg(fields, natArgs[len(natArgs)-1]))
			qw422016.E().S(" × ")
			streamprintJSONHelpType2(qw422016, gen, trw.element.t, trw.element.bare, fields, elementNatArgs)
			qw422016.E().S("]")
		default:
			qw422016.E().S("[")
			qw422016.E().V(trw.size)
			qw422016.E().S(" × ")
			streamprintJSONHelpType2(qw422016, gen, trw.element.t, trw.element.bare, fields, elementNatArgs)
			qw422016.E().S("]")
		}
	}
}

func writeprintJSONHelpType2(qq422016 qtio422016.Writer, gen *Gen2, trww *TypeRWWrapper, bare bool, fields []Field, natArgs []ActualNatArg) {
	qw422016 := qt422016.AcquireWriter(qq422016)
	streamprintJSONHelpType2(qw422016, gen, trww, bare, fields, natArgs)
	qt422016.ReleaseWriter(qw422016)
}

func printJSONHelpType2(gen *Gen2, trww *TypeRWWrapper, bare bool, fields []Field, natArgs []ActualNatArg) string {
	qb422016 := qt422016.AcquireByteBuffer()
	writeprintJSONHelpType2(qb422016, gen, trww, bare, fields, natArgs)
	qs422016 := string(qb422016.B)
	qt422016.ReleaseByteBuffer(qb422016)
	return qs422016
}

func streamprintHTMLHelp(qw422016 *qt422016.Writer, gen *Gen2, trww *TypeRWWrapper) {
	if trw, ok := trww.trw.(*TypeRWStruct); ok && ((trw.ResultType == nil && trww.IsTrueType()) || trw.isTypeDef()) {
		return
	}
	if _, ok := trww.trw.(*TypeRWBool); ok {
		return
	}
	if _, ok := trww.trw.(*TypeRWBrackets); ok {
		return
	}
	if _, ok := trww.trw.(*TypeRWPrimitive); ok {
		return
	}

	qw422016.N().S(`<h2 id="`)
	qw422016.E().S(trww.goGlobalName)
	qw422016.N().S(`">`)
	qw422016.E().S(trww.JSONHelpString())
	qw422016.N().S(`</h2>
`)
	if len(trww.origTL) == 1 && trww.origTL[0].CommentBefore != "" {
		for _, line := range strings.Split(trww.origTL[0].CommentBefore, "\n") {
			qw422016.N().S(`    <code style="color:DarkCyan">`)
			qw422016.E().S(line)
			qw422016.N().S(`</code></br>
`)
		}
	}
	qw422016.N().S(`
`)
	if len(trww.NatParams) != 0 {
		qw422016.N().S(`External # (nat) arguments: <b>`)
		qw422016.E().S(strings.Join(trww.NatParams, ", "))
		qw422016.N().S(`</b>
`)
	}
	qw422016.N().S(`<p></p>
`)
	switch trw := trww.trw.(type) {
	case *TypeRWPrimitive:
		qw422016.N().S(`<dl>
  <dt>JSON</dt>
  <dd>`)
		qw422016.E().S(trw.goType)
		qw422016.N().S(`</dd>
</dl>
`)
	case *TypeRWMaybe:
		qw422016.N().S(`<dl>
  <dt>JSON</dt>
  <dd>
    <ul>
      <li><code>{}</code></li>
      <li><code>`)
		qw422016.E().S(`{"value": `)
		streamprintJSONHelpType2(qw422016, gen, trw.element.t, trw.element.bare, nil, trw.element.natArgs)
		qw422016.E().S("}")
		qw422016.N().S(`</code></li>
    </ul>
  </dd>
  <dt>TL</dt>
  <dd>
    <ul>
    <li><code>`)
		qw422016.E().S(trww.origTL[0].String())
		qw422016.N().S(`</code></li>
    <li><code>`)
		qw422016.E().S(trww.origTL[1].String())
		qw422016.N().S(`</code></li>
    </ul>
  </dd>
</dl>
`)
	case *TypeRWStruct:
		if trw.ResultType != nil {
			qw422016.N().S(`  Returns <code>`)
			streamprintJSONHelpType2(qw422016, gen, trw.ResultType, false, trw.Fields, trw.ResultNatArgs)
			qw422016.N().S(`</code>
`)
		}
		qw422016.N().S(`<dl>
  <dt>JSON</dt>
  <dd><code>
`)
		if trw.ResultType != nil && trww.IsTrueType() {
			qw422016.N().S(`    {}
`)
		} else {
			qw422016.N().S(`    {
      <table>
`)
			for i, field := range trw.Fields {
				if field.origTL.CommentBefore != "" {
					for _, line := range strings.Split(field.origTL.CommentBefore, "\n") {
						qw422016.N().S(`          <tr><td colspan="4">
            <code style="color:DarkCyan">`)
						qw422016.E().S(line)
						qw422016.N().S(`</code>
          </td></tr>
`)
					}
				}
				qw422016.N().S(`        <tr>

`)
				if field.t.IsTrueType() {
					qw422016.N().S(`          <td>&nbsp;&nbsp;"`)
					qw422016.E().S(field.originalName)
					qw422016.N().S(`"</td><td>: true`)
					if i != len(trw.Fields)-1 {
						qw422016.N().S(`,`)
					}
					qw422016.N().S(`</td>
`)
				} else {
					qw422016.N().S(`          <td>&nbsp;&nbsp;"`)
					qw422016.E().S(field.originalName)
					qw422016.N().S(`"</td><td>: `)
					streamprintJSONHelpType2(qw422016, gen, field.t, field.bare, trw.Fields, field.natArgs)
					if i != len(trw.Fields)-1 {
						qw422016.N().S(`,`)
					}
					qw422016.N().S(`</td>
`)
				}
				qw422016.N().S(`          <td>`)
				streamjsonCommentFieldMask(qw422016, field.fieldMask, field.BitNumber, trw.Fields)
				qw422016.N().S(`</td>
          <td>
`)
				if field.origTL.CommentRight != "" {
					for _, line := range strings.Split(field.origTL.CommentRight, "\n") {
						qw422016.N().S(`    <code style="color:DarkCyan">`)
						qw422016.E().S(line)
						qw422016.N().S(`</code></td></tr><tr><td colspan="4">
`)
					}
				}
				qw422016.N().S(`          </td>
        </tr>
`)
			}
			qw422016.N().S(`      </table>
    }
`)
		}
		qw422016.N().S(`</code></dd>
  <dt>TL</dt>
  <dd>
    <code>`)
		qw422016.E().S(trww.origTL[0].String())
		qw422016.N().S(`</code>
`)
		if trww.origTL[0].CommentRight != "" {
			for _, line := range strings.Split(trww.origTL[0].CommentRight, "\n") {
				qw422016.N().S(`    <code style="color:DarkCyan">`)
				qw422016.E().S(line)
				qw422016.N().S(`</code></br>
`)
			}
		}
		qw422016.N().S(`  </dd>
</dl>
`)
	case *TypeRWUnion:
		qw422016.N().S(`<dl>
  <dt>JSON</dt>
  <dd><code>
      <table>
`)
		for _, field := range trw.Fields {
			tag := fmt.Sprintf("%08x", field.t.tlTag)

			qw422016.N().S(`            <tr>
`)
			if trw.IsEnum {
				qw422016.N().S(`                <td><span title='Can be also specified as "`)
				qw422016.E().S(field.originalName)
				qw422016.N().S(`" or "#`)
				qw422016.E().S(tag)
				qw422016.N().S(`"' style="color:MediumVioletRed">"`)
				qw422016.E().S(field.originalName)
				qw422016.N().S(`#`)
				qw422016.E().S(tag)
				qw422016.N().S(`"</span></td><td></td>
`)
			} else {
				qw422016.N().S(`                <td>{"type":<span title='Can be also specified as "`)
				qw422016.E().S(field.originalName)
				qw422016.N().S(`" or "#`)
				qw422016.E().S(tag)
				qw422016.N().S(`"' style="color:MediumVioletRed">"`)
				qw422016.E().S(field.originalName)
				qw422016.N().S(`#`)
				qw422016.E().S(tag)
				qw422016.N().S(`"</span>`)
				if !field.t.IsTrueType() {
					qw422016.N().S(`,</td><td>"value":`)
					streammakeRef(qw422016, field.t.goGlobalName, field.t.JSONHelpString())
					qw422016.N().S(`}</td>`)
				} else {
					qw422016.N().S(`}</td><td></td>`)
				}
			}
			qw422016.N().S(`          <td>
`)
			if field.t.origTL[0].CommentRight != "" {
				for _, line := range strings.Split(field.t.origTL[0].CommentRight, "\n") {
					qw422016.N().S(`    <code style="color:DarkCyan">`)
					qw422016.E().S(line)
					qw422016.N().S(`</code></td></tr><tr><td colspan="3">
`)
				}
			}
			qw422016.N().S(`          </td>
        </tr>
`)
		}
		qw422016.N().S(`      </table>
  </code></dd>
  <dt>TL</dt>
  <dd>
    <ul>
`)
		for _, origTL := range trww.origTL {
			qw422016.N().S(`    <li>
    <code>`)
			qw422016.E().S(origTL.String())
			qw422016.N().S(`</code>
    </li>
`)
		}
		qw422016.N().S(`    </ul>
  </dd>
</dl>
`)
	}
}

func writeprintHTMLHelp(qq422016 qtio422016.Writer, gen *Gen2, trww *TypeRWWrapper) {
	qw422016 := qt422016.AcquireWriter(qq422016)
	streamprintHTMLHelp(qw422016, gen, trww)
	qt422016.ReleaseWriter(qw422016)
}

func printHTMLHelp(gen *Gen2, trww *TypeRWWrapper) string {
	qb422016 := qt422016.AcquireByteBuffer()
	writeprintHTMLHelp(qb422016, gen, trww)
	qs422016 := string(qb422016.B)
	qt422016.ReleaseByteBuffer(qb422016)
	return qs422016
}

func streamjsonCommentFieldMask(qw422016 *qt422016.Writer, fm *ActualNatArg, num uint32, fields []Field) {
	if fm == nil {
		return
	}
	if fm.isField {
		qw422016.N().S(`// `)
		qw422016.E().S(fields[fm.FieldIndex].originalName)
		qw422016.N().S(` bit #`)
		qw422016.E().V(num)
		qw422016.N().S(`
`)
	} else if fm.isArith && (fm.Arith.Res&(1<<num)) != 0 {
		qw422016.N().S(`// `)
		qw422016.E().V(fm.Arith.Res)
		qw422016.N().S(` bit #`)
		qw422016.E().V(num)
		qw422016.N().S(` = true
`)
	} else if fm.isArith {
		qw422016.N().S(`// `)
		qw422016.E().V(fm.Arith.Res)
		qw422016.N().S(` bit #`)
		qw422016.E().V(num)
		qw422016.N().S(` = false
`)
	} else {
		qw422016.N().S(`// `)
		qw422016.E().S(fm.name)
		qw422016.N().S(` bit #`)
		qw422016.E().V(num)
		qw422016.N().S(`
`)
	}
}

func writejsonCommentFieldMask(qq422016 qtio422016.Writer, fm *ActualNatArg, num uint32, fields []Field) {
	qw422016 := qt422016.AcquireWriter(qq422016)
	streamjsonCommentFieldMask(qw422016, fm, num, fields)
	qt422016.ReleaseWriter(qw422016)
}

func jsonCommentFieldMask(fm *ActualNatArg, num uint32, fields []Field) string {
	qb422016 := qt422016.AcquireByteBuffer()
	writejsonCommentFieldMask(qb422016, fm, num, fields)
	qs422016 := string(qb422016.B)
	qt422016.ReleaseByteBuffer(qb422016)
	return qs422016
}

func streammakeRef(qw422016 *qt422016.Writer, a string, s string) {
	qw422016.N().S(`<a href="#`)
	qw422016.E().S(a)
	qw422016.N().S(`">`)
	qw422016.E().S(s)
	qw422016.N().S(`</a>`)
}

func writemakeRef(qq422016 qtio422016.Writer, a string, s string) {
	qw422016 := qt422016.AcquireWriter(qq422016)
	streammakeRef(qw422016, a, s)
	qt422016.ReleaseWriter(qw422016)
}

func makeRef(a string, s string) string {
	qb422016 := qt422016.AcquireByteBuffer()
	writemakeRef(qb422016, a, s)
	qs422016 := string(qb422016.B)
	qt422016.ReleaseByteBuffer(qb422016)
	return qs422016
}
