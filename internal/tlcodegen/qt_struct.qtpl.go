// Copyright 2022 V Kontakte LLC
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Code generated by qtc from "qt_struct.qtpl". DO NOT EDIT.
// See https://github.com/valyala/quicktemplate for details.

package tlcodegen

import (
	"fmt"

	qtio422016 "io"

	qt422016 "github.com/valyala/quicktemplate"
)

var (
	_ = qtio422016.Copy
	_ = qt422016.AcquireByteBuffer
)

func (struct_ *TypeRWStruct) StreamGenerateCode(qw422016 *qt422016.Writer, bytesVersion bool, directImports *DirectImports) {
	goName := addBytes(struct_.wr.goGlobalName, bytesVersion)
	tlTag := fmt.Sprintf("%#x", struct_.wr.tlTag)
	natArgsDecl := formatNatArgsDecl(struct_.wr.NatParams)
	natArgsCall := formatNatArgsDeclCall(struct_.wr.NatParams)

	if struct_.wr.unionParent != nil {
		ep := struct_.wr.unionParent.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false)

		if struct_.wr.unionIsEnum {
			qw422016.N().S(`func `)
			qw422016.N().S(goName)
			qw422016.N().S(`() `)
			qw422016.N().S(ep)
			qw422016.N().S(` { return `)
			qw422016.N().S(ep)
			qw422016.N().S(`__MakeEnum(`)
			qw422016.N().D(struct_.wr.unionIndex)
			qw422016.N().S(`) }
`)
			return
		} else {
			qw422016.N().S(`func (item `)
			qw422016.N().S(goName)
			qw422016.N().S(`) AsUnion() `)
			qw422016.N().S(ep)
			qw422016.N().S(` {
    var ret `)
			qw422016.N().S(ep)
			qw422016.N().S(`
    ret.Set`)
			qw422016.N().S(struct_.wr.unionField.goName)
			qw422016.N().S(`(`)
			qw422016.N().S(ifString(struct_.wr.IsTrueType(), "", "item"))
			qw422016.N().S(`)
    return ret
}

`)
		}
	}
	struct_.streamtypeDefinition(qw422016, bytesVersion, directImports)
	qw422016.N().S(`
`)
	if struct_.wr.tlTag != 0 {
		// anonymous square brackets citizens or other exotic type

		qw422016.N().S(`func (`)
		qw422016.N().S(goName)
		qw422016.N().S(`) TLName() string { return `)
		qw422016.N().Q(struct_.wr.tlName.String())
		qw422016.N().S(` }
func (`)
		qw422016.N().S(goName)
		qw422016.N().S(`) TLTag() uint32  { return `)
		qw422016.N().S(tlTag)
		qw422016.N().S(` }

`)
	}
	qw422016.N().S(`    `)
	struct_.streamfieldMaskGettersAndSetters(qw422016, bytesVersion, directImports)
	qw422016.N().S(`
`)
	if len(struct_.Fields) == 0 {
		// compact code is good

		qw422016.N().S(`func (item *`)
		qw422016.N().S(goName)
		qw422016.N().S(`) Reset() {}
`)
		if struct_.wr.gen.options.GenerateRandomCode {
			qw422016.N().S(`func (item *`)
			qw422016.N().S(goName)
			qw422016.N().S(`) FillRandom(rand basictl.Rand`)
			qw422016.N().S(natArgsDecl)
			qw422016.N().S(`) { }
`)
		}
		qw422016.N().S(`func (item *`)
		qw422016.N().S(goName)
		qw422016.N().S(`) Read(w []byte`)
		qw422016.N().S(natArgsDecl)
		qw422016.N().S(`) ([]byte, error) { return w, nil }
func (item *`)
		qw422016.N().S(goName)
		qw422016.N().S(`) Write(w []byte`)
		qw422016.N().S(natArgsDecl)
		qw422016.N().S(`) ([]byte, error) { return w, nil }
`)
	} else {
		qw422016.N().S(`func (item *`)
		qw422016.N().S(goName)
		qw422016.N().S(`) Reset() { `)
		struct_.streamresetFields(qw422016, bytesVersion, directImports)
		qw422016.N().S(` }
`)
		if struct_.wr.gen.options.GenerateRandomCode {
			qw422016.N().S(`func (item *`)
			qw422016.N().S(goName)
			qw422016.N().S(`) FillRandom(rand basictl.Rand`)
			qw422016.N().S(natArgsDecl)
			qw422016.N().S(`) { `)
			struct_.streamrandomFields(qw422016, bytesVersion, directImports)
			qw422016.N().S(` }
`)
		}
		qw422016.N().S(`
func (item *`)
		qw422016.N().S(goName)
		qw422016.N().S(`) Read(w []byte`)
		qw422016.N().S(natArgsDecl)
		qw422016.N().S(`) (_ []byte, err error) { `)
		struct_.streamreadFields(qw422016, bytesVersion, directImports)
		qw422016.N().S(` }

func (item *`)
		qw422016.N().S(goName)
		qw422016.N().S(`) Write(w []byte`)
		qw422016.N().S(natArgsDecl)
		qw422016.N().S(`) (_ []byte, err error) { `)
		struct_.streamwriteFields(qw422016, bytesVersion, directImports)
		qw422016.N().S(` }

`)
	}
	if struct_.wr.tlTag != 0 {
		if len(struct_.Fields) == 0 {
			// compact code is good

			qw422016.N().S(`func (item *`)
			qw422016.N().S(goName)
			qw422016.N().S(`) ReadBoxed(w []byte`)
			qw422016.N().S(natArgsDecl)
			qw422016.N().S(`) ([]byte, error) { return basictl.NatReadExactTag(w, `)
			qw422016.N().S(tlTag)
			qw422016.N().S(`) }
func (item *`)
			qw422016.N().S(goName)
			qw422016.N().S(`) WriteBoxed(w []byte`)
			qw422016.N().S(natArgsDecl)
			qw422016.N().S(`) ([]byte, error) { return basictl.NatWrite(w, `)
			qw422016.N().S(tlTag)
			qw422016.N().S(`), nil }


`)
		} else {
			qw422016.N().S(`func (item *`)
			qw422016.N().S(goName)
			qw422016.N().S(`) ReadBoxed(w []byte`)
			qw422016.N().S(natArgsDecl)
			qw422016.N().S(`) (_ []byte, err error) {
    if w, err = basictl.NatReadExactTag(w, `)
			qw422016.N().S(tlTag)
			qw422016.N().S(`); err != nil {
        return w, err
    }
    return item.Read(w`)
			qw422016.N().S(natArgsCall)
			qw422016.N().S(`)
}

func (item *`)
			qw422016.N().S(goName)
			qw422016.N().S(`) WriteBoxed(w []byte`)
			qw422016.N().S(natArgsDecl)
			qw422016.N().S(`) ([]byte, error) {
    w = basictl.NatWrite(w, `)
			qw422016.N().S(tlTag)
			qw422016.N().S(`)
    return item.Write(w`)
			qw422016.N().S(natArgsCall)
			qw422016.N().S(`)
}

`)
		}
	}
	struct_.streamfunctionCode(qw422016, bytesVersion, directImports)
	qw422016.N().S(`
`)
	if len(struct_.wr.NatParams) == 0 {
		qw422016.N().S(`
func (item `)
		qw422016.N().S(goName)
		qw422016.N().S(`) String(`)
		qw422016.N().S(formatNatArgsDeclNoComma(struct_.wr.NatParams))
		qw422016.N().S(`) string {
    w, err := item.WriteJSON(nil`)
		qw422016.N().S(natArgsCall)
		qw422016.N().S(`)
    if err != nil {
        return err.Error()
    }
    return string(w)
}
`)
	}
	struct_.streamgenerateJSONCode(qw422016, bytesVersion, directImports)
	qw422016.N().S(`
`)
}

func (struct_ *TypeRWStruct) WriteGenerateCode(qq422016 qtio422016.Writer, bytesVersion bool, directImports *DirectImports) {
	qw422016 := qt422016.AcquireWriter(qq422016)
	struct_.StreamGenerateCode(qw422016, bytesVersion, directImports)
	qt422016.ReleaseWriter(qw422016)
}

func (struct_ *TypeRWStruct) GenerateCode(bytesVersion bool, directImports *DirectImports) string {
	qb422016 := qt422016.AcquireByteBuffer()
	struct_.WriteGenerateCode(qb422016, bytesVersion, directImports)
	qs422016 := string(qb422016.B)
	qt422016.ReleaseByteBuffer(qb422016)
	return qs422016
}

func (struct_ *TypeRWStruct) streamtypeDefinition(qw422016 *qt422016.Writer, bytesVersion bool, directImports *DirectImports) {
	goName := addBytes(struct_.wr.goGlobalName, bytesVersion)

	if struct_.isTypeDef() {
		asterisk := ifString(struct_.Fields[0].recursive, "*", "") // actually never recursive due to condition in struct_.isTypeDef()
		fieldTypeString := struct_.Fields[0].t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false)

		qw422016.N().S(`type `)
		qw422016.N().S(goName)
		qw422016.N().S(` `)
		qw422016.N().S(asterisk)
		qw422016.N().S(fieldTypeString)
		qw422016.N().S(`
`)
		return
	}
	qw422016.N().S(`type `)
	qw422016.N().S(goName)
	qw422016.N().S(` struct {
`)
	for _, field := range struct_.Fields {
		asterisk := ifString(field.recursive, "*", "")
		fieldTypeString := ""
		fieldsMaskComment := ""
		if field.fieldMask != nil {
			fieldsMaskComment = fmt.Sprintf(" // Conditional: %s.%d", formatNatArg(struct_.Fields, *field.fieldMask), field.BitNumber)
		}
		prefixComment := ""
		if field.t.IsTrueType() {
			prefixComment = "// "
			fieldTypeString = "(TrueType)"
		} else {
			fieldTypeString = field.t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false)
		}

		qw422016.N().S(`    `)
		qw422016.N().S(prefixComment)
		qw422016.N().S(field.goName)
		qw422016.N().S(` `)
		qw422016.N().S(asterisk)
		qw422016.N().S(fieldTypeString)
		qw422016.N().S(fieldsMaskComment)
		qw422016.N().S(`
`)
	}
	qw422016.N().S(`}
`)
}

func (struct_ *TypeRWStruct) writetypeDefinition(qq422016 qtio422016.Writer, bytesVersion bool, directImports *DirectImports) {
	qw422016 := qt422016.AcquireWriter(qq422016)
	struct_.streamtypeDefinition(qw422016, bytesVersion, directImports)
	qt422016.ReleaseWriter(qw422016)
}

func (struct_ *TypeRWStruct) typeDefinition(bytesVersion bool, directImports *DirectImports) string {
	qb422016 := qt422016.AcquireByteBuffer()
	struct_.writetypeDefinition(qb422016, bytesVersion, directImports)
	qs422016 := string(qb422016.B)
	qt422016.ReleaseByteBuffer(qb422016)
	return qs422016
}

func (struct_ *TypeRWStruct) streamfieldMaskGettersAndSetters(qw422016 *qt422016.Writer, bytesVersion bool, directImports *DirectImports) {
	goName := addBytes(struct_.wr.goGlobalName, bytesVersion)

	for i, field := range struct_.Fields {
		if field.fieldMask == nil {
			continue
		}
		fieldTypeString := ""
		isTrueType := "bool"
		maskFunArg := !field.fieldMask.isField && !field.fieldMask.isArith
		natArgUse := formatNatArg(struct_.Fields, *field.fieldMask)
		asterisk := addAsterisk(field.recursive, "")

		if !field.t.IsTrueType() {
			fieldTypeString = field.t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false)
			isTrueType = fieldTypeString

		}
		if !field.fieldMask.isArith {
			// Example
			//     notify.notification#461f4ce2 {mode:#} removed:mode.0?Bool = notify.Notification mode;
			//     @any notify.getScheduledNotifications#f53ad7bd  = notify.Notification 0;
			// We skip generating Set and Clear altogether in this case, but still generate IsSet
			setName := struct_.setNames[i]
			if setName == "" {
				setName = struct_.fieldsDec.deconflictName("Set" + field.goName)
				struct_.setNames[i] = setName
			}

			if maskFunArg {
				qw422016.N().S(`
func (item *`)
				qw422016.N().S(goName)
				qw422016.N().S(`) `)
				qw422016.N().S(setName)
				qw422016.N().S(`(v `)
				qw422016.N().S(isTrueType)
				qw422016.N().S(`, `)
				qw422016.N().S(natArgUse)
				qw422016.N().S(` *uint32) {
`)
			} else {
				qw422016.N().S(`func (item *`)
				qw422016.N().S(goName)
				qw422016.N().S(`) `)
				qw422016.N().S(setName)
				qw422016.N().S(`(v `)
				qw422016.N().S(isTrueType)
				qw422016.N().S(`) {
`)
			}
			if !field.t.IsTrueType() {
				if field.recursive {
					qw422016.N().S(`    if item.`)
					qw422016.N().S(field.goName)
					qw422016.N().S(` == nil {
        var value `)
					qw422016.N().S(fieldTypeString)
					qw422016.N().S(`
        item.`)
					qw422016.N().S(field.goName)
					qw422016.N().S(` = &value
    }
`)
				}
				qw422016.N().S(`    `)
				qw422016.N().S(asterisk)
				qw422016.N().S(`item.`)
				qw422016.N().S(field.goName)
				qw422016.N().S(` = v
`)
			}
			if maskFunArg {
				qw422016.N().S(`    if `)
				qw422016.N().S(natArgUse)
				qw422016.N().S(` != nil {
`)
			}
			if field.t.IsTrueType() {
				qw422016.N().S(`        if v {
            `)
				qw422016.N().S(addAsterisk(maskFunArg, natArgUse))
				qw422016.N().S(` |= 1 << `)
				qw422016.E().V(field.BitNumber)
				qw422016.N().S(`
        } else {
            `)
				qw422016.N().S(addAsterisk(maskFunArg, natArgUse))
				qw422016.N().S(` &^= 1 << `)
				qw422016.E().V(field.BitNumber)
				qw422016.N().S(`
        }
`)
			} else {
				qw422016.N().S(`        `)
				qw422016.N().S(addAsterisk(maskFunArg, natArgUse))
				qw422016.N().S(` |= 1 << `)
				qw422016.E().V(field.BitNumber)
				qw422016.N().S(`
`)
			}
			if maskFunArg {
				qw422016.N().S(`    }
`)
			}
			qw422016.N().S(`}
`)
			if !field.t.IsTrueType() {
				clearName := struct_.clearNames[i]
				if clearName == "" {
					clearName = struct_.fieldsDec.deconflictName("Clear" + field.goName)
					struct_.clearNames[i] = clearName
				}

				if maskFunArg {
					qw422016.N().S(`func (item *`)
					qw422016.N().S(goName)
					qw422016.N().S(`) `)
					qw422016.N().S(clearName)
					qw422016.N().S(`(`)
					qw422016.N().S(natArgUse)
					qw422016.N().S(` *uint32) {
`)
				} else {
					qw422016.N().S(`func (item *`)
					qw422016.N().S(goName)
					qw422016.N().S(`) `)
					qw422016.N().S(clearName)
					qw422016.N().S(`() {
`)
				}
				if field.recursive {
					qw422016.N().S(`    if item.`)
					qw422016.N().S(field.goName)
					qw422016.N().S(` != nil { `)
					qw422016.N().S(field.t.TypeResettingCode(bytesVersion, directImports, struct_.wr.ins, fmt.Sprintf("item.%s", field.goName), field.recursive))
					qw422016.N().S(` }
`)
				} else {
					qw422016.N().S(`    `)
					qw422016.N().S(field.t.TypeResettingCode(bytesVersion, directImports, struct_.wr.ins, fmt.Sprintf("item.%s", field.goName), field.recursive))
					qw422016.N().S(`
`)
				}
				if maskFunArg {
					qw422016.N().S(`    if `)
					qw422016.N().S(natArgUse)
					qw422016.N().S(` != nil {
`)
				}
				qw422016.N().S(`    `)
				qw422016.N().S(addAsterisk(maskFunArg, natArgUse))
				qw422016.N().S(` &^= 1 << `)
				qw422016.E().V(field.BitNumber)
				qw422016.N().S(`
`)
				if maskFunArg {
					qw422016.N().S(`    }
`)
				}
				qw422016.N().S(`}
`)
			}
		}
		isSetName := struct_.isSetNames[i]
		if isSetName == "" {
			isSetName = struct_.fieldsDec.deconflictName("IsSet" + field.goName)
			struct_.isSetNames[i] = isSetName
		}

		if maskFunArg {
			qw422016.N().S(`func (item `)
			qw422016.N().S(goName)
			qw422016.N().S(`) `)
			qw422016.N().S(isSetName)
			qw422016.N().S(`(`)
			qw422016.N().S(natArgUse)
			qw422016.N().S(` uint32) bool { return `)
			qw422016.N().S(natArgUse)
			qw422016.N().S(` & (1 << `)
			qw422016.E().V(field.BitNumber)
			qw422016.N().S(`) != 0 }
`)
		} else {
			qw422016.N().S(`func (item `)
			qw422016.N().S(goName)
			qw422016.N().S(`) `)
			qw422016.N().S(isSetName)
			qw422016.N().S(`() bool { return `)
			qw422016.N().S(natArgUse)
			qw422016.N().S(` & (1 << `)
			qw422016.E().V(field.BitNumber)
			qw422016.N().S(`) != 0 }
`)
		}
		qw422016.N().S(`

`)
	}
}

func (struct_ *TypeRWStruct) writefieldMaskGettersAndSetters(qq422016 qtio422016.Writer, bytesVersion bool, directImports *DirectImports) {
	qw422016 := qt422016.AcquireWriter(qq422016)
	struct_.streamfieldMaskGettersAndSetters(qw422016, bytesVersion, directImports)
	qt422016.ReleaseWriter(qw422016)
}

func (struct_ *TypeRWStruct) fieldMaskGettersAndSetters(bytesVersion bool, directImports *DirectImports) string {
	qb422016 := qt422016.AcquireByteBuffer()
	struct_.writefieldMaskGettersAndSetters(qb422016, bytesVersion, directImports)
	qs422016 := string(qb422016.B)
	qt422016.ReleaseByteBuffer(qb422016)
	return qs422016
}

func (struct_ *TypeRWStruct) streamgenerateJSONCode(qw422016 *qt422016.Writer, bytesVersion bool, directImports *DirectImports) {
	goName := addBytes(struct_.wr.goGlobalName, bytesVersion)
	natArgsDecl := formatNatArgsDecl(struct_.wr.NatParams)
	natArgsCall := formatNatArgsDeclCall(struct_.wr.NatParams)

	if struct_.isTypeDef() {
		field := struct_.Fields[0]
		fieldTypeString := field.t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false)

		qw422016.N().S(`
func `)
		qw422016.N().S(goName)
		qw422016.N().S(`__ReadJSON(item *`)
		qw422016.N().S(goName)
		qw422016.N().S(`, j interface{}`)
		qw422016.N().S(natArgsDecl)
		qw422016.N().S(`) error { return item.readJSON(j`)
		qw422016.N().S(natArgsCall)
		qw422016.N().S(`); }
func (item *`)
		qw422016.N().S(goName)
		qw422016.N().S(`) readJSON(j interface{}`)
		qw422016.N().S(natArgsDecl)
		qw422016.N().S(`) error {
    ptr := (*`)
		qw422016.N().S(fieldTypeString)
		qw422016.N().S(`)(item)
    `)
		qw422016.N().S(field.t.TypeJSONReadingCode(bytesVersion, directImports, struct_.wr.ins, "j", "ptr", formatNatArgs(struct_.Fields, field.natArgs), true))
		qw422016.N().S(`
    return nil
}

func (item *`)
		qw422016.N().S(goName)
		qw422016.N().S(`) WriteJSON(w []byte`)
		qw422016.N().S(natArgsDecl)
		qw422016.N().S(`) (_ []byte, err error) {
    return item.WriteJSONOpt(false, w`)
		qw422016.N().S(natArgsCall)
		qw422016.N().S(`)
}

func (item *`)
		qw422016.N().S(goName)
		qw422016.N().S(`) WriteJSONOpt(short bool, w []byte`)
		qw422016.N().S(natArgsDecl)
		qw422016.N().S(`) (_ []byte, err error) {
    ptr := (*`)
		qw422016.N().S(fieldTypeString)
		qw422016.N().S(`)(item)
    `)
		qw422016.N().S(field.t.TypeJSONWritingCode(bytesVersion, directImports, struct_.wr.ins, "ptr", formatNatArgs(struct_.Fields, field.natArgs), true))
		qw422016.N().S(`
    return w, nil
}
`)
	} else {
		// Sorting fields is bad idea. Most efficient parsing is if they are in TL order, because no look ahead required

		qw422016.N().S(`
`)
		struct_.streamreadJSONCode(qw422016, bytesVersion, directImports)
		qw422016.N().S(`
`)
		struct_.streamwriteJSONCode(qw422016, bytesVersion, directImports)
		qw422016.N().S(`
`)
	}
	if len(struct_.wr.NatParams) == 0 {
		qw422016.N().S(`func (item *`)
		qw422016.N().S(goName)
		qw422016.N().S(`) MarshalJSON() ([]byte, error) {
  return item.WriteJSON(nil)
}

func (item *`)
		qw422016.N().S(goName)
		qw422016.N().S(`) UnmarshalJSON(b []byte) error {
    j, err := `)
		qw422016.N().S(struct_.wr.gen.InternalPrefix())
		qw422016.N().S(`JsonBytesToInterface(b)
    if err != nil {
        return `)
		qw422016.N().S(struct_.wr.gen.InternalPrefix())
		qw422016.N().S(`ErrorInvalidJSON(`)
		qw422016.N().Q(struct_.wr.tlName.String())
		qw422016.N().S(`, err.Error())
    }
    if err = item.readJSON(j); err != nil {
        return `)
		qw422016.N().S(struct_.wr.gen.InternalPrefix())
		qw422016.N().S(`ErrorInvalidJSON(`)
		qw422016.N().Q(struct_.wr.tlName.String())
		qw422016.N().S(`, err.Error())
    }
    return nil
}
`)
	}
	qw422016.N().S(`
`)
}

func (struct_ *TypeRWStruct) writegenerateJSONCode(qq422016 qtio422016.Writer, bytesVersion bool, directImports *DirectImports) {
	qw422016 := qt422016.AcquireWriter(qq422016)
	struct_.streamgenerateJSONCode(qw422016, bytesVersion, directImports)
	qt422016.ReleaseWriter(qw422016)
}

func (struct_ *TypeRWStruct) generateJSONCode(bytesVersion bool, directImports *DirectImports) string {
	qb422016 := qt422016.AcquireByteBuffer()
	struct_.writegenerateJSONCode(qb422016, bytesVersion, directImports)
	qs422016 := string(qb422016.B)
	qt422016.ReleaseByteBuffer(qb422016)
	return qs422016
}

func (struct_ *TypeRWStruct) streamreadJSONCode(qw422016 *qt422016.Writer, bytesVersion bool, directImports *DirectImports) {
	goName := addBytes(struct_.wr.goGlobalName, bytesVersion)
	natArgsDecl := formatNatArgsDecl(struct_.wr.NatParams)
	natArgsCall := formatNatArgsDeclCall(struct_.wr.NatParams)

	qw422016.N().S(`func `)
	qw422016.N().S(goName)
	qw422016.N().S(`__ReadJSON(item *`)
	qw422016.N().S(goName)
	qw422016.N().S(`, j interface{}`)
	qw422016.N().S(natArgsDecl)
	qw422016.N().S(`) error { return item.readJSON(j`)
	qw422016.N().S(natArgsCall)
	qw422016.N().S(`); }
func (item *`)
	qw422016.N().S(goName)
	qw422016.N().S(`) readJSON(j interface{}`)
	qw422016.N().S(natArgsDecl)
	qw422016.N().S(`) error {
    _jm, _ok := j.(map[string]interface{})
    if j != nil && !_ok {
        return `)
	qw422016.N().S(struct_.wr.gen.InternalPrefix())
	qw422016.N().S(`ErrorInvalidJSON(`)
	qw422016.N().Q(struct_.wr.tlName.String())
	qw422016.N().S(`, "expected json object")
    }
`)
	// first we read everything that could be field mask (primitives)
	// then we set explicit/check implicit field masks depending on which keys json object has
	// then we read the rest, passing the same field masks to every field reader

	for _, field := range struct_.Fields {
		// field names will be mandatory soon, except for typedefs which are processed separately

		if field.originalName == "" {
			continue
		}
		jsonField := fmt.Sprintf("_j%s", field.goName)
		itemField := fmt.Sprintf("item.%s", field.goName)

		qw422016.N().S(`    `)
		qw422016.N().S(jsonField)
		qw422016.N().S(` := _jm[`)
		qw422016.N().Q(field.originalName)
		qw422016.N().S(`]
    delete(_jm,`)
		qw422016.N().Q(field.originalName)
		qw422016.N().S(`)
`)
		if field.fieldMask != nil {
			continue
		}
		if _, isScalar := field.t.trw.(*TypeRWPrimitive); !isScalar {
			continue
		}
		qw422016.N().S(`    `)
		qw422016.N().S(field.t.TypeJSONReadingCode(bytesVersion, directImports, struct_.wr.ins, jsonField, itemField, formatNatArgs(struct_.Fields, field.natArgs), field.recursive))
		qw422016.N().S(`
`)
	}
	qw422016.N().S(`    for k := range _jm {
        return `)
	qw422016.N().S(struct_.wr.gen.InternalPrefix())
	qw422016.N().S(`ErrorInvalidJSONExcessElement(`)
	qw422016.N().Q(struct_.wr.tlName.String())
	qw422016.N().S(`, k)
    }
`)
	for _, field := range struct_.Fields {
		// field names will be mandatory soon, except for typedefs which are processed separately

		if field.originalName == "" {
			continue
		}
		if field.fieldMask == nil {
			continue
		}
		// If field depends on implicit field mask and set in json, but field mask bit not set, this is error
		// Otherwise field will be silently ignored, to caller surprise
		//
		// If field depends on explicit field mask and set in json, we set the bit
		// Setting field is convenient to set field mask bits. Also works for true-types
		//
		// We must first set all bits, only then read fields, so that all fields depend on te same set of bits

		jsonField := fmt.Sprintf("_j%s", field.goName)

		if field.t.IsTrueType() {
			if !field.fieldMask.isField {
				qw422016.N().S(`    if `)
				qw422016.N().S(jsonField)
				qw422016.N().S(` != nil {
        return `)
				qw422016.N().S(struct_.wr.gen.InternalPrefix())
				qw422016.N().S(`ErrorInvalidJSON(`)
				qw422016.N().Q(struct_.wr.tlName.String())
				qw422016.N().S(`, "implicit true field '`)
				qw422016.N().S(field.originalName)
				qw422016.N().S(`' cannot be defined, set fieldmask instead")
    }
`)
			} else {
				qw422016.N().S(`    if `)
				qw422016.N().S(jsonField)
				qw422016.N().S(` != nil {
        _bit := false
        if err := `)
				qw422016.N().S(struct_.wr.gen.InternalPrefix())
				qw422016.N().S(`JsonReadBool(`)
				qw422016.N().S(jsonField)
				qw422016.N().S(`, &_bit); err != nil {
            return err
        }
        if _bit {
            `)
				qw422016.N().S(formatNatArg(struct_.Fields, *field.fieldMask))
				qw422016.N().S(` |= 1 << `)
				qw422016.E().V(field.BitNumber)
				qw422016.N().S(`
        } else {
            `)
				qw422016.N().S(formatNatArg(struct_.Fields, *field.fieldMask))
				qw422016.N().S(` &^= 1 << `)
				qw422016.E().V(field.BitNumber)
				qw422016.N().S(`
        }
    }
`)
			}
		} else {
			if !field.fieldMask.isField {
				qw422016.N().S(`    if `)
				qw422016.N().S(formatNatArg(struct_.Fields, *field.fieldMask))
				qw422016.N().S(` & (1 << `)
				qw422016.E().V(field.BitNumber)
				qw422016.N().S(`) == 0 && `)
				qw422016.N().S(jsonField)
				qw422016.N().S(` != nil {
        return `)
				qw422016.N().S(struct_.wr.gen.InternalPrefix())
				qw422016.N().S(`ErrorInvalidJSON(`)
				qw422016.N().Q(struct_.wr.tlName.String())
				qw422016.N().S(`, "field '`)
				qw422016.N().S(field.originalName)
				qw422016.N().S(`' is defined, while corresponding implicit fieldmask bit is 0")
    }
`)
			} else {
				qw422016.N().S(`    if `)
				qw422016.N().S(jsonField)
				qw422016.N().S(` != nil {
        `)
				qw422016.N().S(formatNatArg(struct_.Fields, *field.fieldMask))
				qw422016.N().S(` |= 1 << `)
				qw422016.E().V(field.BitNumber)
				qw422016.N().S(`
    }
`)
			}
		}
	}
	for _, field := range struct_.Fields {
		// field names will be mandatory soon, except for typedefs which are processed separately

		if field.originalName == "" {
			continue
		}
		jsonField := fmt.Sprintf("_j%s", field.goName)
		itemField := fmt.Sprintf("item.%s", field.goName)

		if field.t.IsTrueType() {
			if field.fieldMask == nil {
				tmpName := fmt.Sprintf("_%s", field.goName)
				readingCode := field.t.TypeJSONReadingCode(bytesVersion, directImports, struct_.wr.ins, jsonField, tmpName, formatNatArgs(struct_.Fields, field.natArgs), field.recursive)

				fieldTypeString := field.t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false)

				qw422016.N().S(`    var `)
				qw422016.N().S(tmpName)
				qw422016.N().S(` `)
				qw422016.N().S(fieldTypeString)
				qw422016.N().S(`
    `)
				qw422016.N().S(readingCode)
				qw422016.N().S(`
`)
			}
			continue
		}
		readingCode := field.t.TypeJSONReadingCode(bytesVersion, directImports, struct_.wr.ins, jsonField, itemField, formatNatArgs(struct_.Fields, field.natArgs), field.recursive)
		// TODO - for recursive field, add initialization
		resettingCode := field.t.TypeResettingCode(bytesVersion, directImports, struct_.wr.ins, itemField, field.recursive)

		if field.fieldMask != nil {
			if !field.fieldMask.isField {
				qw422016.N().S(`    if `)
				qw422016.N().S(formatNatArg(struct_.Fields, *field.fieldMask))
				qw422016.N().S(` & (1 << `)
				qw422016.E().V(field.BitNumber)
				qw422016.N().S(`) != 0 {
`)
				if field.recursive {
					fieldTypeString := field.t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false)

					qw422016.N().S(`        if item.`)
					qw422016.N().S(field.goName)
					qw422016.N().S(` == nil {
            var value `)
					qw422016.N().S(fieldTypeString)
					qw422016.N().S(`
            item.`)
					qw422016.N().S(field.goName)
					qw422016.N().S(` = &value
        }
`)
				}
				qw422016.N().S(`        `)
				qw422016.N().S(readingCode)
				qw422016.N().S(`
    } else {
`)
				if field.recursive {
					qw422016.N().S(`        if item.`)
					qw422016.N().S(field.goName)
					qw422016.N().S(` != nil {
            `)
					qw422016.N().S(resettingCode)
					qw422016.N().S(`
        }
`)
				} else {
					qw422016.N().S(`        `)
					qw422016.N().S(resettingCode)
					qw422016.N().S(`
`)
				}
				qw422016.N().S(`    }
`)
			} else {
				qw422016.N().S(`    if `)
				qw422016.N().S(jsonField)
				qw422016.N().S(` != nil {
`)
				if field.recursive {
					fieldTypeString := field.t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false)

					qw422016.N().S(`        if item.`)
					qw422016.N().S(field.goName)
					qw422016.N().S(` == nil {
            var value `)
					qw422016.N().S(fieldTypeString)
					qw422016.N().S(`
            item.`)
					qw422016.N().S(field.goName)
					qw422016.N().S(` = &value
        }
`)
				}
				qw422016.N().S(`        `)
				qw422016.N().S(readingCode)
				qw422016.N().S(`
    } else {
`)
				if field.recursive {
					qw422016.N().S(`        if item.`)
					qw422016.N().S(field.goName)
					qw422016.N().S(` != nil {
            `)
					qw422016.N().S(resettingCode)
					qw422016.N().S(`
        }
`)
				} else {
					qw422016.N().S(`        `)
					qw422016.N().S(resettingCode)
					qw422016.N().S(`
`)
				}
				qw422016.N().S(`    }
`)
			}
		} else {
			if _, isScalar := field.t.trw.(*TypeRWPrimitive); !isScalar {
				qw422016.N().S(`    `)
				qw422016.N().S(readingCode)
				qw422016.N().S(`
`)
			}
		}
	}
	qw422016.N().S(`    return nil
}
`)
}

func (struct_ *TypeRWStruct) writereadJSONCode(qq422016 qtio422016.Writer, bytesVersion bool, directImports *DirectImports) {
	qw422016 := qt422016.AcquireWriter(qq422016)
	struct_.streamreadJSONCode(qw422016, bytesVersion, directImports)
	qt422016.ReleaseWriter(qw422016)
}

func (struct_ *TypeRWStruct) readJSONCode(bytesVersion bool, directImports *DirectImports) string {
	qb422016 := qt422016.AcquireByteBuffer()
	struct_.writereadJSONCode(qb422016, bytesVersion, directImports)
	qs422016 := string(qb422016.B)
	qt422016.ReleaseByteBuffer(qb422016)
	return qs422016
}

func (struct_ *TypeRWStruct) streamwriteJSONCode(qw422016 *qt422016.Writer, bytesVersion bool, directImports *DirectImports) {
	goName := addBytes(struct_.wr.goGlobalName, bytesVersion)
	natArgsDecl := formatNatArgsDecl(struct_.wr.NatParams)
	natArgsCall := formatNatArgsDeclCall(struct_.wr.NatParams)

	qw422016.N().S(`
func (item *`)
	qw422016.N().S(goName)
	qw422016.N().S(`) WriteJSON(w []byte`)
	qw422016.N().S(natArgsDecl)
	qw422016.N().S(`) (_ []byte, err error) {
    return item.WriteJSONOpt(false, w`)
	qw422016.N().S(natArgsCall)
	qw422016.N().S(`)
}
func (item *`)
	qw422016.N().S(goName)
	qw422016.N().S(`) WriteJSONOpt(short bool, w []byte`)
	qw422016.N().S(natArgsDecl)
	qw422016.N().S(`) (_ []byte, err error) {
    w = append(w, '{')
`)
	for _, field := range struct_.Fields {
		// field names will be mandatory soon, except for typedefs which are processed separately

		if field.originalName == "" {
			continue
		}
		if field.t.IsTrueType() {
			if field.fieldMask != nil && (field.fieldMask.isField || field.fieldMask.isArith) {
				qw422016.N().S(`    if `)
				qw422016.N().S(formatNatArg(struct_.Fields, *field.fieldMask))
				qw422016.N().S(` & (1<<`)
				qw422016.E().V(field.BitNumber)
				qw422016.N().S(`) != 0 {
        w = basictl.JSONAddCommaIfNeeded(w)
        w = append(w, `)
				qw422016.N().S("`")
				qw422016.N().Q(field.originalName)
				qw422016.N().S(`:true`)
				qw422016.N().S("`")
				qw422016.N().S(`...)
    }
`)
			}
		} else {
			if field.fieldMask != nil {
				qw422016.N().S(`    if `)
				qw422016.N().S(formatNatArg(struct_.Fields, *field.fieldMask))
				qw422016.N().S(` & (1<<`)
				qw422016.E().V(field.BitNumber)
				qw422016.N().S(`) != 0 {
`)
			}
			if field.fieldMask == nil && field.t.TypeJSONEmptyCondition(bytesVersion, fmt.Sprintf("item.%s", field.goName), field.recursive) != "" {
				qw422016.N().S(`                if `)
				qw422016.N().S(field.t.TypeJSONEmptyCondition(bytesVersion, fmt.Sprintf("item.%s", field.goName), field.recursive))
				qw422016.N().S(` {
`)
			}
			qw422016.N().S(`                w = basictl.JSONAddCommaIfNeeded(w)
                w = append(w, `)
			qw422016.N().S("`")
			qw422016.N().S(`"`)
			qw422016.E().S(field.originalName)
			qw422016.N().S(`":`)
			qw422016.N().S("`")
			qw422016.N().S(`...)
        `)
			qw422016.N().S(field.t.TypeJSONWritingCode(bytesVersion, directImports, struct_.wr.ins, fmt.Sprintf("item.%s", field.goName), formatNatArgs(struct_.Fields, field.natArgs), field.recursive))
			qw422016.N().S(`
`)
			if field.fieldMask == nil && field.t.TypeJSONEmptyCondition(bytesVersion, fmt.Sprintf("item.%s", field.goName), field.recursive) != "" {
				qw422016.N().S(`                }
`)
			}
			if field.fieldMask != nil {
				qw422016.N().S(`    }
`)
			}
		}
	}
	qw422016.N().S(`    return append(w, '}'), nil
}
`)
}

func (struct_ *TypeRWStruct) writewriteJSONCode(qq422016 qtio422016.Writer, bytesVersion bool, directImports *DirectImports) {
	qw422016 := qt422016.AcquireWriter(qq422016)
	struct_.streamwriteJSONCode(qw422016, bytesVersion, directImports)
	qt422016.ReleaseWriter(qw422016)
}

func (struct_ *TypeRWStruct) writeJSONCode(bytesVersion bool, directImports *DirectImports) string {
	qb422016 := qt422016.AcquireByteBuffer()
	struct_.writewriteJSONCode(qb422016, bytesVersion, directImports)
	qs422016 := string(qb422016.B)
	qt422016.ReleaseByteBuffer(qb422016)
	return qs422016
}

func (struct_ *TypeRWStruct) streamfunctionCode(qw422016 *qt422016.Writer, bytesVersion bool, directImports *DirectImports) {
	if struct_.ResultType == nil {
		return
	}
	goName := addBytes(struct_.wr.goGlobalName, bytesVersion)
	retArg := struct_.ResultType.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false)

	qw422016.N().S(`func (item *`)
	qw422016.N().S(goName)
	qw422016.N().S(`) ReadResult(w []byte, ret *`)
	qw422016.N().S(retArg)
	qw422016.N().S(`) (_ []byte, err error) {
    `)
	qw422016.N().S(struct_.ResultType.TypeReadingCode(bytesVersion, directImports, struct_.wr.ins, "ret", false, formatNatArgs(struct_.Fields, struct_.ResultNatArgs), true, true))
	qw422016.N().S(`
}

func (item *`)
	qw422016.N().S(goName)
	qw422016.N().S(`) WriteResult(w []byte, ret `)
	qw422016.N().S(retArg)
	qw422016.N().S(`) (_ []byte, err error) {
    `)
	qw422016.N().S(struct_.ResultType.TypeWritingCode(bytesVersion, directImports, struct_.wr.ins, "ret", false, formatNatArgs(struct_.Fields, struct_.ResultNatArgs), false, true))
	qw422016.N().S(`
}

func (item *`)
	qw422016.N().S(goName)
	qw422016.N().S(`) ReadResultJSON(j interface{}, ret *`)
	qw422016.N().S(retArg)
	qw422016.N().S(`) error {
    `)
	qw422016.N().S(struct_.ResultType.TypeJSONReadingCode(bytesVersion, directImports, struct_.wr.ins, "j", "ret", formatNatArgs(struct_.Fields, struct_.ResultNatArgs), true))
	qw422016.N().S(`
    return nil
}

func (item *`)
	qw422016.N().S(goName)
	qw422016.N().S(`) WriteResultJSON(w []byte, ret `)
	qw422016.N().S(retArg)
	qw422016.N().S(`) (_ []byte, err error) {
    return item.writeResultJSON(false, w, ret)
}

func (item *`)
	qw422016.N().S(goName)
	qw422016.N().S(`) writeResultJSON(short bool, w []byte, ret `)
	qw422016.N().S(retArg)
	qw422016.N().S(`) (_ []byte, err error) {
    `)
	qw422016.N().S(struct_.ResultType.TypeJSONWritingCode(bytesVersion, directImports, struct_.wr.ins, "ret", formatNatArgs(struct_.Fields, struct_.ResultNatArgs), false))
	qw422016.N().S(`
    return w, nil
}

func (item *`)
	qw422016.N().S(goName)
	qw422016.N().S(`) ReadResultWriteResultJSON(r []byte, w []byte) (_ []byte, _ []byte, err error) {
  var ret `)
	qw422016.N().S(retArg)
	qw422016.N().S(`
  if r, err = item.ReadResult(r, &ret); err != nil {
    return r, w, err
  }
  w, err = item.WriteResultJSON(w, ret)
  return r, w, err
}

func (item *`)
	qw422016.N().S(goName)
	qw422016.N().S(`) ReadResultWriteResultJSONShort(r []byte, w []byte) (_ []byte, _ []byte, err error) {
  var ret `)
	qw422016.N().S(retArg)
	qw422016.N().S(`
  if r, err = item.ReadResult(r, &ret); err != nil {
    return r, w, err
  }
  w, err = item.writeResultJSON(true, w, ret)
  return r, w, err
}

func (item *`)
	qw422016.N().S(goName)
	qw422016.N().S(`) ReadResultJSONWriteResult(r []byte, w []byte) ([]byte, []byte, error) {
  j, err := `)
	qw422016.N().S(struct_.wr.gen.InternalPrefix())
	qw422016.N().S(`JsonBytesToInterface(r)
  if err != nil {
    return r, w, `)
	qw422016.N().S(struct_.wr.gen.InternalPrefix())
	qw422016.N().S(`ErrorInvalidJSON(`)
	qw422016.N().Q(struct_.wr.tlName.String())
	qw422016.N().S(`, err.Error())
  }
  var ret `)
	qw422016.N().S(retArg)
	qw422016.N().S(`
  if err = item.ReadResultJSON(j, &ret); err != nil {
    return r, w, err
  }
  w, err = item.WriteResult(w, ret)
  return r, w, err
}

`)
}

func (struct_ *TypeRWStruct) writefunctionCode(qq422016 qtio422016.Writer, bytesVersion bool, directImports *DirectImports) {
	qw422016 := qt422016.AcquireWriter(qq422016)
	struct_.streamfunctionCode(qw422016, bytesVersion, directImports)
	qt422016.ReleaseWriter(qw422016)
}

func (struct_ *TypeRWStruct) functionCode(bytesVersion bool, directImports *DirectImports) string {
	qb422016 := qt422016.AcquireByteBuffer()
	struct_.writefunctionCode(qb422016, bytesVersion, directImports)
	qs422016 := string(qb422016.B)
	qt422016.ReleaseByteBuffer(qb422016)
	return qs422016
}

func (struct_ *TypeRWStruct) streamresetFields(qw422016 *qt422016.Writer, bytesVersion bool, directImports *DirectImports) {
	if struct_.isTypeDef() {
		field := struct_.Fields[0]

		qw422016.N().S(`ptr := (*`)
		qw422016.N().S(field.t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false))
		qw422016.N().S(`)(item)
`)
		qw422016.N().S(field.t.TypeResettingCode(bytesVersion, directImports, struct_.wr.ins, "ptr", true))
		qw422016.N().S(`
`)
		return
	}
	for _, field := range struct_.Fields {
		if field.t.IsTrueType() {
			continue
		}
		resetCode := field.t.TypeResettingCode(bytesVersion, directImports, struct_.wr.ins, fmt.Sprintf("item.%s", field.goName), field.recursive)

		if field.recursive {
			qw422016.N().S(`if item.`)
			qw422016.N().S(field.goName)
			qw422016.N().S(` != nil { `)
			qw422016.N().S(resetCode)
			qw422016.N().S(` }
`)
		} else {
			qw422016.N().S(resetCode)
			qw422016.N().S(`
`)
		}
	}
}

func (struct_ *TypeRWStruct) writeresetFields(qq422016 qtio422016.Writer, bytesVersion bool, directImports *DirectImports) {
	qw422016 := qt422016.AcquireWriter(qq422016)
	struct_.streamresetFields(qw422016, bytesVersion, directImports)
	qt422016.ReleaseWriter(qw422016)
}

func (struct_ *TypeRWStruct) resetFields(bytesVersion bool, directImports *DirectImports) string {
	qb422016 := qt422016.AcquireByteBuffer()
	struct_.writeresetFields(qb422016, bytesVersion, directImports)
	qs422016 := string(qb422016.B)
	qt422016.ReleaseByteBuffer(qb422016)
	return qs422016
}

func (struct_ *TypeRWStruct) streamrandomFields(qw422016 *qt422016.Writer, bytesVersion bool, directImports *DirectImports) {
	if struct_.isTypeDef() {
		field := struct_.Fields[0]

		qw422016.N().S(`ptr := (*`)
		qw422016.N().S(field.t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false))
		qw422016.N().S(`)(item)
`)
		qw422016.N().S(field.t.TypeRandomCode(bytesVersion, directImports, struct_.wr.ins, "ptr", formatNatArgs(struct_.Fields, field.natArgs), true))
		qw422016.N().S(`
`)
		return
	}
	lastWritten := false

	for i, field := range struct_.Fields {
		if field.t.IsTrueType() {
			continue
		}
		finishFieldsMask := false

		if field.fieldMask != nil {
			// Commented for now. compiler does the same without additional complexity
			// if field.fieldMask.isArith {
			//    res, err := strconv.Atoi(field.fieldMask.name)
			//    if err != nil {
			//        log.Panicf("constant field mask %q failed to parse as int - %v", field.fieldMask.name, err)
			//    }
			//    if res&(1<<field.BitNumber) == 0 {
			//        continue
			//    }
			// } else {
			finishFieldsMask = true

			qw422016.N().S(`if `)
			qw422016.N().S(formatNatArg(struct_.Fields, *field.fieldMask))
			qw422016.N().S(` & (1<<`)
			qw422016.E().V(field.BitNumber)
			qw422016.N().S(`) != 0 {
`)
			// }

		}
		if field.recursive {
			qw422016.N().S(`if item.`)
			qw422016.N().S(field.goName)
			qw422016.N().S(` == nil {
    var value `)
			qw422016.N().S(field.t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false))
			qw422016.N().S(`
    item.`)
			qw422016.N().S(field.goName)
			qw422016.N().S(` = &value
}
`)
		}
		last := i == len(struct_.Fields)-1 && !finishFieldsMask
		lastWritten = lastWritten || last

		qw422016.N().S(field.t.TypeRandomCode(bytesVersion, directImports, struct_.wr.ins, "item."+field.goName, formatNatArgs(struct_.Fields, field.natArgs), field.recursive))
		qw422016.N().S(`
`)
		if finishFieldsMask {
			qw422016.N().S(`} else {
`)
			if field.recursive {
				qw422016.N().S(`        if item.`)
				qw422016.N().S(field.goName)
				qw422016.N().S(` != nil {
            `)
				qw422016.N().S(field.t.TypeResettingCode(bytesVersion, directImports, struct_.wr.ins, fmt.Sprintf("item.%s", field.goName), field.recursive))
				qw422016.N().S(`
        }
`)
			} else {
				qw422016.N().S(`        `)
				qw422016.N().S(field.t.TypeResettingCode(bytesVersion, directImports, struct_.wr.ins, fmt.Sprintf("item.%s", field.goName), field.recursive))
				qw422016.N().S(`
`)
			}
			qw422016.N().S(`}
`)
		}
	}
}

func (struct_ *TypeRWStruct) writerandomFields(qq422016 qtio422016.Writer, bytesVersion bool, directImports *DirectImports) {
	qw422016 := qt422016.AcquireWriter(qq422016)
	struct_.streamrandomFields(qw422016, bytesVersion, directImports)
	qt422016.ReleaseWriter(qw422016)
}

func (struct_ *TypeRWStruct) randomFields(bytesVersion bool, directImports *DirectImports) string {
	qb422016 := qt422016.AcquireByteBuffer()
	struct_.writerandomFields(qb422016, bytesVersion, directImports)
	qs422016 := string(qb422016.B)
	qt422016.ReleaseByteBuffer(qb422016)
	return qs422016
}

func (struct_ *TypeRWStruct) streamwriteFields(qw422016 *qt422016.Writer, bytesVersion bool, directImports *DirectImports) {
	if struct_.isTypeDef() {
		field := struct_.Fields[0]

		qw422016.N().S(`ptr := (*`)
		qw422016.N().S(field.t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false))
		qw422016.N().S(`)(item)
`)
		qw422016.N().S(field.t.TypeWritingCode(bytesVersion, directImports, struct_.wr.ins, "ptr", field.Bare(), formatNatArgs(struct_.Fields, field.natArgs), true, true))
		qw422016.N().S(`
`)
		return
	}
	lastWritten := false

	for i, field := range struct_.Fields {
		if field.t.IsTrueType() {
			continue
		}
		finishFieldsMask := false

		if field.fieldMask != nil {
			// Commented for now. compiler does the same without additional complexity
			// if field.fieldMask.isArith {
			//    res, err := strconv.Atoi(field.fieldMask.name)
			//    if err != nil {
			//        log.Panicf("constant field mask %q failed to parse as int - %v", field.fieldMask.name, err)
			//    }
			//    if res&(1<<field.BitNumber) == 0 {
			//        continue
			//    }
			// } else {
			finishFieldsMask = true

			qw422016.N().S(`if `)
			qw422016.N().S(formatNatArg(struct_.Fields, *field.fieldMask))
			qw422016.N().S(` & (1<<`)
			qw422016.E().V(field.BitNumber)
			qw422016.N().S(`) != 0 {
`)
			// }

		}
		last := i == len(struct_.Fields)-1 && !finishFieldsMask
		lastWritten = lastWritten || last

		qw422016.N().S(`    `)
		qw422016.N().S(field.t.TypeWritingCode(bytesVersion, directImports, struct_.wr.ins, fmt.Sprintf("item.%s", field.goName), field.Bare(), formatNatArgs(struct_.Fields, field.natArgs), field.recursive, last))
		qw422016.N().S(`
`)
		if finishFieldsMask {
			qw422016.N().S(`}
`)
		}
	}
	if !lastWritten {
		qw422016.N().S(`return w, nil
`)
	}
}

func (struct_ *TypeRWStruct) writewriteFields(qq422016 qtio422016.Writer, bytesVersion bool, directImports *DirectImports) {
	qw422016 := qt422016.AcquireWriter(qq422016)
	struct_.streamwriteFields(qw422016, bytesVersion, directImports)
	qt422016.ReleaseWriter(qw422016)
}

func (struct_ *TypeRWStruct) writeFields(bytesVersion bool, directImports *DirectImports) string {
	qb422016 := qt422016.AcquireByteBuffer()
	struct_.writewriteFields(qb422016, bytesVersion, directImports)
	qs422016 := string(qb422016.B)
	qt422016.ReleaseByteBuffer(qb422016)
	return qs422016
}

func (struct_ *TypeRWStruct) streamreadFields(qw422016 *qt422016.Writer, bytesVersion bool, directImports *DirectImports) {
	if struct_.isTypeDef() {
		field := struct_.Fields[0]

		qw422016.N().S(`ptr := (*`)
		qw422016.N().S(field.t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false))
		qw422016.N().S(`)(item)
`)
		qw422016.N().S(field.t.TypeReadingCode(bytesVersion, directImports, struct_.wr.ins, "ptr", field.Bare(), formatNatArgs(struct_.Fields, field.natArgs), true, true))
		qw422016.N().S(`
`)
		return
	}
	lastWritten := false

	for i, field := range struct_.Fields {
		if field.t.IsTrueType() {
			continue
		}
		finishFieldsMask := false

		if field.fieldMask != nil {
			// Commented for now. compiler does the same without additional complexity
			// if field.fieldMask.isArith {
			//    res, err := strconv.Atoi(field.fieldMask.name)
			//    if err != nil {
			//        log.Panicf("constant field mask %q failed to parse as int - %v", field.fieldMask.name, err)
			//    }
			//    if res&(1<<field.BitNumber) == 0 {
			//        continue
			//    }
			// } else {
			finishFieldsMask = true

			qw422016.N().S(`if `)
			qw422016.N().S(formatNatArg(struct_.Fields, *field.fieldMask))
			qw422016.N().S(` & (1<<`)
			qw422016.E().V(field.BitNumber)
			qw422016.N().S(`) != 0 {
`)
			// }

		}
		if field.recursive {
			qw422016.N().S(`if item.`)
			qw422016.N().S(field.goName)
			qw422016.N().S(` == nil {
    var value `)
			qw422016.N().S(field.t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false))
			qw422016.N().S(`
    item.`)
			qw422016.N().S(field.goName)
			qw422016.N().S(` = &value
}
`)
		}
		last := i == len(struct_.Fields)-1 && !finishFieldsMask
		lastWritten = lastWritten || last

		qw422016.N().S(field.t.TypeReadingCode(bytesVersion, directImports, struct_.wr.ins, "item."+field.goName, field.Bare(), formatNatArgs(struct_.Fields, field.natArgs), field.recursive, last))
		qw422016.N().S(`
`)
		if finishFieldsMask {
			qw422016.N().S(`} else {
`)
			if field.recursive {
				qw422016.N().S(`        if item.`)
				qw422016.N().S(field.goName)
				qw422016.N().S(` != nil {
            `)
				qw422016.N().S(field.t.TypeResettingCode(bytesVersion, directImports, struct_.wr.ins, fmt.Sprintf("item.%s", field.goName), field.recursive))
				qw422016.N().S(`
        }
`)
			} else {
				qw422016.N().S(`        `)
				qw422016.N().S(field.t.TypeResettingCode(bytesVersion, directImports, struct_.wr.ins, fmt.Sprintf("item.%s", field.goName), field.recursive))
				qw422016.N().S(`
`)
			}
			qw422016.N().S(`}
`)
		}
	}
	if !lastWritten {
		qw422016.N().S(`return w, nil
`)
	}
}

func (struct_ *TypeRWStruct) writereadFields(qq422016 qtio422016.Writer, bytesVersion bool, directImports *DirectImports) {
	qw422016 := qt422016.AcquireWriter(qq422016)
	struct_.streamreadFields(qw422016, bytesVersion, directImports)
	qt422016.ReleaseWriter(qw422016)
}

func (struct_ *TypeRWStruct) readFields(bytesVersion bool, directImports *DirectImports) string {
	qb422016 := qt422016.AcquireByteBuffer()
	struct_.writereadFields(qb422016, bytesVersion, directImports)
	qs422016 := string(qb422016.B)
	qt422016.ReleaseByteBuffer(qb422016)
	return qs422016
}
