// Code generated by qtc from "qt_struct.qtpl". DO NOT EDIT.
// See https://github.com/valyala/quicktemplate for details.

package tlcodegen

import "fmt"

import "github.com/vkcom/tl/internal/utils"

import "strings"

import "sort"

import (
	qtio422016 "io"

	qt422016 "github.com/valyala/quicktemplate"
)

var (
	_ = qtio422016.Copy
	_ = qt422016.AcquireByteBuffer
)

func (struct_ *TypeRWStruct) StreamGenerateCode(qw422016 *qt422016.Writer, bytesVersion bool, directImports *DirectImports) {
	goName := addBytes(struct_.wr.goGlobalName, bytesVersion)
	tlTag := fmt.Sprintf("0x%08x", struct_.wr.tlTag)
	tlName := struct_.wr.tlName.String()
	natArgsDecl := formatNatArgsDecl(struct_.wr.NatParams)
	natArgsCall := formatNatArgsDeclCall(struct_.wr.NatParams)
	writeNeedsError := struct_.wr.hasErrorInWriteMethods

	if struct_.wr.unionParent != nil {
		ep := struct_.wr.unionParent.wr.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false)

		if struct_.wr.unionParent.IsEnum {
			qw422016.N().S(`func `)
			qw422016.N().S(goName)
			qw422016.N().S(`() `)
			qw422016.N().S(ep)
			qw422016.N().S(` { return `)
			qw422016.N().S(ep)
			qw422016.N().S(`__MakeEnum(`)
			qw422016.N().D(struct_.wr.unionIndex)
			qw422016.N().S(`) }
`)
			return
		} else {
			qw422016.N().S(`func (item `)
			qw422016.N().S(goName)
			qw422016.N().S(`) AsUnion() `)
			qw422016.N().S(ep)
			qw422016.N().S(` {
    var ret `)
			qw422016.N().S(ep)
			qw422016.N().S(`
    ret.Set`)
			qw422016.N().S(struct_.wr.unionParent.Fields[struct_.wr.unionIndex].goName)
			qw422016.N().S(`(`)
			qw422016.N().S(ifString(struct_.wr.IsTrueType(), "", "item"))
			qw422016.N().S(`)
    return ret
}

`)
		}
	}
	struct_.streamtypeDefinition(qw422016, bytesVersion, directImports)
	qw422016.N().S(`
`)
	if struct_.wr.tlTag != 0 {
		// anonymous square brackets citizens or other exotic type

		qw422016.N().S(`func (`)
		qw422016.N().S(goName)
		qw422016.N().S(`) TLName() string { return `)
		qw422016.N().Q(tlName)
		qw422016.N().S(` }
func (`)
		qw422016.N().S(goName)
		qw422016.N().S(`) TLTag() uint32  { return `)
		qw422016.N().S(tlTag)
		qw422016.N().S(` }

`)
	}
	qw422016.N().S(`    `)
	struct_.streamfieldMaskGettersAndSetters(qw422016, bytesVersion, directImports)
	qw422016.N().S(`
func (item *`)
	qw422016.N().S(goName)
	qw422016.N().S(`) Reset() { `)
	struct_.streamresetFields(qw422016, bytesVersion, directImports)
	qw422016.N().S(` }

`)
	if struct_.wr.gen.options.GenerateRandomCode {
		qw422016.N().S(`func (item *`)
		qw422016.N().S(goName)
		qw422016.N().S(`) FillRandom(rg *basictl.RandGenerator`)
		qw422016.N().S(natArgsDecl)
		qw422016.N().S(`) { `)
		struct_.streamrandomFields(qw422016, bytesVersion, directImports)
		qw422016.N().S(` }
`)
	}
	qw422016.N().S(`
func (item *`)
	qw422016.N().S(goName)
	qw422016.N().S(`) Read(w []byte`)
	qw422016.N().S(natArgsDecl)
	qw422016.N().S(`) (_ []byte, err error) { `)
	struct_.streamreadFields(qw422016, bytesVersion, directImports)
	qw422016.N().S(` }

func (item *`)
	qw422016.N().S(goName)
	qw422016.N().S(`) WriteGeneral(w []byte`)
	qw422016.N().S(natArgsDecl)
	qw422016.N().S(`) (_ []byte, err error) {
`)
	if writeNeedsError {
		qw422016.N().S(`    return item.Write(w`)
		qw422016.N().S(natArgsCall)
		qw422016.N().S(`)
`)
	} else {
		qw422016.N().S(`    return item.Write(w`)
		qw422016.N().S(natArgsCall)
		qw422016.N().S(`), nil
`)
	}
	qw422016.N().S(`}

func (item *`)
	qw422016.N().S(goName)
	qw422016.N().S(`) Write(w []byte`)
	qw422016.N().S(natArgsDecl)
	qw422016.N().S(`) `)
	qw422016.N().S(wrapWithError(writeNeedsError, "[]byte"))
	qw422016.N().S(` { `)
	struct_.streamwriteFields(qw422016, bytesVersion, directImports)
	qw422016.N().S(` }

`)
	if struct_.wr.tlTag != 0 {
		qw422016.N().S(`func (item *`)
		qw422016.N().S(goName)
		qw422016.N().S(`) ReadBoxed(w []byte`)
		qw422016.N().S(natArgsDecl)
		qw422016.N().S(`) (_ []byte, err error) {
    if w, err = basictl.NatReadExactTag(w, `)
		qw422016.N().S(tlTag)
		qw422016.N().S(`); err != nil {
        return w, err
    }
    return item.Read(w`)
		qw422016.N().S(natArgsCall)
		qw422016.N().S(`)
}

func (item *`)
		qw422016.N().S(goName)
		qw422016.N().S(`) WriteBoxedGeneral(w []byte`)
		qw422016.N().S(natArgsDecl)
		qw422016.N().S(`) (_ []byte, err error) {
`)
		if writeNeedsError {
			qw422016.N().S(`    return item.WriteBoxed(w`)
			qw422016.N().S(natArgsCall)
			qw422016.N().S(`)
`)
		} else {
			qw422016.N().S(`    return item.WriteBoxed(w`)
			qw422016.N().S(natArgsCall)
			qw422016.N().S(`), nil
`)
		}
		qw422016.N().S(`}

func (item *`)
		qw422016.N().S(goName)
		qw422016.N().S(`) WriteBoxed(w []byte`)
		qw422016.N().S(natArgsDecl)
		qw422016.N().S(`) `)
		qw422016.N().S(wrapWithError(writeNeedsError, "[]byte"))
		qw422016.N().S(` {
    w = basictl.NatWrite(w, `)
		qw422016.N().S(tlTag)
		qw422016.N().S(`)
    return item.Write(w`)
		qw422016.N().S(natArgsCall)
		qw422016.N().S(`)
}

`)
	}
	struct_.streamfunctionCode(qw422016, bytesVersion, directImports)
	qw422016.N().S(`
`)
	if len(struct_.wr.NatParams) == 0 {
		qw422016.N().S(`
func (item `)
		qw422016.N().S(goName)
		qw422016.N().S(`) String(`)
		qw422016.N().S(formatNatArgsDeclNoComma(struct_.wr.NatParams))
		qw422016.N().S(`) string {
`)
		if writeNeedsError {
			qw422016.N().S(`    w, err := item.WriteJSON(nil`)
			qw422016.N().S(natArgsCall)
			qw422016.N().S(`)
    if err != nil {
        return err.Error()
    }
    return string(w)
`)
		} else {
			qw422016.N().S(`    return string(item.WriteJSON(nil`)
			qw422016.N().S(natArgsCall)
			qw422016.N().S(`))
`)
		}
		qw422016.N().S(`}
`)
	}
	struct_.streamgenerateJSONCode(qw422016, bytesVersion, directImports)
	qw422016.N().S(`
`)
	if struct_.wr.gen.options.GenerateTL2 {
		struct_.streamgenerateTL2Code(qw422016, bytesVersion, directImports)
		qw422016.N().S(`
`)
	}
}

func (struct_ *TypeRWStruct) WriteGenerateCode(qq422016 qtio422016.Writer, bytesVersion bool, directImports *DirectImports) {
	qw422016 := qt422016.AcquireWriter(qq422016)
	struct_.StreamGenerateCode(qw422016, bytesVersion, directImports)
	qt422016.ReleaseWriter(qw422016)
}

func (struct_ *TypeRWStruct) GenerateCode(bytesVersion bool, directImports *DirectImports) string {
	qb422016 := qt422016.AcquireByteBuffer()
	struct_.WriteGenerateCode(qb422016, bytesVersion, directImports)
	qs422016 := string(qb422016.B)
	qt422016.ReleaseByteBuffer(qb422016)
	return qs422016
}

func (struct_ *TypeRWStruct) streamtypeDefinition(qw422016 *qt422016.Writer, bytesVersion bool, directImports *DirectImports) {
	goName := addBytes(struct_.wr.goGlobalName, bytesVersion)

	if struct_.isTypeDef() {
		asterisk := ifString(struct_.Fields[0].recursive, "*", "") // actually never recursive due to condition in struct_.isTypeDef()
		fieldTypeString := struct_.Fields[0].t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false)

		qw422016.N().S(`type `)
		qw422016.N().S(goName)
		qw422016.N().S(` `)
		qw422016.N().S(asterisk)
		qw422016.N().S(fieldTypeString)
		qw422016.N().S(`
`)
		return
	}
	qw422016.N().S(`type `)
	qw422016.N().S(goName)
	qw422016.N().S(` struct {
`)
	for _, field := range struct_.Fields {
		asterisk := ifString(field.recursive, "*", "")
		fieldTypeString := ""
		fieldsMaskComment := ""
		if field.fieldMask != nil {
			fieldsMaskComment = fmt.Sprintf(" // Conditional: %s.%d", formatNatArg(struct_.Fields, *field.fieldMask), field.BitNumber)
		}
		prefixComment := ""
		if field.t.IsTrueType() {
			prefixComment = "// "
			fieldTypeString = "(TrueType)"
		} else {
			fieldTypeString = field.t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false)
		}

		qw422016.N().S(`    `)
		qw422016.N().S(prefixComment)
		qw422016.N().S(field.goName)
		qw422016.N().S(` `)
		qw422016.N().S(asterisk)
		qw422016.N().S(fieldTypeString)
		qw422016.N().S(fieldsMaskComment)
		qw422016.N().S(`
`)
	}
	qw422016.N().S(`}
`)
}

func (struct_ *TypeRWStruct) writetypeDefinition(qq422016 qtio422016.Writer, bytesVersion bool, directImports *DirectImports) {
	qw422016 := qt422016.AcquireWriter(qq422016)
	struct_.streamtypeDefinition(qw422016, bytesVersion, directImports)
	qt422016.ReleaseWriter(qw422016)
}

func (struct_ *TypeRWStruct) typeDefinition(bytesVersion bool, directImports *DirectImports) string {
	qb422016 := qt422016.AcquireByteBuffer()
	struct_.writetypeDefinition(qb422016, bytesVersion, directImports)
	qs422016 := string(qb422016.B)
	qt422016.ReleaseByteBuffer(qb422016)
	return qs422016
}

func (struct_ *TypeRWStruct) streamfieldMaskGettersAndSetters(qw422016 *qt422016.Writer, bytesVersion bool, directImports *DirectImports) {
	goName := addBytes(struct_.wr.goGlobalName, bytesVersion)

	for i, field := range struct_.Fields {
		if field.fieldMask == nil {
			continue
		}
		fieldTypeString := ""
		isTrueType := "bool"
		maskFunArg := !field.fieldMask.isField && !field.fieldMask.isArith
		natArgUse := formatNatArg(struct_.Fields, *field.fieldMask)
		asterisk := addAsterisk(field.recursive, "")

		if !field.t.IsTrueType() {
			fieldTypeString = field.t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false)
			isTrueType = fieldTypeString

		}
		if !field.fieldMask.isArith {
			// Example
			//     notify.notification#461f4ce2 {mode:#} removed:mode.0?Bool = notify.Notification mode;
			//     @any notify.getScheduledNotifications#f53ad7bd  = notify.Notification 0;
			// We skip generating Set and Clear altogether in this case, but still generate IsSet
			setName := struct_.setNames[i]
			if setName == "" {
				setName = struct_.fieldsDec.deconflictName("Set" + field.goName)
				struct_.setNames[i] = setName
			}

			if maskFunArg {
				qw422016.N().S(`
func (item *`)
				qw422016.N().S(goName)
				qw422016.N().S(`) `)
				qw422016.N().S(setName)
				qw422016.N().S(`(v `)
				qw422016.N().S(isTrueType)
				qw422016.N().S(`, `)
				qw422016.N().S(natArgUse)
				qw422016.N().S(` *uint32) {
`)
			} else {
				qw422016.N().S(`func (item *`)
				qw422016.N().S(goName)
				qw422016.N().S(`) `)
				qw422016.N().S(setName)
				qw422016.N().S(`(v `)
				qw422016.N().S(isTrueType)
				qw422016.N().S(`) {
`)
			}
			if !field.t.IsTrueType() {
				if field.recursive {
					qw422016.N().S(`    if item.`)
					qw422016.N().S(field.goName)
					qw422016.N().S(` == nil {
        var value `)
					qw422016.N().S(fieldTypeString)
					qw422016.N().S(`
        item.`)
					qw422016.N().S(field.goName)
					qw422016.N().S(` = &value
    }
`)
				}
				qw422016.N().S(`    `)
				qw422016.N().S(asterisk)
				qw422016.N().S(`item.`)
				qw422016.N().S(field.goName)
				qw422016.N().S(` = v
`)
			}
			if maskFunArg {
				qw422016.N().S(`    if `)
				qw422016.N().S(natArgUse)
				qw422016.N().S(` != nil {
`)
			}
			if field.t.IsTrueType() {
				qw422016.N().S(`        if v {
            `)
				qw422016.N().S(addAsterisk(maskFunArg, natArgUse))
				qw422016.N().S(` |= 1 << `)
				qw422016.E().V(field.BitNumber)
				qw422016.N().S(`
        } else {
            `)
				qw422016.N().S(addAsterisk(maskFunArg, natArgUse))
				qw422016.N().S(` &^= 1 << `)
				qw422016.E().V(field.BitNumber)
				qw422016.N().S(`
        }
`)
			} else {
				qw422016.N().S(`        `)
				qw422016.N().S(addAsterisk(maskFunArg, natArgUse))
				qw422016.N().S(` |= 1 << `)
				qw422016.E().V(field.BitNumber)
				qw422016.N().S(`
`)
			}
			if maskFunArg {
				qw422016.N().S(`    }
`)
			}
			qw422016.N().S(`}
`)
			if !field.t.IsTrueType() {
				clearName := struct_.clearNames[i]
				if clearName == "" {
					clearName = struct_.fieldsDec.deconflictName("Clear" + field.goName)
					struct_.clearNames[i] = clearName
				}

				if maskFunArg {
					qw422016.N().S(`func (item *`)
					qw422016.N().S(goName)
					qw422016.N().S(`) `)
					qw422016.N().S(clearName)
					qw422016.N().S(`(`)
					qw422016.N().S(natArgUse)
					qw422016.N().S(` *uint32) {
`)
				} else {
					qw422016.N().S(`func (item *`)
					qw422016.N().S(goName)
					qw422016.N().S(`) `)
					qw422016.N().S(clearName)
					qw422016.N().S(`() {
`)
				}
				if field.recursive {
					qw422016.N().S(`    if item.`)
					qw422016.N().S(field.goName)
					qw422016.N().S(` != nil { `)
					qw422016.N().S(field.t.TypeResettingCode(bytesVersion, directImports, struct_.wr.ins, fmt.Sprintf("item.%s", field.goName), field.recursive))
					qw422016.N().S(` }
`)
				} else {
					qw422016.N().S(`    `)
					qw422016.N().S(field.t.TypeResettingCode(bytesVersion, directImports, struct_.wr.ins, fmt.Sprintf("item.%s", field.goName), field.recursive))
					qw422016.N().S(`
`)
				}
				if maskFunArg {
					qw422016.N().S(`    if `)
					qw422016.N().S(natArgUse)
					qw422016.N().S(` != nil {
`)
				}
				qw422016.N().S(`    `)
				qw422016.N().S(addAsterisk(maskFunArg, natArgUse))
				qw422016.N().S(` &^= 1 << `)
				qw422016.E().V(field.BitNumber)
				qw422016.N().S(`
`)
				if maskFunArg {
					qw422016.N().S(`    }
`)
				}
				qw422016.N().S(`}
`)
			}
		}
		isSetName := struct_.isSetNames[i]
		if isSetName == "" {
			isSetName = struct_.fieldsDec.deconflictName("IsSet" + field.goName)
			struct_.isSetNames[i] = isSetName
		}

		if maskFunArg {
			qw422016.N().S(`func (item *`)
			qw422016.N().S(goName)
			qw422016.N().S(`) `)
			qw422016.N().S(isSetName)
			qw422016.N().S(`(`)
			qw422016.N().S(natArgUse)
			qw422016.N().S(` uint32) bool { return `)
			qw422016.N().S(natArgUse)
			qw422016.N().S(` & (1 << `)
			qw422016.E().V(field.BitNumber)
			qw422016.N().S(`) != 0 }
`)
		} else {
			qw422016.N().S(`func (item *`)
			qw422016.N().S(goName)
			qw422016.N().S(`) `)
			qw422016.N().S(isSetName)
			qw422016.N().S(`() bool { return `)
			qw422016.N().S(natArgUse)
			qw422016.N().S(` & (1 << `)
			qw422016.E().V(field.BitNumber)
			qw422016.N().S(`) != 0 }
`)
		}
		qw422016.N().S(`

`)
	}
}

func (struct_ *TypeRWStruct) writefieldMaskGettersAndSetters(qq422016 qtio422016.Writer, bytesVersion bool, directImports *DirectImports) {
	qw422016 := qt422016.AcquireWriter(qq422016)
	struct_.streamfieldMaskGettersAndSetters(qw422016, bytesVersion, directImports)
	qt422016.ReleaseWriter(qw422016)
}

func (struct_ *TypeRWStruct) fieldMaskGettersAndSetters(bytesVersion bool, directImports *DirectImports) string {
	qb422016 := qt422016.AcquireByteBuffer()
	struct_.writefieldMaskGettersAndSetters(qb422016, bytesVersion, directImports)
	qs422016 := string(qb422016.B)
	qt422016.ReleaseByteBuffer(qb422016)
	return qs422016
}

func (struct_ *TypeRWStruct) streamgenerateJSONCode(qw422016 *qt422016.Writer, bytesVersion bool, directImports *DirectImports) {
	goName := addBytes(struct_.wr.goGlobalName, bytesVersion)
	tlName := struct_.wr.tlName.String()
	natArgsDecl := formatNatArgsDecl(struct_.wr.NatParams)
	natArgsCall := formatNatArgsDeclCall(struct_.wr.NatParams)
	writeNeedsError := struct_.wr.hasErrorInWriteMethods

	if struct_.isTypeDef() {
		field := struct_.Fields[0]
		fieldTypeString := field.t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false)

		if struct_.wr.gen.options.GenerateLegacyJsonRead {
			qw422016.N().S(`func (item *`)
			qw422016.N().S(goName)
			qw422016.N().S(`) ReadJSONLegacy(legacyTypeNames bool, j interface{}`)
			qw422016.N().S(natArgsDecl)
			qw422016.N().S(`) error {
    ptr := (*`)
			qw422016.N().S(fieldTypeString)
			qw422016.N().S(`)(item)
    `)
			qw422016.N().S(field.t.TypeJSONReadingCode(bytesVersion, directImports, struct_.wr.ins, "j", "ptr", formatNatArgs(struct_.Fields, field.natArgs), true))
			qw422016.N().S(`
    return nil
}

`)
		}
		qw422016.N().S(`func (item *`)
		qw422016.N().S(goName)
		qw422016.N().S(`) ReadJSON(legacyTypeNames bool, in *basictl.JsonLexer`)
		qw422016.N().S(natArgsDecl)
		qw422016.N().S(`) error {
    ptr := (*`)
		qw422016.N().S(fieldTypeString)
		qw422016.N().S(`)(item)
    `)
		qw422016.N().S(field.t.TypeJSON2ReadingCode(bytesVersion, directImports, struct_.wr.ins, "in", "ptr", formatNatArgs(struct_.Fields, field.natArgs), true))
		qw422016.N().S(`
    return nil
}

// This method is general version of WriteJSON, use it instead!
func (item *`)
		qw422016.N().S(goName)
		qw422016.N().S(`) WriteJSONGeneral(w []byte`)
		qw422016.N().S(natArgsDecl)
		qw422016.N().S(`) (_ []byte, err error) {
`)
		if writeNeedsError {
			qw422016.N().S(`    return item.WriteJSON(w`)
			qw422016.N().S(natArgsCall)
			qw422016.N().S(`)
`)
		} else {
			qw422016.N().S(`    return item.WriteJSON(w`)
			qw422016.N().S(natArgsCall)
			qw422016.N().S(`), nil
`)
		}
		qw422016.N().S(`}

func (item *`)
		qw422016.N().S(goName)
		qw422016.N().S(`) WriteJSON(w []byte`)
		qw422016.N().S(natArgsDecl)
		qw422016.N().S(`) `)
		qw422016.N().S(wrapWithError(writeNeedsError, "[]byte"))
		qw422016.N().S(` {
    return item.WriteJSONOpt(true, false, w`)
		qw422016.N().S(natArgsCall)
		qw422016.N().S(`)
}

func (item *`)
		qw422016.N().S(goName)
		qw422016.N().S(`) WriteJSONOpt(newTypeNames bool, short bool, w []byte`)
		qw422016.N().S(natArgsDecl)
		qw422016.N().S(`) `)
		qw422016.N().S(wrapWithError(writeNeedsError, "[]byte"))
		qw422016.N().S(` {
    ptr := (*`)
		qw422016.N().S(fieldTypeString)
		qw422016.N().S(`)(item)
    `)
		qw422016.N().S(field.t.TypeJSONWritingCode(bytesVersion, directImports, struct_.wr.ins, "ptr", formatNatArgs(struct_.Fields, field.natArgs), true, writeNeedsError))
		qw422016.N().S(`
`)
		if writeNeedsError {
			qw422016.N().S(`    return w, nil
`)
		} else {
			qw422016.N().S(`    return w
`)
		}
		qw422016.N().S(`}
`)
	} else {
		// Sorting fields is bad idea. Most efficient parsing is if they are in TL order, because no look ahead required

		qw422016.N().S(`
`)
		struct_.streamreadJSONCode(qw422016, bytesVersion, directImports)
		qw422016.N().S(`
`)
		struct_.streamwriteJSONCode(qw422016, bytesVersion, directImports)
		qw422016.N().S(`
`)
	}
	if len(struct_.wr.NatParams) == 0 {
		qw422016.N().S(`func (item *`)
		qw422016.N().S(goName)
		qw422016.N().S(`) MarshalJSON() ([]byte, error) {
`)
		if writeNeedsError {
			qw422016.N().S(`      return item.WriteJSON(nil)
`)
		} else {
			qw422016.N().S(`      return item.WriteJSON(nil), nil
`)
		}
		qw422016.N().S(`}

func (item *`)
		qw422016.N().S(goName)
		qw422016.N().S(`) UnmarshalJSON(b []byte) error {
    if err := item.ReadJSON(true, &basictl.JsonLexer{Data: b}); err != nil {
        return `)
		qw422016.N().S(struct_.wr.gen.InternalPrefix())
		qw422016.N().S(`ErrorInvalidJSON(`)
		qw422016.N().Q(tlName)
		qw422016.N().S(`, err.Error())
    }
    return nil
}
`)
	}
	qw422016.N().S(`
`)
}

func (struct_ *TypeRWStruct) writegenerateJSONCode(qq422016 qtio422016.Writer, bytesVersion bool, directImports *DirectImports) {
	qw422016 := qt422016.AcquireWriter(qq422016)
	struct_.streamgenerateJSONCode(qw422016, bytesVersion, directImports)
	qt422016.ReleaseWriter(qw422016)
}

func (struct_ *TypeRWStruct) generateJSONCode(bytesVersion bool, directImports *DirectImports) string {
	qb422016 := qt422016.AcquireByteBuffer()
	struct_.writegenerateJSONCode(qb422016, bytesVersion, directImports)
	qs422016 := string(qb422016.B)
	qt422016.ReleaseByteBuffer(qb422016)
	return qs422016
}

func (struct_ *TypeRWStruct) streamreadJSONCode(qw422016 *qt422016.Writer, bytesVersion bool, directImports *DirectImports) {
	goName := addBytes(struct_.wr.goGlobalName, bytesVersion)
	tlName := struct_.wr.tlName.String()
	natArgsDecl := formatNatArgsDecl(struct_.wr.NatParams)

	if struct_.wr.gen.options.GenerateLegacyJsonRead {
		qw422016.N().S(`
func (item *`)
		qw422016.N().S(goName)
		qw422016.N().S(`) ReadJSONLegacy(legacyTypeNames bool, j interface{}`)
		qw422016.N().S(natArgsDecl)
		qw422016.N().S(`) error {
    _jm, _ok := j.(map[string]interface{})
    if j != nil && !_ok {
        return `)
		qw422016.N().S(struct_.wr.gen.InternalPrefix())
		qw422016.N().S(`ErrorInvalidJSON(`)
		qw422016.N().Q(tlName)
		qw422016.N().S(`, "expected json object")
    }
`)
		// first we read everything that could be field mask (primitives)
		// then we set explicit/check implicit field masks depending on which keys json object has
		// then we read the rest, passing the same field masks to every field reader

		for _, field := range struct_.Fields {
			// field names will be mandatory soon, except for typedefs which are processed separately

			if field.originalName == "" {
				continue
			}
			jsonField := fmt.Sprintf("_j%s", field.goName)
			itemField := fmt.Sprintf("item.%s", field.goName)

			qw422016.N().S(`    `)
			qw422016.N().S(jsonField)
			qw422016.N().S(` := _jm[`)
			qw422016.N().Q(field.originalName)
			qw422016.N().S(`]
    delete(_jm,`)
			qw422016.N().Q(field.originalName)
			qw422016.N().S(`)
`)
			if field.fieldMask != nil {
				continue
			}
			if _, isScalar := field.t.trw.(*TypeRWPrimitive); !isScalar {
				continue
			}
			qw422016.N().S(`    `)
			qw422016.N().S(field.t.TypeJSONReadingCode(bytesVersion, directImports, struct_.wr.ins, jsonField, itemField, formatNatArgs(struct_.Fields, field.natArgs), field.recursive))
			qw422016.N().S(`
`)
		}
		qw422016.N().S(`    for k := range _jm {
        return `)
		qw422016.N().S(struct_.wr.gen.InternalPrefix())
		qw422016.N().S(`ErrorInvalidJSONExcessElement(`)
		qw422016.N().Q(tlName)
		qw422016.N().S(`, k)
    }
`)
		for _, field := range struct_.Fields {
			// field names will be mandatory soon, except for typedefs which are processed separately

			if field.originalName == "" {
				continue
			}
			if field.fieldMask == nil {
				continue
			}
			// If field depends on implicit field mask and set in json, but field mask bit not set, this is error
			// Otherwise field will be silently ignored, to caller surprise
			//
			// If field depends on explicit field mask and set in json, we set the bit
			// Setting field is convenient to set field mask bits. Also works for true-types
			//
			// We must first set all bits, only then read fields, so that all fields depend on te same set of bits

			jsonField := fmt.Sprintf("_j%s", field.goName)

			if field.t.IsTrueType() {
				if !field.fieldMask.isField {
					qw422016.N().S(`    if `)
					qw422016.N().S(jsonField)
					qw422016.N().S(` != nil {
        return `)
					qw422016.N().S(struct_.wr.gen.InternalPrefix())
					qw422016.N().S(`ErrorInvalidJSON(`)
					qw422016.N().Q(tlName)
					qw422016.N().S(`, "implicit true field '`)
					qw422016.N().S(field.originalName)
					qw422016.N().S(`' cannot be defined, set fieldmask instead")
    }
`)
				} else {
					qw422016.N().S(`    if `)
					qw422016.N().S(jsonField)
					qw422016.N().S(` != nil {
        _bit := false
        if err := `)
					qw422016.N().S(struct_.wr.gen.InternalPrefix())
					qw422016.N().S(`JsonReadBool(`)
					qw422016.N().S(jsonField)
					qw422016.N().S(`, &_bit); err != nil {
            return err
        }
        if _bit {
            `)
					qw422016.N().S(formatNatArg(struct_.Fields, *field.fieldMask))
					qw422016.N().S(` |= 1 << `)
					qw422016.E().V(field.BitNumber)
					qw422016.N().S(`
        } else {
            `)
					qw422016.N().S(formatNatArg(struct_.Fields, *field.fieldMask))
					qw422016.N().S(` &^= 1 << `)
					qw422016.E().V(field.BitNumber)
					qw422016.N().S(`
        }
    }
`)
				}
			} else {
				if !field.fieldMask.isField {
					qw422016.N().S(`    if `)
					qw422016.N().S(formatNatArg(struct_.Fields, *field.fieldMask))
					qw422016.N().S(` & (1 << `)
					qw422016.E().V(field.BitNumber)
					qw422016.N().S(`) == 0 && `)
					qw422016.N().S(jsonField)
					qw422016.N().S(` != nil {
        return `)
					qw422016.N().S(struct_.wr.gen.InternalPrefix())
					qw422016.N().S(`ErrorInvalidJSON(`)
					qw422016.N().Q(tlName)
					qw422016.N().S(`, "field '`)
					qw422016.N().S(field.originalName)
					qw422016.N().S(`' is defined, while corresponding implicit fieldmask bit is 0")
    }
`)
				} else {
					qw422016.N().S(`    if `)
					qw422016.N().S(jsonField)
					qw422016.N().S(` != nil {
        `)
					qw422016.N().S(formatNatArg(struct_.Fields, *field.fieldMask))
					qw422016.N().S(` |= 1 << `)
					qw422016.E().V(field.BitNumber)
					qw422016.N().S(`
    }
`)
				}
			}
		}
		for _, field := range struct_.Fields {
			// field names will be mandatory soon, except for typedefs which are processed separately

			if field.originalName == "" {
				continue
			}
			jsonField := fmt.Sprintf("_j%s", field.goName)
			itemField := fmt.Sprintf("item.%s", field.goName)

			if field.t.IsTrueType() {
				if field.fieldMask == nil {
					tmpName := fmt.Sprintf("_%s", field.goName)
					readingCode := field.t.TypeJSONReadingCode(bytesVersion, directImports, struct_.wr.ins, jsonField, tmpName, formatNatArgs(struct_.Fields, field.natArgs), field.recursive)

					fieldTypeString := field.t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false)

					qw422016.N().S(`    var `)
					qw422016.N().S(tmpName)
					qw422016.N().S(` `)
					qw422016.N().S(fieldTypeString)
					qw422016.N().S(`
    `)
					qw422016.N().S(readingCode)
					qw422016.N().S(`
`)
				}
				continue
			}
			readingCode := field.t.TypeJSONReadingCode(bytesVersion, directImports, struct_.wr.ins, jsonField, itemField, formatNatArgs(struct_.Fields, field.natArgs), field.recursive)
			// TODO - for recursive field, add initialization
			resettingCode := field.t.TypeResettingCode(bytesVersion, directImports, struct_.wr.ins, itemField, field.recursive)

			if field.fieldMask != nil {
				if !field.fieldMask.isField {
					qw422016.N().S(`    if `)
					qw422016.N().S(formatNatArg(struct_.Fields, *field.fieldMask))
					qw422016.N().S(` & (1 << `)
					qw422016.E().V(field.BitNumber)
					qw422016.N().S(`) != 0 {
`)
					if field.recursive {
						fieldTypeString := field.t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false)

						qw422016.N().S(`        if item.`)
						qw422016.N().S(field.goName)
						qw422016.N().S(` == nil {
            var value `)
						qw422016.N().S(fieldTypeString)
						qw422016.N().S(`
            item.`)
						qw422016.N().S(field.goName)
						qw422016.N().S(` = &value
        }
`)
					}
					qw422016.N().S(`        `)
					qw422016.N().S(readingCode)
					qw422016.N().S(`
    } else {
`)
					if field.recursive {
						qw422016.N().S(`        if item.`)
						qw422016.N().S(field.goName)
						qw422016.N().S(` != nil {
            `)
						qw422016.N().S(resettingCode)
						qw422016.N().S(`
        }
`)
					} else {
						qw422016.N().S(`        `)
						qw422016.N().S(resettingCode)
						qw422016.N().S(`
`)
					}
					qw422016.N().S(`    }
`)
				} else {
					qw422016.N().S(`    if `)
					qw422016.N().S(jsonField)
					qw422016.N().S(` != nil {
`)
					if field.recursive {
						fieldTypeString := field.t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false)

						qw422016.N().S(`        if item.`)
						qw422016.N().S(field.goName)
						qw422016.N().S(` == nil {
            var value `)
						qw422016.N().S(fieldTypeString)
						qw422016.N().S(`
            item.`)
						qw422016.N().S(field.goName)
						qw422016.N().S(` = &value
        }
`)
					}
					qw422016.N().S(`        `)
					qw422016.N().S(readingCode)
					qw422016.N().S(`
    } else {
`)
					if field.recursive {
						qw422016.N().S(`        if item.`)
						qw422016.N().S(field.goName)
						qw422016.N().S(` != nil {
            `)
						qw422016.N().S(resettingCode)
						qw422016.N().S(`
        }
`)
					} else {
						qw422016.N().S(`        `)
						qw422016.N().S(resettingCode)
						qw422016.N().S(`
`)
					}
					qw422016.N().S(`    }
`)
				}
			} else {
				if _, isScalar := field.t.trw.(*TypeRWPrimitive); !isScalar {
					qw422016.N().S(`    `)
					qw422016.N().S(readingCode)
					qw422016.N().S(`
`)
				}
			}
		}
		qw422016.N().S(`    return nil
}

`)
	}
	qw422016.N().S(`func (item *`)
	qw422016.N().S(goName)
	qw422016.N().S(`) ReadJSON(legacyTypeNames bool, in *basictl.JsonLexer`)
	qw422016.N().S(natArgsDecl)
	qw422016.N().S(`) error {
`)
	// init values for after read processing
	needSomeRaw := false

	for _, field := range struct_.Fields {
		/* TODO: skip anonymous names */

		if field.originalName == "" {
			continue
		}
		if field.t.IsTrueType() && field.fieldMask == nil {
			continue
		}
		if field.t.IsTrueType() && !field.fieldMask.isField {
			continue
		}
		if field.t.IsTrueType() {
			qw422016.N().S(`    var trueType`)
			qw422016.N().S(field.goName)
			qw422016.N().S(`Presented bool
    var trueType`)
			qw422016.N().S(field.goName)
			qw422016.N().S(`Value     bool
`)
		} else if !field.HasNatArguments() {
			/* TODO: can be optimized to read with only external nats */

			qw422016.N().S(`    var prop`)
			qw422016.N().S(field.goName)
			qw422016.N().S(`Presented bool
`)
		} else {
			qw422016.N().S(`    var raw`)
			qw422016.N().S(field.goName)
			qw422016.N().S(` []byte
`)
		}
		needSomeRaw = true

	}
	if needSomeRaw {
		qw422016.N().S(`
`)
	}
	/* BLOCK: main read */

	qw422016.N().S(`    if in != nil {
        in.Delim('{')
        if !in.Ok() {
            return in.Error()
        }
        for !in.IsDelim('}') {
`)
	if len(struct_.Fields) == 0 {
		qw422016.N().S(`            return `)
		qw422016.N().S(struct_.wr.gen.InternalPrefix())
		qw422016.N().S(`ErrorInvalidJSON(`)
		qw422016.N().Q(tlName)
		qw422016.N().S(`, "this object can't have properties")
`)
	} else {
		qw422016.N().S(`            key := in.UnsafeFieldName(true)
            in.WantColon()
            switch key {
`)
		for _, field := range struct_.Fields {
			/* TODO: skip anonymous names */

			if field.originalName == "" {
				continue
			}
			qw422016.N().S(`                case "`)
			qw422016.N().S(field.originalName)
			qw422016.N().S(`":
`)
			reader := "in"
			itemField := fmt.Sprintf("item.%s", field.goName)

			if field.t.IsTrueType() {
				if field.fieldMask == nil {
					qw422016.N().S(`                    var tmp`)
					qw422016.N().S(field.goName)
					qw422016.N().S(` `)
					qw422016.N().S(field.t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false))
					qw422016.N().S(`
                    `)
					qw422016.N().S(field.t.TypeJSON2ReadingCode(bytesVersion, directImports, struct_.wr.ins, "in", "tmp"+field.goName, formatNatArgs(struct_.Fields, field.natArgs), field.recursive))
					qw422016.N().S(`
`)
				} else if !field.fieldMask.isField {
					qw422016.N().S(`                    return `)
					qw422016.N().S(struct_.wr.gen.InternalPrefix())
					qw422016.N().S(`ErrorInvalidJSON(`)
					qw422016.N().Q(tlName)
					qw422016.N().S(`, "implicit true field '`)
					qw422016.N().S(field.originalName)
					qw422016.N().S(`' cannot be defined, set fieldmask instead")
`)
				} else {
					qw422016.N().S(`                    if trueType`)
					qw422016.N().S(field.goName)
					qw422016.N().S(`Presented {
                        return `)
					qw422016.N().S(struct_.wr.gen.InternalPrefix())
					qw422016.N().S(`ErrorInvalidJSONWithDuplicatingKeys(`)
					qw422016.N().Q(tlName)
					qw422016.N().S(`, `)
					qw422016.N().Q(field.originalName)
					qw422016.N().S(`)
                    }
                    if err := `)
					qw422016.N().S(struct_.wr.gen.InternalPrefix())
					qw422016.N().S(`Json2ReadBool(in, &trueType`)
					qw422016.N().S(field.goName)
					qw422016.N().S(`Value); err != nil {
                        return err
                    }
                    trueType`)
					qw422016.N().S(field.goName)
					qw422016.N().S(`Presented = true
`)
				}
			} else if !field.HasNatArguments() {
				qw422016.N().S(`                    if prop`)
				qw422016.N().S(field.goName)
				qw422016.N().S(`Presented {
                        return `)
				qw422016.N().S(struct_.wr.gen.InternalPrefix())
				qw422016.N().S(`ErrorInvalidJSONWithDuplicatingKeys(`)
				qw422016.N().Q(tlName)
				qw422016.N().S(`, `)
				qw422016.N().Q(field.originalName)
				qw422016.N().S(`)
                    }
`)
				if field.recursive {
					qw422016.N().S(`                    if `)
					qw422016.N().S(itemField)
					qw422016.N().S(` == nil {
                        var value `)
					qw422016.N().S(field.t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false))
					qw422016.N().S(`
                        `)
					qw422016.N().S(itemField)
					qw422016.N().S(` = &value
                    }
`)
				}
				if field.IsAffectedByExternalFieldMask() {
					qw422016.N().S(`                    if `)
					qw422016.N().S(formatNatArg(struct_.Fields, *field.fieldMask))
					qw422016.N().S(` & (1 << `)
					qw422016.E().V(field.BitNumber)
					qw422016.N().S(`) == 0 {
                        return `)
					qw422016.N().S(struct_.wr.gen.InternalPrefix())
					qw422016.N().S(`ErrorInvalidJSON(`)
					qw422016.N().Q(tlName)
					qw422016.N().S(`, "field '`)
					qw422016.N().S(field.originalName)
					qw422016.N().S(`' is defined, while corresponding implicit fieldmask bit is 0")
                    }
`)
				}
				qw422016.N().S(`                    `)
				qw422016.N().S(field.t.TypeJSON2ReadingCode(bytesVersion, directImports, struct_.wr.ins, reader, itemField, formatNatArgs(struct_.Fields, field.natArgs), field.recursive))
				qw422016.N().S(`
                    prop`)
				qw422016.N().S(field.goName)
				qw422016.N().S(`Presented = true
`)
			} else {
				qw422016.N().S(`                    if raw`)
				qw422016.N().S(field.goName)
				qw422016.N().S(` != nil {
                        return `)
				qw422016.N().S(struct_.wr.gen.InternalPrefix())
				qw422016.N().S(`ErrorInvalidJSONWithDuplicatingKeys(`)
				qw422016.N().Q(tlName)
				qw422016.N().S(`, `)
				qw422016.N().Q(field.originalName)
				qw422016.N().S(`)
                    }
                    raw`)
				qw422016.N().S(field.goName)
				qw422016.N().S(` = in.Raw()
                    if !in.Ok() {
                        return in.Error()
                    }
`)
			}
		}
		qw422016.N().S(`                default: return `)
		qw422016.N().S(struct_.wr.gen.InternalPrefix())
		qw422016.N().S(`ErrorInvalidJSONExcessElement(`)
		qw422016.N().Q(tlName)
		qw422016.N().S(`, key)
            }
            in.WantComma()
`)
	}
	qw422016.N().S(`        }
        in.Delim('}')
        if !in.Ok() {
            return in.Error()
        }
    }
`)
	/* BLOCK: reset independent props with they are absent */

	for _, field := range struct_.Fields {
		/* TODO: skip anonymous names */

		if field.originalName == "" {
			continue
		}
		if field.t.IsTrueType() {
			continue
		}
		if !field.HasNatArguments() {
			qw422016.N().S(`    if !prop`)
			qw422016.N().S(field.goName)
			qw422016.N().S(`Presented {
`)
			if field.recursive {
				qw422016.N().S(`        if item.`)
				qw422016.N().S(field.goName)
				qw422016.N().S(` != nil {
            `)
				qw422016.N().S(field.t.TypeResettingCode(bytesVersion, directImports, struct_.wr.ins, "item."+field.goName, field.recursive))
				qw422016.N().S(`
        }
`)
			} else {
				qw422016.N().S(`        `)
				qw422016.N().S(field.t.TypeResettingCode(bytesVersion, directImports, struct_.wr.ins, "item."+field.goName, field.recursive))
				qw422016.N().S(`
`)
			}
			qw422016.N().S(`    }
`)
		}
	}
	/* BLOCK: bit fix */

	for _, field := range struct_.Fields {
		/* TODO: skip anonymous names */

		if field.originalName == "" {
			continue
		}
		if field.IsAffectingLocalFieldMasks() {
			presentCondition := "true"
			if field.t.IsTrueType() {
				presentCondition = "trueType" + field.goName + "Presented"
			} else if !field.HasNatArguments() {
				presentCondition = "prop" + field.goName + "Presented"
			} else {
				presentCondition = "raw" + field.goName + " != nil"
			}
			affectedFields, bits := struct_.AllAffectedFieldMasks(field)

			qw422016.N().S(`    if `)
			qw422016.N().S(presentCondition)
			qw422016.N().S(` {
`)
			firstAffectedNat := 0

			if field.t.IsTrueType() {
				/* COMMENT: if trueType value is false bit sets to zero */
				firstAffectedNat = 1

				qw422016.N().S(`        if trueType`)
				qw422016.N().S(field.goName)
				qw422016.N().S(`Value {
            `)
				qw422016.N().S(formatNatArg(struct_.Fields, *field.fieldMask))
				qw422016.N().S(` |= 1 << `)
				qw422016.E().V(field.BitNumber)
				qw422016.N().S(`
        }
`)
			}
			for i := firstAffectedNat; i < len(affectedFields); i++ {
				qw422016.N().S(`        item.`)
				qw422016.N().S(affectedFields[i].goName)
				qw422016.N().S(` |= 1 << `)
				qw422016.E().V(bits[i])
				qw422016.N().S(`
`)
			}
			qw422016.N().S(`    }
`)
		}
	}
	/* BLOCK: read rest fields */

	for _, field := range struct_.Fields {
		/* TODO: skip anonymous names */

		if field.originalName == "" {
			continue
		}
		if field.t.IsTrueType() || !field.HasNatArguments() {
			continue
		}
		presentCondition := "raw" + field.goName + " != nil"

		if field.fieldMask != nil {
			qw422016.N().S(`        if `)
			qw422016.N().S(formatNatArg(struct_.Fields, *field.fieldMask))
			qw422016.N().S(` & (1 << `)
			qw422016.E().V(field.BitNumber)
			qw422016.N().S(`) == 0 {
`)
			if field.IsAffectedByExternalFieldMask() {
				qw422016.N().S(`            if `)
				qw422016.N().S(presentCondition)
				qw422016.N().S(` {
                return `)
				qw422016.N().S(struct_.wr.gen.InternalPrefix())
				qw422016.N().S(`ErrorInvalidJSON(`)
				qw422016.N().Q(tlName)
				qw422016.N().S(`, "field '`)
				qw422016.N().S(field.originalName)
				qw422016.N().S(`' is defined, while corresponding implicit fieldmask bit is 0")
            }
`)
			}
			resetCode := field.t.TypeResettingCode(bytesVersion, directImports, struct_.wr.ins, fmt.Sprintf("item.%s", field.goName), field.recursive)

			if field.recursive {
				qw422016.N().S(`            if item.`)
				qw422016.N().S(field.goName)
				qw422016.N().S(` != nil {
                `)
				qw422016.N().S(resetCode)
				qw422016.N().S(`
            }
`)
			} else {
				qw422016.N().S(`            `)
				qw422016.N().S(resetCode)
				qw422016.N().S(`
`)
			}
			qw422016.N().S(`        } else {
            `)
			struct_.streamreadJsonWithResetForRaw(qw422016, field, bytesVersion, directImports)
			qw422016.N().S(`
        }
`)
		} else {
			qw422016.N().S(`        `)
			struct_.streamreadJsonWithResetForRaw(qw422016, field, bytesVersion, directImports)
			qw422016.N().S(`
`)
		}
	}
	/* BLOCK: trueType with false values validation */

	for _, field := range struct_.Fields {
		if !field.t.IsTrueType() || field.fieldMask == nil || !field.fieldMask.isField {
			continue
		}
		fieldMask := struct_.Fields[field.fieldMask.FieldIndex]
		fieldMaskName := fieldMask.goName
		bit := field.BitNumber

		qw422016.N().S(`        // tries to set bit to zero if it is 1
        if trueType`)
		qw422016.N().S(field.goName)
		qw422016.N().S(`Presented && !trueType`)
		qw422016.N().S(field.goName)
		qw422016.N().S(`Value && (item.`)
		qw422016.N().S(fieldMaskName)
		qw422016.N().S(` & (1 << `)
		qw422016.E().V(bit)
		qw422016.N().S(`) != 0) {
            return `)
		qw422016.N().S(struct_.wr.gen.InternalPrefix())
		qw422016.N().S(`ErrorInvalidJSON(`)
		qw422016.N().Q(tlName)
		qw422016.N().S(`, "fieldmask bit `)
		qw422016.N().S(fieldMask.originalName)
		qw422016.N().S(`.`)
		qw422016.N().D(field.fieldMask.FieldIndex)
		qw422016.N().S(` is indefinite because of the contradictions in values")
        }
`)
	}
	qw422016.N().S(`    return nil
}

`)
}

func (struct_ *TypeRWStruct) writereadJSONCode(qq422016 qtio422016.Writer, bytesVersion bool, directImports *DirectImports) {
	qw422016 := qt422016.AcquireWriter(qq422016)
	struct_.streamreadJSONCode(qw422016, bytesVersion, directImports)
	qt422016.ReleaseWriter(qw422016)
}

func (struct_ *TypeRWStruct) readJSONCode(bytesVersion bool, directImports *DirectImports) string {
	qb422016 := qt422016.AcquireByteBuffer()
	struct_.writereadJSONCode(qb422016, bytesVersion, directImports)
	qs422016 := string(qb422016.B)
	qt422016.ReleaseByteBuffer(qb422016)
	return qs422016
}

func (struct_ *TypeRWStruct) streamreadJsonWithResetForRaw(qw422016 *qt422016.Writer, field Field, bytesVersion bool, directImports *DirectImports) {
	qw422016.N().S(`        var in`)
	qw422016.N().S(field.goName)
	qw422016.N().S(`Pointer *basictl.JsonLexer
        in`)
	qw422016.N().S(field.goName)
	qw422016.N().S(` := basictl.JsonLexer{Data:raw`)
	qw422016.N().S(field.goName)
	qw422016.N().S(`}
        if raw`)
	qw422016.N().S(field.goName)
	qw422016.N().S(` != nil {
            in`)
	qw422016.N().S(field.goName)
	qw422016.N().S(`Pointer = &in`)
	qw422016.N().S(field.goName)
	qw422016.N().S(`
        }
`)
	readingCode := field.t.TypeJSON2ReadingCode(bytesVersion, directImports, struct_.wr.ins, "in"+field.goName+"Pointer", "item."+field.goName, formatNatArgs(struct_.Fields, field.natArgs), field.recursive)

	if field.recursive {
		qw422016.N().S(`        if item.`)
		qw422016.N().S(field.goName)
		qw422016.N().S(` == nil {
            var value `)
		qw422016.N().S(field.t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false))
		qw422016.N().S(`
            item.`)
		qw422016.N().S(field.goName)
		qw422016.N().S(` = &value
        }
`)
	}
	qw422016.N().S(`        `)
	qw422016.N().S(readingCode)
	qw422016.N().S(`
`)
}

func (struct_ *TypeRWStruct) writereadJsonWithResetForRaw(qq422016 qtio422016.Writer, field Field, bytesVersion bool, directImports *DirectImports) {
	qw422016 := qt422016.AcquireWriter(qq422016)
	struct_.streamreadJsonWithResetForRaw(qw422016, field, bytesVersion, directImports)
	qt422016.ReleaseWriter(qw422016)
}

func (struct_ *TypeRWStruct) readJsonWithResetForRaw(field Field, bytesVersion bool, directImports *DirectImports) string {
	qb422016 := qt422016.AcquireByteBuffer()
	struct_.writereadJsonWithResetForRaw(qb422016, field, bytesVersion, directImports)
	qs422016 := string(qb422016.B)
	qt422016.ReleaseByteBuffer(qb422016)
	return qs422016
}

func (struct_ *TypeRWStruct) streamwriteJSONCode(qw422016 *qt422016.Writer, bytesVersion bool, directImports *DirectImports) {
	goName := addBytes(struct_.wr.goGlobalName, bytesVersion)
	natArgsDecl := formatNatArgsDecl(struct_.wr.NatParams)
	natArgsCall := formatNatArgsDeclCall(struct_.wr.NatParams)
	writeNeedsError := struct_.wr.hasErrorInWriteMethods

	qw422016.N().S(`
// This method is general version of WriteJSON, use it instead!
func (item *`)
	qw422016.N().S(goName)
	qw422016.N().S(`) WriteJSONGeneral(w []byte`)
	qw422016.N().S(natArgsDecl)
	qw422016.N().S(`) (_ []byte, err error) {
`)
	if writeNeedsError {
		qw422016.N().S(`    return item.WriteJSONOpt(true, false, w`)
		qw422016.N().S(natArgsCall)
		qw422016.N().S(`)
`)
	} else {
		qw422016.N().S(`    return item.WriteJSONOpt(true, false, w`)
		qw422016.N().S(natArgsCall)
		qw422016.N().S(`), nil
`)
	}
	qw422016.N().S(`}

func (item *`)
	qw422016.N().S(goName)
	qw422016.N().S(`) WriteJSON(w []byte`)
	qw422016.N().S(natArgsDecl)
	qw422016.N().S(`) `)
	qw422016.N().S(wrapWithError(writeNeedsError, "[]byte"))
	qw422016.N().S(` {
    return item.WriteJSONOpt(true, false, w`)
	qw422016.N().S(natArgsCall)
	qw422016.N().S(`)
}
func (item *`)
	qw422016.N().S(goName)
	qw422016.N().S(`) WriteJSONOpt(newTypeNames bool, short bool, w []byte`)
	qw422016.N().S(natArgsDecl)
	qw422016.N().S(`) `)
	qw422016.N().S(wrapWithError(writeNeedsError, "[]byte"))
	qw422016.N().S(` {
    w = append(w, '{')
`)
	for _, field := range struct_.Fields {
		// field names will be mandatory soon, except for typedefs which are processed separately

		if field.originalName == "" {
			continue
		}
		if field.t.IsTrueType() {
			if field.fieldMask != nil && (field.fieldMask.isField || field.fieldMask.isArith) {
				qw422016.N().S(`    if `)
				qw422016.N().S(formatNatArg(struct_.Fields, *field.fieldMask))
				qw422016.N().S(` & (1<<`)
				qw422016.E().V(field.BitNumber)
				qw422016.N().S(`) != 0 {
        w = basictl.JSONAddCommaIfNeeded(w)
        w = append(w, `)
				qw422016.N().S("`")
				qw422016.N().Q(field.originalName)
				qw422016.N().S(`:true`)
				qw422016.N().S("`")
				qw422016.N().S(`...)
    }
`)
			}
		} else {
			if field.fieldMask != nil {
				qw422016.N().S(`    if `)
				qw422016.N().S(formatNatArg(struct_.Fields, *field.fieldMask))
				qw422016.N().S(` & (1<<`)
				qw422016.E().V(field.BitNumber)
				qw422016.N().S(`) != 0 {
`)
			}
			if field.fieldMask == nil && field.t.TypeJSONEmptyCondition(bytesVersion, fmt.Sprintf("item.%s", field.goName), field.recursive) != "" {
				qw422016.N().S(`                backupIndex`)
				qw422016.N().S(field.goName)
				qw422016.N().S(` := len(w)
`)
			}
			qw422016.N().S(`                w = basictl.JSONAddCommaIfNeeded(w)
                w = append(w, `)
			qw422016.N().S("`")
			qw422016.N().S(`"`)
			qw422016.E().S(field.originalName)
			qw422016.N().S(`":`)
			qw422016.N().S("`")
			qw422016.N().S(`...)
        `)
			qw422016.N().S(field.t.TypeJSONWritingCode(bytesVersion, directImports, struct_.wr.ins, fmt.Sprintf("item.%s", field.goName), formatNatArgs(struct_.Fields, field.natArgs), field.recursive, field.t.hasErrorInWriteMethods))
			qw422016.N().S(`
`)
			if field.fieldMask == nil && field.t.TypeJSONEmptyCondition(bytesVersion, fmt.Sprintf("item.%s", field.goName), field.recursive) != "" {
				qw422016.N().S(`                if (`)
				qw422016.N().S(field.t.TypeJSONEmptyCondition(bytesVersion, fmt.Sprintf("item.%s", field.goName), field.recursive))
				qw422016.N().S(`) == false {
                        w = w[:backupIndex`)
				qw422016.N().S(field.goName)
				qw422016.N().S(`]
                }
`)
			}
			if field.fieldMask != nil {
				qw422016.N().S(`    }
`)
			}
		}
	}
	if writeNeedsError {
		qw422016.N().S(`    return append(w, '}'), nil
`)
	} else {
		qw422016.N().S(`    return append(w, '}')
`)
	}
	qw422016.N().S(`}
`)
}

func (struct_ *TypeRWStruct) writewriteJSONCode(qq422016 qtio422016.Writer, bytesVersion bool, directImports *DirectImports) {
	qw422016 := qt422016.AcquireWriter(qq422016)
	struct_.streamwriteJSONCode(qw422016, bytesVersion, directImports)
	qt422016.ReleaseWriter(qw422016)
}

func (struct_ *TypeRWStruct) writeJSONCode(bytesVersion bool, directImports *DirectImports) string {
	qb422016 := qt422016.AcquireByteBuffer()
	struct_.writewriteJSONCode(qb422016, bytesVersion, directImports)
	qs422016 := string(qb422016.B)
	qt422016.ReleaseByteBuffer(qb422016)
	return qs422016
}

func (struct_ *TypeRWStruct) streamfunctionCode(qw422016 *qt422016.Writer, bytesVersion bool, directImports *DirectImports) {
	if struct_.ResultType == nil {
		return
	}
	goName := addBytes(struct_.wr.goGlobalName, bytesVersion)
	retArg := struct_.ResultType.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false)

	qw422016.N().S(`func (item *`)
	qw422016.N().S(goName)
	qw422016.N().S(`) ReadResult(w []byte, ret *`)
	qw422016.N().S(retArg)
	qw422016.N().S(`) (_ []byte, err error) {
    `)
	qw422016.N().S(struct_.ResultType.TypeReadingCode(bytesVersion, directImports, struct_.wr.ins, "ret", false, formatNatArgs(struct_.Fields, struct_.ResultNatArgs), true, true))
	qw422016.N().S(`
}

func (item *`)
	qw422016.N().S(goName)
	qw422016.N().S(`) WriteResult(w []byte, ret `)
	qw422016.N().S(retArg)
	qw422016.N().S(`) (_ []byte, err error) {
    `)
	qw422016.N().S(struct_.ResultType.TypeWritingCode(bytesVersion, directImports, struct_.wr.ins, "ret", false, formatNatArgs(struct_.Fields, struct_.ResultNatArgs), false, false, struct_.ResultType.hasErrorInWriteMethods))
	qw422016.N().S(`
    return w, nil
}
`)
	if struct_.wr.gen.options.GenerateTL2 && struct_.wr.wantsTL2 {
		qw422016.N().S(`
func (item *`)
		qw422016.N().S(goName)
		qw422016.N().S(`) ReadResultTL2(w []byte, ret *`)
		qw422016.N().S(retArg)
		qw422016.N().S(`) (_ []byte, err error) {
    `)
		qw422016.N().S(struct_.ResultType.ReadTL2Call(directImports, bytesVersion, "w", "ret", false, struct_.wr.ins, true, formatNatArgs(struct_.Fields, struct_.ResultNatArgs)))
		qw422016.N().S(`
    return w, nil
}

func (item *`)
		qw422016.N().S(goName)
		qw422016.N().S(`) WriteResultTL2(w []byte, sizes []int, ret `)
		qw422016.N().S(retArg)
		qw422016.N().S(`) (_ []byte, _ []int, err error) {
    `)
		qw422016.N().S(struct_.ResultType.WriteTL2Call(directImports, bytesVersion, "sizes", "w", "ret", false, struct_.wr.ins, false, formatNatArgs(struct_.Fields, struct_.ResultNatArgs)))
		qw422016.N().S(`
    return w, sizes, nil
}
`)
	}
	qw422016.N().S(`
func (item *`)
	qw422016.N().S(goName)
	qw422016.N().S(`) ReadResultJSON(legacyTypeNames bool, in *basictl.JsonLexer, ret *`)
	qw422016.N().S(retArg)
	qw422016.N().S(`) error {
    `)
	qw422016.N().S(struct_.ResultType.TypeJSON2ReadingCode(bytesVersion, directImports, struct_.wr.ins, "in", "ret", formatNatArgs(struct_.Fields, struct_.ResultNatArgs), true))
	qw422016.N().S(`
    return nil
}

func (item *`)
	qw422016.N().S(goName)
	qw422016.N().S(`) WriteResultJSON(w []byte, ret `)
	qw422016.N().S(retArg)
	qw422016.N().S(`) (_ []byte, err error) {
    return item.writeResultJSON(true, false, w, ret)
}

func (item *`)
	qw422016.N().S(goName)
	qw422016.N().S(`) writeResultJSON(newTypeNames bool, short bool, w []byte, ret `)
	qw422016.N().S(retArg)
	qw422016.N().S(`) (_ []byte, err error) {
    `)
	qw422016.N().S(struct_.ResultType.TypeJSONWritingCode(bytesVersion, directImports, struct_.wr.ins, "ret", formatNatArgs(struct_.Fields, struct_.ResultNatArgs), false, struct_.ResultType.hasErrorInWriteMethods))
	qw422016.N().S(`
    return w, nil
}

func (item *`)
	qw422016.N().S(goName)
	qw422016.N().S(`) ReadResultWriteResultJSON(r []byte, w []byte) (_ []byte, _ []byte, err error) {
  var ret `)
	qw422016.N().S(retArg)
	qw422016.N().S(`
  if r, err = item.ReadResult(r, &ret); err != nil {
    return r, w, err
  }
  w, err = item.WriteResultJSON(w, ret)
  return r, w, err
}

func (item *`)
	qw422016.N().S(goName)
	qw422016.N().S(`) ReadResultWriteResultJSONOpt(newTypeNames bool, short bool, r []byte, w []byte) (_ []byte, _ []byte, err error) {
  var ret `)
	qw422016.N().S(retArg)
	qw422016.N().S(`
  if r, err = item.ReadResult(r, &ret); err != nil {
    return r, w, err
  }
  w, err = item.writeResultJSON(newTypeNames, short, w, ret)
  return r, w, err
}

func (item *`)
	qw422016.N().S(goName)
	qw422016.N().S(`) ReadResultJSONWriteResult(r []byte, w []byte) ([]byte, []byte, error) {
  var ret `)
	qw422016.N().S(retArg)
	qw422016.N().S(`
  err := item.ReadResultJSON(true, &basictl.JsonLexer{Data: r}, &ret)
  if err != nil {
    return r, w, err
  }
  w, err = item.WriteResult(w, ret)
  return r, w, err
}
`)
	for fieldId, field := range struct_.Fields {
		if _, affectedBits := struct_.GetFieldNatPropertiesAsUsageMap(fieldId, false, true); len(affectedBits) != 0 {
			bits := make([]uint32, 0)
			for i := range affectedBits {
				bits = append(bits, i)
			}
			sort.Slice(bits, func(i, j int) bool {
				return bits[i] < bits[j]
			})

			for _, bit := range bits {
				bitUsage := affectedBits[bit]
				affectedTypes := make([]*TypeRWStruct, 0)
				for i := range bitUsage.AffectedFields {
					affectedTypes = append(affectedTypes, i)
				}
				sort.Slice(affectedTypes, func(i, j int) bool {
					return TypeRWWrapperLessGlobal(affectedTypes[i].wr, affectedTypes[j].wr) > 0
				})

				for _, affectedType := range affectedTypes {
					affectedFieldsByBit := bitUsage.AffectedFields[affectedType]
					affectedFieldsByBit = utils.SetToSlice(utils.SliceToSet(affectedFieldsByBit))
					sort.Slice(affectedFieldsByBit, func(i, j int) bool {
						return affectedFieldsByBit[i] < affectedFieldsByBit[j]
					})
					fieldNames := make([]string, len(affectedFieldsByBit))
					fieldNamesForComment := make([]string, len(affectedFieldsByBit))

					for i := range fieldNames {
						fieldNames[i] = affectedType.Fields[affectedFieldsByBit[i]].goName
						fieldNamesForComment[i] = "\"" + affectedType.Fields[affectedFieldsByBit[i]].originalName + "\""
					}

					mergedFields := strings.Join(fieldNames, "And")
					mergedFieldsForComment := strings.Join(fieldNamesForComment, ", ")
					maybeS := ""
					if len(affectedFieldsByBit) > 1 {
						maybeS = "s"
					}

					qw422016.N().S(`// Set field`)
					qw422016.N().S(maybeS)
					qw422016.N().S(` `)
					qw422016.N().S(mergedFieldsForComment)
					qw422016.N().S(` in "`)
					qw422016.N().S(affectedType.wr.tlName.String())
					qw422016.N().S(`" by changing fieldMask "`)
					qw422016.N().S(field.originalName)
					qw422016.N().S(`"
func (item *`)
					qw422016.N().S(goName)
					qw422016.N().S(`) Set`)
					qw422016.N().S(affectedType.wr.goGlobalName)
					qw422016.N().S(mergedFields)
					qw422016.N().S(`(value bool) {
    if value {
        item.`)
					qw422016.N().S(field.goName)
					qw422016.N().S(` |= 1 << `)
					qw422016.N().D(int(bit))
					qw422016.N().S(`
    } else {
        item.`)
					qw422016.N().S(field.goName)
					qw422016.N().S(` &^= 1 << `)
					qw422016.N().D(int(bit))
					qw422016.N().S(`
    }
}

`)
				}
			}
		}
	}
	qw422016.N().S(`
`)
}

func (struct_ *TypeRWStruct) writefunctionCode(qq422016 qtio422016.Writer, bytesVersion bool, directImports *DirectImports) {
	qw422016 := qt422016.AcquireWriter(qq422016)
	struct_.streamfunctionCode(qw422016, bytesVersion, directImports)
	qt422016.ReleaseWriter(qw422016)
}

func (struct_ *TypeRWStruct) functionCode(bytesVersion bool, directImports *DirectImports) string {
	qb422016 := qt422016.AcquireByteBuffer()
	struct_.writefunctionCode(qb422016, bytesVersion, directImports)
	qs422016 := string(qb422016.B)
	qt422016.ReleaseByteBuffer(qb422016)
	return qs422016
}

func (struct_ *TypeRWStruct) streamresetFields(qw422016 *qt422016.Writer, bytesVersion bool, directImports *DirectImports) {
	if struct_.isTypeDef() {
		field := struct_.Fields[0]

		qw422016.N().S(`ptr := (*`)
		qw422016.N().S(field.t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false))
		qw422016.N().S(`)(item)
`)
		qw422016.N().S(field.t.TypeResettingCode(bytesVersion, directImports, struct_.wr.ins, "ptr", true))
		qw422016.N().S(`
`)
		return
	}
	for _, field := range struct_.Fields {
		if field.t.IsTrueType() {
			continue
		}
		resetCode := field.t.TypeResettingCode(bytesVersion, directImports, struct_.wr.ins, fmt.Sprintf("item.%s", field.goName), field.recursive)

		if field.recursive {
			qw422016.N().S(`if item.`)
			qw422016.N().S(field.goName)
			qw422016.N().S(` != nil { `)
			qw422016.N().S(resetCode)
			qw422016.N().S(` }
`)
		} else {
			qw422016.N().S(resetCode)
			qw422016.N().S(`
`)
		}
	}
}

func (struct_ *TypeRWStruct) writeresetFields(qq422016 qtio422016.Writer, bytesVersion bool, directImports *DirectImports) {
	qw422016 := qt422016.AcquireWriter(qq422016)
	struct_.streamresetFields(qw422016, bytesVersion, directImports)
	qt422016.ReleaseWriter(qw422016)
}

func (struct_ *TypeRWStruct) resetFields(bytesVersion bool, directImports *DirectImports) string {
	qb422016 := qt422016.AcquireByteBuffer()
	struct_.writeresetFields(qb422016, bytesVersion, directImports)
	qs422016 := string(qb422016.B)
	qt422016.ReleaseByteBuffer(qb422016)
	return qs422016
}

func (struct_ *TypeRWStruct) streamrandomFields(qw422016 *qt422016.Writer, bytesVersion bool, directImports *DirectImports) {
	if struct_.isTypeDef() {
		field := struct_.Fields[0]

		qw422016.N().S(`ptr := (*`)
		qw422016.N().S(field.t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false))
		qw422016.N().S(`)(item)
`)
		qw422016.N().S(field.t.TypeRandomCode(bytesVersion, directImports, struct_.wr.ins, "ptr", formatNatArgs(struct_.Fields, field.natArgs), true))
		qw422016.N().S(`
`)
		return
	}
	for fieldId, field := range struct_.Fields {
		if field.t.IsTrueType() {
			continue
		}
		if field.fieldMask != nil {
			qw422016.N().S(`if `)
			qw422016.N().S(formatNatArg(struct_.Fields, *field.fieldMask))
			qw422016.N().S(` & (1<<`)
			qw422016.E().V(field.BitNumber)
			qw422016.N().S(`) != 0 {
`)
		}
		if field.recursive {
			qw422016.N().S(`rg.IncreaseDepth()
if item.`)
			qw422016.N().S(field.goName)
			qw422016.N().S(` == nil {
    var value `)
			qw422016.N().S(field.t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false))
			qw422016.N().S(`
    item.`)
			qw422016.N().S(field.goName)
			qw422016.N().S(` = &value
}
`)
		}
		if fieldProps, indexes := struct_.GetFieldNatProperties(fieldId); (fieldProps & (FieldIsNat | FieldUsedAsFieldMask | FieldUsedAsSize)) != 0 {
			if (fieldProps & FieldUsedAsFieldMask) != 0 {
				qw422016.N().S(`var mask`)
				qw422016.N().S(field.goName)
				qw422016.N().S(` uint32
`)
				qw422016.N().S(field.t.TypeRandomCode(bytesVersion, directImports, struct_.wr.ins, "mask"+field.goName, formatNatArgs(struct_.Fields, field.natArgs), field.recursive))
				qw422016.N().S(`
`)
				if (fieldProps & FieldUsedAsSize) != 0 {
					qw422016.N().S(`mask`)
					qw422016.N().S(field.goName)
					qw422016.N().S(` = rg.LimitValue(mask`)
					qw422016.N().S(field.goName)
					qw422016.N().S(`)
`)
				}
				qw422016.N().S(`item.`)
				qw422016.N().S(field.goName)
				qw422016.N().S(` = 0
`)
				for index, indexPosition := range indexes {
					qw422016.N().S(`if mask`)
					qw422016.N().S(field.goName)
					qw422016.N().S(` & (1<<`)
					qw422016.N().V(index)
					qw422016.N().S(`) != 0 {
    item.`)
					qw422016.N().S(field.goName)
					qw422016.N().S(` |= (1<<`)
					qw422016.N().V(indexPosition)
					qw422016.N().S(`)
}
`)
				}
			} else if (fieldProps & FieldUsedAsSize) != 0 {
				qw422016.N().S(field.t.TypeRandomCode(bytesVersion, directImports, struct_.wr.ins, "item."+field.goName, formatNatArgs(struct_.Fields, field.natArgs), field.recursive))
				qw422016.N().S(`
item.`)
				qw422016.N().S(field.goName)
				qw422016.N().S(` = rg.LimitValue(item.`)
				qw422016.N().S(field.goName)
				qw422016.N().S(`)
`)
			} else if fieldProps == FieldIsNat {
				qw422016.N().S(field.t.TypeRandomCode(bytesVersion, directImports, struct_.wr.ins, "item."+field.goName, formatNatArgs(struct_.Fields, field.natArgs), field.recursive))
				qw422016.N().S(`
`)
			}
		} else {
			qw422016.N().S(field.t.TypeRandomCode(bytesVersion, directImports, struct_.wr.ins, "item."+field.goName, formatNatArgs(struct_.Fields, field.natArgs), field.recursive))
			qw422016.N().S(`
`)
		}
		if field.recursive {
			qw422016.N().S(`rg.DecreaseDepth()
`)
		}
		if field.fieldMask != nil {
			qw422016.N().S(`} else {
`)
			resetCode := field.t.TypeResettingCode(bytesVersion, directImports, struct_.wr.ins, fmt.Sprintf("item.%s", field.goName), field.recursive)

			if field.recursive {
				qw422016.N().S(`    if item.`)
				qw422016.N().S(field.goName)
				qw422016.N().S(` != nil {
        `)
				qw422016.N().S(resetCode)
				qw422016.N().S(`
    }
`)
			} else {
				qw422016.N().S(`    `)
				qw422016.N().S(resetCode)
				qw422016.N().S(`
`)
			}
			qw422016.N().S(`}
`)
		}
	}
}

func (struct_ *TypeRWStruct) writerandomFields(qq422016 qtio422016.Writer, bytesVersion bool, directImports *DirectImports) {
	qw422016 := qt422016.AcquireWriter(qq422016)
	struct_.streamrandomFields(qw422016, bytesVersion, directImports)
	qt422016.ReleaseWriter(qw422016)
}

func (struct_ *TypeRWStruct) randomFields(bytesVersion bool, directImports *DirectImports) string {
	qb422016 := qt422016.AcquireByteBuffer()
	struct_.writerandomFields(qb422016, bytesVersion, directImports)
	qs422016 := string(qb422016.B)
	qt422016.ReleaseByteBuffer(qb422016)
	return qs422016
}

func (struct_ *TypeRWStruct) streamwriteFields(qw422016 *qt422016.Writer, bytesVersion bool, directImports *DirectImports) {
	if struct_.isTypeDef() {
		field := struct_.Fields[0]

		qw422016.N().S(`ptr := (*`)
		qw422016.N().S(field.t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false))
		qw422016.N().S(`)(item)
`)
		qw422016.N().S(field.t.TypeWritingCode(bytesVersion, directImports, struct_.wr.ins, "ptr", field.Bare(), formatNatArgs(struct_.Fields, field.natArgs), true, true, struct_.wr.hasErrorInWriteMethods))
		qw422016.N().S(`
`)
		return
	}
	for _, field := range struct_.Fields {
		writingCode := ""
		if field.t.IsTrueType() {
			if field.Bare() {
				continue
			}
			writingCode = fmt.Sprintf("w = basictl.NatWrite(w, 0x%08x)", field.t.tlTag)
		} else {
			writingCode = field.t.TypeWritingCode(bytesVersion, directImports, struct_.wr.ins, fmt.Sprintf("item.%s", field.goName), field.Bare(), formatNatArgs(struct_.Fields, field.natArgs), field.recursive, false, field.t.hasErrorInWriteMethods)
		}

		if field.fieldMask != nil {
			qw422016.N().S(`        if `)
			qw422016.N().S(formatNatArg(struct_.Fields, *field.fieldMask))
			qw422016.N().S(` & (1<<`)
			qw422016.E().V(field.BitNumber)
			qw422016.N().S(`) != 0 {
`)
		}
		if field.recursive {
			qw422016.N().S(`        if `)
			qw422016.N().S(fmt.Sprintf("item.%s", field.goName))
			qw422016.N().S(` == nil {
            var tmpValue `)
			qw422016.N().S(field.t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false))
			qw422016.N().S(`
            `)
			qw422016.N().S(field.t.TypeWritingCode(bytesVersion, directImports, struct_.wr.ins, "(&tmpValue)", field.Bare(), formatNatArgs(struct_.Fields, field.natArgs), field.recursive, false, field.t.hasErrorInWriteMethods))
			qw422016.N().S(`
        } else {
            `)
			qw422016.N().S(writingCode)
			qw422016.N().S(`
        }
`)
		} else {
			qw422016.N().S(`        `)
			qw422016.N().S(writingCode)
			qw422016.N().S(`
`)
		}
		if field.fieldMask != nil {
			qw422016.N().S(`        }
`)
		}
	}
	if struct_.wr.hasErrorInWriteMethods {
		qw422016.N().S(`return w, nil
`)
	} else {
		qw422016.N().S(`return w
`)
	}
}

func (struct_ *TypeRWStruct) writewriteFields(qq422016 qtio422016.Writer, bytesVersion bool, directImports *DirectImports) {
	qw422016 := qt422016.AcquireWriter(qq422016)
	struct_.streamwriteFields(qw422016, bytesVersion, directImports)
	qt422016.ReleaseWriter(qw422016)
}

func (struct_ *TypeRWStruct) writeFields(bytesVersion bool, directImports *DirectImports) string {
	qb422016 := qt422016.AcquireByteBuffer()
	struct_.writewriteFields(qb422016, bytesVersion, directImports)
	qs422016 := string(qb422016.B)
	qt422016.ReleaseByteBuffer(qb422016)
	return qs422016
}

func (struct_ *TypeRWStruct) streamreadFields(qw422016 *qt422016.Writer, bytesVersion bool, directImports *DirectImports) {
	if struct_.isTypeDef() {
		field := struct_.Fields[0]

		qw422016.N().S(`ptr := (*`)
		qw422016.N().S(field.t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false))
		qw422016.N().S(`)(item)
`)
		qw422016.N().S(field.t.TypeReadingCode(bytesVersion, directImports, struct_.wr.ins, "ptr", field.Bare(), formatNatArgs(struct_.Fields, field.natArgs), true, true))
		qw422016.N().S(`
`)
		return
	}
	lastWritten := false

	for i, field := range struct_.Fields {
		if field.t.IsTrueType() && field.Bare() {
			continue
		}
		if field.fieldMask != nil {
			qw422016.N().S(`if `)
			qw422016.N().S(formatNatArg(struct_.Fields, *field.fieldMask))
			qw422016.N().S(` & (1<<`)
			qw422016.E().V(field.BitNumber)
			qw422016.N().S(`) != 0 {
`)
		}
		if field.recursive {
			qw422016.N().S(`if item.`)
			qw422016.N().S(field.goName)
			qw422016.N().S(` == nil {
    var value `)
			qw422016.N().S(field.t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false))
			qw422016.N().S(`
    item.`)
			qw422016.N().S(field.goName)
			qw422016.N().S(` = &value
}
`)
		}
		last := i == len(struct_.Fields)-1 && field.fieldMask == nil
		lastWritten = lastWritten || last

		if field.t.IsTrueType() {
			qw422016.N().S(wrapLastW(last, fmt.Sprintf("basictl.NatReadExactTag(w, 0x%08x)", field.t.tlTag), true))
			qw422016.N().S(`
`)
		} else {
			qw422016.N().S(field.t.TypeReadingCode(bytesVersion, directImports, struct_.wr.ins, "item."+field.goName, field.Bare(), formatNatArgs(struct_.Fields, field.natArgs), field.recursive, last))
			qw422016.N().S(`
`)
		}
		if field.fieldMask != nil {
			if field.t.IsTrueType() {
				qw422016.N().S(`}
`)
			} else {
				qw422016.N().S(`} else {
`)
				if field.recursive {
					qw422016.N().S(`        if item.`)
					qw422016.N().S(field.goName)
					qw422016.N().S(` != nil {
`)
				}
				qw422016.N().S(`            `)
				qw422016.N().S(field.t.TypeResettingCode(bytesVersion, directImports, struct_.wr.ins, fmt.Sprintf("item.%s", field.goName), field.recursive))
				qw422016.N().S(`
`)
				if field.recursive {
					qw422016.N().S(`        }
`)
				}
				qw422016.N().S(`}
`)
			}
		}
	}
	if !lastWritten {
		qw422016.N().S(`return w, nil`)
	}
	// keeps all function body on the same line

}

func (struct_ *TypeRWStruct) writereadFields(qq422016 qtio422016.Writer, bytesVersion bool, directImports *DirectImports) {
	qw422016 := qt422016.AcquireWriter(qq422016)
	struct_.streamreadFields(qw422016, bytesVersion, directImports)
	qt422016.ReleaseWriter(qw422016)
}

func (struct_ *TypeRWStruct) readFields(bytesVersion bool, directImports *DirectImports) string {
	qb422016 := qt422016.AcquireByteBuffer()
	struct_.writereadFields(qb422016, bytesVersion, directImports)
	qs422016 := string(qb422016.B)
	qt422016.ReleaseByteBuffer(qb422016)
	return qs422016
}

func (struct_ *TypeRWStruct) streamgenerateTL2Code(qw422016 *qt422016.Writer, bytesVersion bool, directImports *DirectImports) {
	goName := addBytes(struct_.wr.goGlobalName, bytesVersion)
	tlName := struct_.wr.tlName.String()
	natArgsDecl := formatNatArgsDecl(struct_.wr.NatParams)

	if struct_.isTypeDef() && struct_.wr.unionParent == nil {
		field := struct_.Fields[0]
		fieldTypeString := field.t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false)

		if struct_.wr.wantsTL2 {
			qw422016.N().S(`
func (item *`)
			qw422016.N().S(goName)
			qw422016.N().S(`) CalculateLayout(sizes []int`)
			qw422016.N().S(natArgsDecl)
			qw422016.N().S(`) []int {
`)
			if field.t.trw.doesCalculateLayoutUseObject(true) {
				qw422016.N().S(`    ptr := (*`)
				qw422016.N().S(fieldTypeString)
				qw422016.N().S(`)(item)
`)
			}
			qw422016.N().S(`    `)
			qw422016.N().S(field.t.CalculateLayout(directImports, bytesVersion, "sizes", "ptr", false, struct_.wr.ins, true, formatNatArgs(struct_.Fields, field.natArgs)))
			qw422016.N().S(`
    return sizes
}

func (item *`)
			qw422016.N().S(goName)
			qw422016.N().S(`) InternalWriteTL2(w []byte, sizes []int`)
			qw422016.N().S(natArgsDecl)
			qw422016.N().S(`) ([]byte, []int) {
`)
			if field.t.trw.doesWriteTL2UseObject(false) {
				qw422016.N().S(`    ptr := (*`)
				qw422016.N().S(fieldTypeString)
				qw422016.N().S(`)(item)
`)
			}
			qw422016.N().S(`    `)
			qw422016.N().S(field.t.WriteTL2Call(directImports, bytesVersion, "sizes", "w", "ptr", false, struct_.wr.ins, true, formatNatArgs(struct_.Fields, field.natArgs)))
			qw422016.N().S(`
    return w, sizes
}
`)
		}
		if len(natArgsDecl) == 0 {
			qw422016.N().S(`
func (item *`)
			qw422016.N().S(goName)
			qw422016.N().S(`) WriteTL2(w []byte, ctx *basictl.TL2WriteContext) []byte {
`)
			if !struct_.wr.wantsTL2 {
				qw422016.N().S(`    return w
`)
			} else {
				qw422016.N().S(`    var sizes []int
    if ctx != nil {
        sizes = ctx.SizeBuffer
    }
    sizes = item.CalculateLayout(sizes[:0])
    w, _ = item.InternalWriteTL2(w, sizes)
    if ctx != nil {
        ctx.SizeBuffer = sizes[:0]
    }
    return w
`)
			}
			qw422016.N().S(`}
`)
		}
		qw422016.N().S(`
func (item *`)
		qw422016.N().S(goName)
		qw422016.N().S(`) InternalReadTL2(r []byte`)
		qw422016.N().S(natArgsDecl)
		qw422016.N().S(`) (_ []byte, err error) {
`)
		if !struct_.wr.wantsTL2 {
			qw422016.N().S(`    return r, `)
			qw422016.N().S(struct_.wr.gen.InternalPrefix())
			qw422016.N().S(`ErrorTL2SerializersNotGenerated(`)
			qw422016.N().Q(tlName)
			qw422016.N().S(`)
`)
		} else {
			if field.t.trw.doesReadTL2UseObject(false) {
				qw422016.N().S(`    ptr := (*`)
				qw422016.N().S(fieldTypeString)
				qw422016.N().S(`)(item)
`)
			}
			qw422016.N().S(`    `)
			qw422016.N().S(field.t.ReadTL2Call(directImports, bytesVersion, "r", "ptr", false, struct_.wr.ins, true, formatNatArgs(struct_.Fields, field.natArgs)))
			qw422016.N().S(`
    return r, nil
`)
		}
		qw422016.N().S(`}

`)
		if len(natArgsDecl) == 0 {
			qw422016.N().S(`func (item *`)
			qw422016.N().S(goName)
			qw422016.N().S(`) ReadTL2(r []byte, ctx *basictl.TL2ReadContext) (_ []byte, err error) {
    return item.InternalReadTL2(r)
}
`)
		}
	} else {
		qw422016.N().S(`
`)
		if struct_.wr.wantsTL2 {
			qw422016.N().S(`func (item *`)
			qw422016.N().S(goName)
			qw422016.N().S(`) CalculateLayout(sizes []int`)
			qw422016.N().S(natArgsDecl)
			qw422016.N().S(`) []int {
`)
			if struct_.isTypeDef() {
				qw422016.N().S(`    ptr := (*`)
				qw422016.N().S(struct_.Fields[0].t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false))
				qw422016.N().S(`)(item)
`)
			}
			qw422016.N().S(`    sizePosition := len(sizes)
    sizes = append(sizes, 0)

    currentSize := 0
    lastUsedByte := 0
`)
			if struct_.wr.unionParent != nil && struct_.wr.unionIndex != 0 {
				qw422016.N().S(`
    // add constructor No for union type in case of non first option
    lastUsedByte = 1
    currentSize += basictl.TL2CalculateSize(`)
				qw422016.N().D(struct_.wr.unionIndex)
				qw422016.N().S(`)
`)
			}
			currentPositionFirstUsage := -1
			for i, field := range struct_.Fields {
				_, trivialSize := field.t.trw.tl2TrivialSize(fmt.Sprintf("item.%s", field.goName), field.fieldMask == nil, field.recursive)
				if len(trivialSize) == 0 {
					currentPositionFirstUsage = i
					break
				}
			}

			for fieldIndex, field := range struct_.Fields {
				if field.t.IsTrueType() {
					continue
				}
				fieldName := fmt.Sprintf("item.%[1]s", field.goName)
				fieldRecursive := field.recursive
				if struct_.isTypeDef() {
					fieldName = "ptr"
					fieldRecursive = true
				}

				isSizeConstant, trivialSize := field.t.trw.tl2TrivialSize(fieldName, field.fieldMask == nil, fieldRecursive)

				qw422016.N().S(`
    // calculate layout for `)
				qw422016.N().S(fieldName)
				qw422016.N().S(`
`)
				if len(trivialSize) == 0 {
					if fieldIndex == currentPositionFirstUsage {
						qw422016.N().S(`    currentPosition := len(sizes)
`)
					} else {
						qw422016.N().S(`    currentPosition = len(sizes)
`)
					}
				}
				if field.fieldMask != nil {
					qw422016.N().S(`    if `)
					qw422016.N().S(formatNatArg(struct_.Fields, *field.fieldMask))
					qw422016.N().S(` & (1 << `)
					qw422016.E().V(field.BitNumber)
					qw422016.N().S(`) != 0 {
`)
				}
				nonEmptyCondition := field.t.TypeJSONEmptyCondition(false, fieldName, fieldRecursive)

				if nonEmptyCondition != "" {
					qw422016.N().S(`    if `)
					qw422016.N().S(nonEmptyCondition)
					qw422016.N().S(` {
`)
				}
				qw422016.N().S(`    `)
				qw422016.N().S(field.t.CalculateLayout(directImports, bytesVersion, "sizes", fieldName, field.fieldMask == nil, struct_.wr.ins, fieldRecursive, formatNatArgs(struct_.Fields, field.natArgs)))
				qw422016.N().S(`
`)
				if field.t.trw.doesZeroSizeMeanEmpty(field.fieldMask == nil) {
					if !isSizeConstant {
						sizeValue := "sizes[currentPosition]"
						if len(trivialSize) != 0 {
							sizeValue = trivialSize
						}

						qw422016.N().S(`    if `)
						qw422016.N().S(sizeValue)
						qw422016.N().S(` != 0 {
        lastUsedByte = `)
						qw422016.N().D((fieldIndex+1)/8 + 1)
						qw422016.N().S(`
        currentSize += `)
						qw422016.N().S(sizeValue)
						qw422016.N().S(`
`)
						if field.t.trw.isSizeWrittenInData() {
							qw422016.N().S(`        currentSize += basictl.TL2CalculateSize(`)
							qw422016.N().S(sizeValue)
							qw422016.N().S(`)
`)
						}
						if len(trivialSize) == 0 {
							qw422016.N().S(`    } else {
        sizes = sizes[:currentPosition + 1]
    }
`)
						} else {
							qw422016.N().S(`    }
`)
						}
					} else {
						qw422016.N().S(`        lastUsedByte = `)
						qw422016.N().D((fieldIndex+1)/8 + 1)
						qw422016.N().S(`
        currentSize += `)
						qw422016.N().S(trivialSize)
						qw422016.N().S(`
`)
						if field.t.trw.isSizeWrittenInData() {
							qw422016.N().S(`        currentSize += basictl.TL2CalculateSize(`)
							qw422016.N().S(trivialSize)
							qw422016.N().S(`)
`)
						}
					}
				} else {
					sizeValue := "sizes[currentPosition]"
					if len(trivialSize) != 0 {
						sizeValue = trivialSize
					}

					qw422016.N().S(`        lastUsedByte = `)
					qw422016.N().D((fieldIndex+1)/8 + 1)
					qw422016.N().S(`
        currentSize += `)
					qw422016.N().S(sizeValue)
					qw422016.N().S(`
`)
					if field.t.trw.isSizeWrittenInData() {
						qw422016.N().S(`        currentSize += basictl.TL2CalculateSize(`)
						qw422016.N().S(sizeValue)
						qw422016.N().S(`)
`)
					}
				}
				if nonEmptyCondition != "" {
					qw422016.N().S(`    }
`)
				}
				if field.fieldMask != nil {
					qw422016.N().S(`    }
`)
				}
			}
			qw422016.N().S(`
    // append byte for each section until last mentioned field
    if lastUsedByte != 0 {
        currentSize += lastUsedByte
    } else {
        // remove unused values
        sizes = sizes[:sizePosition + 1]
    }
    sizes[sizePosition] = currentSize
    return sizes
}

func (item *`)
			qw422016.N().S(goName)
			qw422016.N().S(`) InternalWriteTL2(w []byte, sizes []int`)
			qw422016.N().S(natArgsDecl)
			qw422016.N().S(`) ([]byte, []int) {
`)
			if struct_.isTypeDef() {
				qw422016.N().S(`    ptr := (*`)
				qw422016.N().S(struct_.Fields[0].t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false))
				qw422016.N().S(`)(item)
`)
			}
			qw422016.N().S(`    currentSize := sizes[0]
    sizes = sizes[1:]

    serializedSize := 0

    w = basictl.TL2WriteSize(w, currentSize)
    if currentSize == 0 {
        return w, sizes
    }

`)
			if len(struct_.Fields) > 0 || (struct_.wr.unionParent != nil && struct_.wr.unionIndex != 0) {
				qw422016.N().S(`    var currentBlock byte
    currentBlockPosition := len(w)
`)
			}
			qw422016.N().S(`    w = append(w, 0)
    serializedSize += 1
`)
			if struct_.wr.unionParent != nil && struct_.wr.unionIndex != 0 {
				qw422016.N().S(`
    // add constructor No for union type in case of non first option
    currentBlock |= (1 << 0)

    w = basictl.TL2WriteSize(w, `)
				qw422016.N().D(struct_.wr.unionIndex)
				qw422016.N().S(`)
    serializedSize += basictl.TL2CalculateSize(`)
				qw422016.N().D(struct_.wr.unionIndex)
				qw422016.N().S(`)
`)
			}
			for fieldIndex, field := range struct_.Fields {
				if (fieldIndex+1)%8 == 0 {
					qw422016.N().S(`
        // add byte for fields with index `)
					qw422016.N().V((fieldIndex + 1))
					qw422016.N().S(`..`)
					qw422016.N().V((fieldIndex + 8))
					qw422016.N().S(`
        w[currentBlockPosition] = currentBlock
        currentBlock = 0
        if serializedSize != currentSize {
            currentBlockPosition = len(w)
            w = append(w, 0)
            serializedSize += 1
        } else {
            return w, sizes
        }
`)
				}
				if field.t.IsTrueType() {
					continue
				}
				fieldName := fmt.Sprintf("item.%s", field.goName)
				fieldRecursive := field.recursive
				if struct_.isTypeDef() {
					fieldName = "ptr"
					fieldRecursive = true
				}
				_, trivialSize := field.t.trw.tl2TrivialSize(fieldName, field.fieldMask == nil, fieldRecursive)

				qw422016.N().S(`    // write `)
				qw422016.N().S(fieldName)
				qw422016.N().S(`
`)
				if field.fieldMask != nil {
					qw422016.N().S(`    if `)
					qw422016.N().S(formatNatArg(struct_.Fields, *field.fieldMask))
					qw422016.N().S(` & (1 << `)
					qw422016.E().V(field.BitNumber)
					qw422016.N().S(`) != 0 {
`)
				}
				nonEmptyCondition := field.t.TypeJSONEmptyCondition(false, fieldName, fieldRecursive)

				if nonEmptyCondition != "" {
					qw422016.N().S(`    if `)
					qw422016.N().S(nonEmptyCondition)
					qw422016.N().S(` {
`)
				}
				sizeValue := "sizes[0]"
				if len(trivialSize) != 0 {
					sizeValue = trivialSize
				}

				qw422016.N().S(`    serializedSize += `)
				qw422016.N().S(sizeValue)
				qw422016.N().S(`
`)
				if field.t.trw.doesZeroSizeMeanEmpty(field.fieldMask == nil) {
					qw422016.N().S(`    if `)
					qw422016.N().S(sizeValue)
					qw422016.N().S(` != 0 {
`)
				}
				if field.t.trw.isSizeWrittenInData() {
					qw422016.N().S(`    serializedSize += basictl.TL2CalculateSize(`)
					qw422016.N().S(sizeValue)
					qw422016.N().S(`)
`)
				}
				qw422016.N().S(`    currentBlock |= (1 << `)
				qw422016.E().V((fieldIndex + 1) % 8)
				qw422016.N().S(`)
    `)
				qw422016.N().S(field.t.WriteTL2Call(directImports, bytesVersion, "sizes", "w", fieldName, field.fieldMask == nil, struct_.wr.ins, fieldRecursive, formatNatArgs(struct_.Fields, field.natArgs)))
				qw422016.N().S(`
`)
				if field.t.trw.doesZeroSizeMeanEmpty(field.fieldMask == nil) {
					if len(trivialSize) == 0 {
						qw422016.N().S(`    } else {
        sizes = sizes[1:]
    }
`)
					} else {
						qw422016.N().S(`    }
`)
					}
				}
				if nonEmptyCondition != "" {
					qw422016.N().S(`    }
`)
				}
				if field.fieldMask != nil {
					qw422016.N().S(`    }
`)
				}
			}
			if len(struct_.Fields) > 0 || (struct_.wr.unionParent != nil && struct_.wr.unionIndex != 0) {
				qw422016.N().S(`    w[currentBlockPosition] = currentBlock
`)
			}
			qw422016.N().S(`    return w, sizes
}
`)
		}
		qw422016.N().S(`
`)
		if len(natArgsDecl) == 0 {
			qw422016.N().S(`func (item *`)
			qw422016.N().S(goName)
			qw422016.N().S(`) WriteTL2(w []byte, ctx *basictl.TL2WriteContext) []byte {
`)
			if !struct_.wr.wantsTL2 {
				qw422016.N().S(`    return w
`)
			} else {
				qw422016.N().S(`    var sizes []int
    if ctx != nil {
        sizes = ctx.SizeBuffer
    }
    sizes = item.CalculateLayout(sizes[:0])
    w, _ = item.InternalWriteTL2(w, sizes)
    if ctx != nil {
        ctx.SizeBuffer = sizes[:0]
    }
    return w
`)
			}
			qw422016.N().S(`}

`)
		}
		if struct_.wr.wantsTL2 {
			if struct_.wr.unionParent == nil {
				qw422016.N().S(`func (item *`)
				qw422016.N().S(goName)
				qw422016.N().S(`) InternalReadTL2(r []byte`)
				qw422016.N().S(natArgsDecl)
				qw422016.N().S(`) (_ []byte, err error) {
    currentSize := 0
    if r, currentSize, err = basictl.TL2ParseSize(r); err != nil { return r, err }
    if len(r) < currentSize {
        return r, basictl.TL2Error("not enough data: expected %d, got %d", currentSize, len(r))
    }

    currentR := r[:currentSize]
    r = r[currentSize:]

    if currentSize == 0 {
        item.Reset()
        return r, nil
    }
    var block byte
    if currentR, err = basictl.ByteReadTL2(currentR, &block); err != nil { return currentR, err }
    // read No of constructor
    if block & 1 != 0 {
        var index int
        if currentR, err = basictl.TL2ReadSize(currentR, &index); err != nil { return currentR, err }
        if index != 0 {
            // unknown cases for current type
            item.Reset()
            return r, nil
        }
    }
`)
			} else {
				qw422016.N().S(`func (item *`)
				qw422016.N().S(goName)
				qw422016.N().S(`) InternalReadTL2(r []byte, block byte`)
				qw422016.N().S(natArgsDecl)
				qw422016.N().S(`) (_ []byte, err error) {
`)
				initCurrentR := false
				for _, field := range struct_.Fields {
					if field.t.trw.doesReadTL2UseBytes(field.fieldMask == nil) {
						initCurrentR = true
						break
					}
				}

				if initCurrentR {
					qw422016.N().S(`    currentR := r
`)
				}
			}
			if struct_.isTypeDef() {
				qw422016.N().S(`    ptr := (*`)
				qw422016.N().S(struct_.Fields[0].t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false))
				qw422016.N().S(`)(item)
`)
			}
			for fieldIndex, field := range struct_.Fields {
				fieldName := fmt.Sprintf("item.%s", field.goName)
				fieldRecursive := field.recursive
				if struct_.isTypeDef() {
					fieldName = "ptr"
					fieldRecursive = true
				}

				if (fieldIndex+1)%8 == 0 {
					qw422016.N().S(`
    // read next block for fields `)
					qw422016.N().V((fieldIndex + 1))
					qw422016.N().S(`..`)
					qw422016.N().V((fieldIndex + 8))
					qw422016.N().S(`
    if len(currentR) > 0 {
        if currentR, err = basictl.ByteReadTL2(currentR, &block); err != nil { return currentR, err }
    } else {
        block = 0
    }
`)
				}
				if field.t.IsTrueType() {
					continue
				}
				qw422016.N().S(`
    // read `)
				qw422016.N().S(fieldName)
				qw422016.N().S(`
    if block & (1 << `)
				qw422016.N().D((fieldIndex + 1) % 8)
				qw422016.N().S(`) != 0 {
`)
				if fieldRecursive {
					qw422016.N().S(`        if `)
					qw422016.N().S(fieldName)
					qw422016.N().S(` == nil {
            var newValue `)
					qw422016.N().S(field.t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false))
					qw422016.N().S(`
            `)
					qw422016.N().S(fieldName)
					qw422016.N().S(` = &newValue
        }
`)
				}
				if field.fieldMask != nil {
					qw422016.N().S(`        if `)
					qw422016.N().S(formatNatArg(struct_.Fields, *field.fieldMask))
					qw422016.N().S(` & (1 << `)
					qw422016.E().V(field.BitNumber)
					qw422016.N().S(`) != 0 {
`)
				}
				qw422016.N().S(`        `)
				qw422016.N().S(field.t.ReadTL2Call(directImports, bytesVersion, "currentR", fieldName, field.fieldMask == nil, struct_.wr.ins, fieldRecursive, formatNatArgs(struct_.Fields, field.natArgs)))
				qw422016.N().S(`
`)
				if field.fieldMask != nil {
					qw422016.N().S(`        } else {
            return currentR, basictl.TL2Error("field mask contradiction: field item." + "`)
					qw422016.N().S(field.goName)
					qw422016.N().S(`" + "is presented but depending bit is absent")
        }
`)
				}
				qw422016.N().S(`    } else {
`)
				if fieldRecursive {
					qw422016.N().S(`        if `)
					qw422016.N().S(fieldName)
					qw422016.N().S(` == nil {
            var newValue `)
					qw422016.N().S(field.t.TypeString2(bytesVersion, directImports, struct_.wr.ins, false, false))
					qw422016.N().S(`
            `)
					qw422016.N().S(fieldName)
					qw422016.N().S(` = &newValue
        }
`)
				}
				qw422016.N().S(`        `)
				qw422016.N().S(field.t.TypeResettingCode(bytesVersion, directImports, struct_.wr.ins, fieldName, fieldRecursive))
				qw422016.N().S(`
    }
`)
			}
			qw422016.N().S(`
    return r, nil
}
`)
		}
		qw422016.N().S(`
`)
		if len(natArgsDecl) == 0 {
			if !struct_.wr.wantsTL2 {
				qw422016.N().S(`func (item *`)
				qw422016.N().S(goName)
				qw422016.N().S(`) ReadTL2(r []byte, ctx *basictl.TL2ReadContext) (_ []byte, err error) {
        return r, `)
				qw422016.N().S(struct_.wr.gen.InternalPrefix())
				qw422016.N().S(`ErrorTL2SerializersNotGenerated(`)
				qw422016.N().Q(tlName)
				qw422016.N().S(`)
}
`)
			} else {
				qw422016.N().S(`func (item *`)
				qw422016.N().S(goName)
				qw422016.N().S(`) ReadTL2(r []byte, ctx *basictl.TL2ReadContext) (_ []byte, err error) {
`)
				if struct_.wr.unionParent != nil {
					qw422016.N().S(`    currentSize := 0
    if r, currentSize, err = basictl.TL2ParseSize(r); err != nil { return r, err }

    currentR := r[:currentSize]
    r = r[currentSize:]

    var block byte
    var index int
    if currentSize == 0 {
        index = 0
    } else {
        if currentR, err = basictl.ByteReadTL2(currentR, &block); err != nil { return r, err }
        if (block & 1) != 0 {
            if currentR, index, err = basictl.TL2ParseSize(currentR); err != nil { return r, err }
        } else {
            index = 0
        }
    }
    if index != `)
					qw422016.N().D(struct_.wr.unionIndex)
					qw422016.N().S(` {
        return r, basictl.TL2Error("unexpected constructor number %d, instead of %d", index, `)
					qw422016.N().D(struct_.wr.unionIndex)
					qw422016.N().S(`)
    }
    _, err = item.InternalReadTL2(currentR, block)
    return r, err
`)
				} else {
					qw422016.N().S(`    return item.InternalReadTL2(r)
`)
				}
				qw422016.N().S(`}
`)
			}
		}
	}
}

func (struct_ *TypeRWStruct) writegenerateTL2Code(qq422016 qtio422016.Writer, bytesVersion bool, directImports *DirectImports) {
	qw422016 := qt422016.AcquireWriter(qq422016)
	struct_.streamgenerateTL2Code(qw422016, bytesVersion, directImports)
	qt422016.ReleaseWriter(qw422016)
}

func (struct_ *TypeRWStruct) generateTL2Code(bytesVersion bool, directImports *DirectImports) string {
	qb422016 := qt422016.AcquireByteBuffer()
	struct_.writegenerateTL2Code(qb422016, bytesVersion, directImports)
	qs422016 := string(qb422016.B)
	qt422016.ReleaseByteBuffer(qb422016)
	return qs422016
}
