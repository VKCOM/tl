// Code generated by vktl/cmd/tlgen2; DO NOT EDIT.
package internal

import (
	"github.com/vkcom/tl/internal/tlcodegen/gentlo/basictl"
)

var _ = basictl.NatWrite

func BuiltinTupleTlsTypeBoxedRead(w []byte, vec *[]TlsType, nat_n uint32) (_ []byte, err error) {
	if err = basictl.CheckLengthSanity(w, nat_n, 4); err != nil {
		return w, err
	}
	if uint32(cap(*vec)) < nat_n {
		*vec = make([]TlsType, nat_n)
	} else {
		*vec = (*vec)[:nat_n]
	}
	for i := range *vec {
		if w, err = (*vec)[i].ReadBoxed(w); err != nil {
			return w, err
		}
	}
	return w, nil
}

func BuiltinTupleTlsTypeBoxedWrite(w []byte, vec []TlsType, nat_n uint32) (_ []byte, err error) {
	if uint32(len(vec)) != nat_n {
		return w, ErrorWrongSequenceLength("[]TlsType", len(vec), nat_n)
	}
	for _, elem := range vec {
		if w, err = elem.WriteBoxed(w); err != nil {
			return w, err
		}
	}
	return w, nil
}

func BuiltinTupleTlsTypeBoxedReadJSON(j interface{}, vec *[]TlsType, nat_n uint32) error {
	_, _arr, err := JsonReadArrayFixedSize("[]TlsType", j, nat_n)
	if err != nil {
		return err
	}
	if uint32(cap(*vec)) < nat_n {
		*vec = make([]TlsType, nat_n)
	} else {
		*vec = (*vec)[:nat_n]
	}
	for i := range *vec {
		if err := TlsType__ReadJSON(&(*vec)[i], _arr[i]); err != nil {
			return err
		}
	}
	return nil
}

func BuiltinTupleTlsTypeBoxedWriteJSON(w []byte, vec []TlsType, nat_n uint32) (_ []byte, err error) {
	return BuiltinTupleTlsTypeBoxedWriteJSONOpt(false, w, vec, nat_n)
}
func BuiltinTupleTlsTypeBoxedWriteJSONOpt(short bool, w []byte, vec []TlsType, nat_n uint32) (_ []byte, err error) {
	if uint32(len(vec)) != nat_n {
		return w, ErrorWrongSequenceLength("[]TlsType", len(vec), nat_n)
	}
	w = append(w, '[')
	for _, elem := range vec {
		w = basictl.JSONAddCommaIfNeeded(w)
		if w, err = elem.WriteJSONOpt(short, w); err != nil {
			return w, err
		}
	}
	return append(w, ']'), nil
}

type TlsType struct {
	Name            int32
	Id              string
	ConstructorsNum int32
	Flags           int32
	Arity           int32
	ParamsType      int64
}

func (TlsType) TLName() string { return "tls.type" }
func (TlsType) TLTag() uint32  { return 0x12eb4386 }

func (item *TlsType) Reset() {
	item.Name = 0
	item.Id = ""
	item.ConstructorsNum = 0
	item.Flags = 0
	item.Arity = 0
	item.ParamsType = 0
}

func (item *TlsType) Read(w []byte) (_ []byte, err error) {
	if w, err = basictl.IntRead(w, &item.Name); err != nil {
		return w, err
	}
	if w, err = basictl.StringRead(w, &item.Id); err != nil {
		return w, err
	}
	if w, err = basictl.IntRead(w, &item.ConstructorsNum); err != nil {
		return w, err
	}
	if w, err = basictl.IntRead(w, &item.Flags); err != nil {
		return w, err
	}
	if w, err = basictl.IntRead(w, &item.Arity); err != nil {
		return w, err
	}
	return basictl.LongRead(w, &item.ParamsType)
}

func (item *TlsType) Write(w []byte) (_ []byte, err error) {
	w = basictl.IntWrite(w, item.Name)
	if w, err = basictl.StringWrite(w, item.Id); err != nil {
		return w, err
	}
	w = basictl.IntWrite(w, item.ConstructorsNum)
	w = basictl.IntWrite(w, item.Flags)
	w = basictl.IntWrite(w, item.Arity)
	return basictl.LongWrite(w, item.ParamsType), nil
}

func (item *TlsType) ReadBoxed(w []byte) (_ []byte, err error) {
	if w, err = basictl.NatReadExactTag(w, 0x12eb4386); err != nil {
		return w, err
	}
	return item.Read(w)
}

func (item *TlsType) WriteBoxed(w []byte) ([]byte, error) {
	w = basictl.NatWrite(w, 0x12eb4386)
	return item.Write(w)
}

func (item TlsType) String() string {
	w, err := item.WriteJSON(nil)
	if err != nil {
		return err.Error()
	}
	return string(w)
}

func TlsType__ReadJSON(item *TlsType, j interface{}) error { return item.readJSON(j) }
func (item *TlsType) readJSON(j interface{}) error {
	_jm, _ok := j.(map[string]interface{})
	if j != nil && !_ok {
		return ErrorInvalidJSON("tls.type", "expected json object")
	}
	_jName := _jm["name"]
	delete(_jm, "name")
	if err := JsonReadInt32(_jName, &item.Name); err != nil {
		return err
	}
	_jId := _jm["id"]
	delete(_jm, "id")
	if err := JsonReadString(_jId, &item.Id); err != nil {
		return err
	}
	_jConstructorsNum := _jm["constructors_num"]
	delete(_jm, "constructors_num")
	if err := JsonReadInt32(_jConstructorsNum, &item.ConstructorsNum); err != nil {
		return err
	}
	_jFlags := _jm["flags"]
	delete(_jm, "flags")
	if err := JsonReadInt32(_jFlags, &item.Flags); err != nil {
		return err
	}
	_jArity := _jm["arity"]
	delete(_jm, "arity")
	if err := JsonReadInt32(_jArity, &item.Arity); err != nil {
		return err
	}
	_jParamsType := _jm["params_type"]
	delete(_jm, "params_type")
	if err := JsonReadInt64(_jParamsType, &item.ParamsType); err != nil {
		return err
	}
	for k := range _jm {
		return ErrorInvalidJSONExcessElement("tls.type", k)
	}
	return nil
}

func (item *TlsType) WriteJSON(w []byte) (_ []byte, err error) {
	return item.WriteJSONOpt(false, w)
}
func (item *TlsType) WriteJSONOpt(short bool, w []byte) (_ []byte, err error) {
	w = append(w, '{')
	if item.Name != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"name":`...)
		w = basictl.JSONWriteInt32(w, item.Name)
	}
	if len(item.Id) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"id":`...)
		w = basictl.JSONWriteString(w, item.Id)
	}
	if item.ConstructorsNum != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"constructors_num":`...)
		w = basictl.JSONWriteInt32(w, item.ConstructorsNum)
	}
	if item.Flags != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"flags":`...)
		w = basictl.JSONWriteInt32(w, item.Flags)
	}
	if item.Arity != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"arity":`...)
		w = basictl.JSONWriteInt32(w, item.Arity)
	}
	if item.ParamsType != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"params_type":`...)
		w = basictl.JSONWriteInt64(w, item.ParamsType)
	}
	return append(w, '}'), nil
}

func (item *TlsType) MarshalJSON() ([]byte, error) {
	return item.WriteJSON(nil)
}

func (item *TlsType) UnmarshalJSON(b []byte) error {
	j, err := JsonBytesToInterface(b)
	if err != nil {
		return ErrorInvalidJSON("tls.type", err.Error())
	}
	if err = item.readJSON(j); err != nil {
		return ErrorInvalidJSON("tls.type", err.Error())
	}
	return nil
}
