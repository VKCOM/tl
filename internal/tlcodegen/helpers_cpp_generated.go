// Copyright 2025 V Kontakte LLC
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Code is generated by scripts/move-basictl-cpp.sh.
// DO NOT EDIT!

package tlcodegen

func CppCopingStreamFiles() []string {
	values := []string{
		"constants.h",
		"errors.h",
		"io_connectors.h",
		"io_streams.cpp",
		"io_streams.h",
		"io_throwable_streams.cpp",
		"io_throwable_streams.h",
		"impl/string_io.h",
		"impl/string_io.cpp",
		"dependencies.h",
	}
	return values
}

func CppCopingStreamFilesText() map[string]string {
	m := make(map[string]string)
	m["constants.h"] = `#ifndef BASICTL_CPP_CONSTANTS_H
#define BASICTL_CPP_CONSTANTS_H

#include <cstring>
#include <cstdint>

namespace basictl {
    inline constexpr std::size_t TL_MAX_TINY_STRING_LEN = 253;
    inline constexpr std::size_t TL_BIG_STRING_LEN = 0xffffff;
    inline constexpr std::uint8_t TL_BIG_STRING_MARKER = 0xfe;
    inline constexpr std::size_t TL_INT32_SIZE = 4;
    inline constexpr std::size_t TL_UINT32_SIZE = 4;
    inline constexpr std::size_t TL_INT64_SIZE = 8;
    inline constexpr std::size_t TL_FLOAT32_SIZE = 4;
    inline constexpr std::size_t TL_FLOAT64_SIZE = 8;
}

#endif //BASICTL_CPP_CONSTANTS_H
`
	m["errors.h"] = `#ifndef BASICTL_CPP_ERRORS_H
#define BASICTL_CPP_ERRORS_H

#include <exception>
#include <string_view>
#include <cstring>
#include <string>

namespace basictl {
    enum class tl_error_type {
        STREAM_EOF,
        INCORRECT_SEQUENCE_LENGTH,
        INCORRECT_STRING_PADDING,
        UNEXPECTED_TAG,
        UNKNOWN_SCENARIO,
    };

    template<typename Type>
    class basic_error final : public std::exception {
    public:
        basic_error(Type type, std::string message)
                : type_(type), message_(std::move(message)) {}

        [[nodiscard]] Type type() const noexcept {
            return type_;
        }

        [[nodiscard]] const std::string& message() const & noexcept {
            return message_;
        }

        [[nodiscard]] std::string&& message() && noexcept {
            return std::move(message_);
        }

        [[nodiscard]] const char *what() const noexcept override {
            return message_.c_str();
        }

    private:
        Type type_;
        std::string message_;
    };

    using tl_stream_error = basic_error<tl_error_type>;
    using tl_connector_error = basic_error<std::uint32_t>;
    using tl_error = std::variant<tl_stream_error, tl_connector_error>;
}

#endif //BASICTL_CPP_ERRORS_H
`
	m["io_connectors.h"] = `#ifndef BASIC_CPP_IO_CONNECTORS_H
#define BASIC_CPP_IO_CONNECTORS_H

#include <variant>
#include <span>

/** TLGEN: CPP INCLUDES */
#include "errors.h"
/** TLGEN: CPP INCLUDES END */

namespace basictl {
    template<typename Type>
    class tl_connector_result {
    public:

        explicit tl_connector_result(Type buffer)
                : result_(buffer) {}

        explicit tl_connector_result(basictl::tl_connector_error error)
                : result_(std::move(error)) {}

        explicit operator bool() const noexcept {
            return std::holds_alternative<Type>(result_);
        }

        bool has_value() const noexcept {
            return std::holds_alternative<Type>(result_);
        }

        Type value() const noexcept {
            return std::get<Type>(result_);
        }

        [[nodiscard]] const tl_connector_error &error() const & noexcept {
            return std::get<tl_connector_error>(result_);
        }

        tl_connector_error error() && noexcept {
            return std::get<tl_connector_error>(std::move(result_));
        }

    private:
        std::variant<Type, basictl::tl_connector_error> result_;
    };

    class tl_input_connector {
    public:
        virtual ~tl_input_connector() = default;

        virtual tl_connector_result<std::span<const std::byte>> get_buffer() noexcept = 0;

        virtual void advance(size_t size) noexcept = 0;
    };

    class tl_output_connector {
    public:
        virtual ~tl_output_connector() = default;

        virtual tl_connector_result<std::span<std::byte>> get_buffer() noexcept = 0;

        virtual void advance(size_t size) noexcept = 0;
    };
}

#endif //BASIC_CPP_IO_CONNECTORS_H
`
	m["io_streams.cpp"] = `/** TLGEN: CPP INCLUDES */
#include "io_streams.h"
#include "io_throwable_streams.h"
/** TLGEN: CPP INCLUDES END */

namespace basictl {
    tl_istream::tl_istream(tl_input_connector &provider) : provider(&provider) {}

    tl_istream::tl_istream(tl_throwable_istream &from) : provider(nullptr) {
        from.pass_data(*this);
        this->sync_in_destructor = false;
    }

    bool tl_istream::string_read(std::string &value) noexcept {
        if (!ensure_byte()) [[unlikely]] {
            return false;
        }
        auto len = size_t(static_cast<unsigned char>(*ptr));
        if (len >= basictl::TL_BIG_STRING_MARKER) [[unlikely]] {
            if (len > basictl::TL_BIG_STRING_MARKER) [[unlikely]] {
                return set_error_sequence_length();
            }
            uint32_t len32 = 0;
            if (!nat_read(len32)) [[unlikely]] {
                return false;
            }
            len = len32 >> 8U;
            value.clear();
            if (!fetch_data_append(value, len)) [[unlikely]] {
                return false;
            }
            if (!fetch_pad((-len) & 3)) [[unlikely]] {
                return false;
            }
            return true;
        }
        auto pad = ((-(len + 1)) & 3);
        auto fullLen = 1 + len + pad;
        if (ptr + fullLen > end_block) [[unlikely]] {
            ptr += 1;
            value.clear();
            if (!fetch_data_append(value, len)) [[unlikely]] {
                return false;
            }
            if (!fetch_pad(pad)) [[unlikely]] {
                return false;
            }
            return true;
        }
        // fast path for short strings that fully fit in buffer
        uint32_t x = 0;
        std::memcpy(&x, ptr + fullLen - 4, 4);
        if ((x & ~(0xFFFFFFFFU >> (8 * pad))) != 0) [[unlikely]] {
            return set_error_string_padding();
        }
        value.assign(reinterpret_cast<const char *>(ptr + 1), len);
        ptr += fullLen;
        return true;
    }

    void tl_istream::sync() noexcept {
        provider->advance(ptr - start_block);
        start_block = ptr;
    }

    bool tl_istream::has_error() const noexcept {
        return error.has_value();
    }

    std::optional<tl_error> &tl_istream::get_error() noexcept {
        return error;
    }

    bool tl_istream::set_error(tl_error_type type, const char *what) noexcept {
        if (!error.has_value()) {
            error = tl_stream_error(type, what);
        }
        return false;
    }

    bool tl_istream::set_error_eof() noexcept { return set_error(tl_error_type::STREAM_EOF, "EOF"); }

    bool tl_istream::set_error_sequence_length() noexcept {
        return set_error(tl_error_type::INCORRECT_SEQUENCE_LENGTH, "sequence_length");
    }

    bool tl_istream::set_error_string_padding() noexcept {
        return set_error(tl_error_type::INCORRECT_STRING_PADDING, "string_padding");
    }

    bool tl_istream::set_error_expected_tag() noexcept {
        return set_error(tl_error_type::UNEXPECTED_TAG, "expected_tag");
    }

    bool tl_istream::set_error_union_tag() noexcept { return set_error(tl_error_type::UNEXPECTED_TAG, "union_tag"); };

    bool tl_istream::set_error_unknown_scenario() noexcept {
        return set_error(tl_error_type::UNKNOWN_SCENARIO, "union_tag");
    };

    void tl_istream::grow_buffer() noexcept {
        ptr = end_block;
        provider->advance(ptr - start_block);
        auto new_buffer_request = provider->get_buffer();
        if (new_buffer_request) {
            auto new_buffer = new_buffer_request.value();
            ptr = new_buffer.data();
            start_block = ptr;
            end_block = ptr + new_buffer.size();
        } else {
            error = new_buffer_request.error();
        }
    }

    bool tl_istream::ensure_byte() noexcept {
        if (ptr >= end_block) [[unlikely]] {
            grow_buffer();
            if (ptr == end_block) [[unlikely]] {
                return set_error_eof();
            }
        }
        return true;
    }

    bool tl_istream::fetch_data(void *vdata, size_t size) noexcept {
        if (ptr + size > end_block) [[unlikely]] {
            return fetch_data2(vdata, size);
        }
        std::memcpy(reinterpret_cast<char *>(vdata), ptr, size);
        ptr += size;
        return true;
    }

    bool tl_istream::fetch_data2(void *vdata, size_t size) noexcept {
        char *data = reinterpret_cast<char *>(vdata);
        for (; ptr + size > end_block;) [[unlikely]] {
            std::memcpy(data, ptr, end_block - ptr);
            data += end_block - ptr;
            size -= end_block - ptr;
            grow_buffer();
            if (ptr == end_block) [[unlikely]] {
                return set_error_eof();
            }
        }
        std::memcpy(data, ptr, size);
        ptr += size;
        return true;
    }

    bool tl_istream::fetch_data_append(std::string &value, size_t size) noexcept {
        for (; ptr + size > end_block;) [[unlikely]] {
            // assert(ptr <= end)
            value.append(reinterpret_cast<const char *>(ptr), end_block - ptr);
            size -= end_block - ptr;
            grow_buffer();
            // assert(ptr <= end)
            if (ptr == end_block) [[unlikely]] {
                return set_error_eof();
            }
        }
        value.append(reinterpret_cast<const char *>(ptr), size);
        ptr += size;
        return true;
    }

    bool tl_istream::fetch_pad(size_t len) noexcept {
        uint32_t x = 0;
        if (!fetch_data(&x, len)) [[unlikely]] {
            return false;
        }
        if (x != 0) [[unlikely]] {
            return set_error_string_padding();
        }
        return true;
    }

    void static throw_exception_from_tl_stream(tl_error &error) {
        switch (error.index()) {
            case 0:
                throw std::get<0>(error);
            case 1:
                throw std::get<1>(error);
        }
    }

    void tl_istream::pass_data(tl_throwable_istream &to) {
        to.provider = provider;
        to.ptr = ptr;
        to.start_block = start_block;
        to.end_block = end_block;

        if (has_error()) {
            ::basictl::throw_exception_from_tl_stream(error.value());
        }
    }

    tl_ostream::tl_ostream(tl_output_connector &provider) : provider(&provider) {}

    tl_ostream::tl_ostream(tl_throwable_ostream &from) : provider(nullptr) {
        from.pass_data(*this);
    }

    bool tl_ostream::string_write(const std::string &value) {
        auto len = value.size();
        if (len > basictl::TL_MAX_TINY_STRING_LEN) [[unlikely]] {
            if (len > basictl::TL_BIG_STRING_LEN) [[unlikely]] {
                return set_error_sequence_length();
            }
            uint32_t p = (len << 8U) | basictl::TL_BIG_STRING_MARKER;
            if (!store_data(&p, 4)) [[unlikely]] {
                return false;
            }
            if (!store_data(value.data(), value.size())) [[unlikely]] {
                return false;
            }
            if (!store_pad((-len) & 3)) [[unlikely]] {
                return false;
            }
            return true;
        }
        auto pad = ((-(len + 1)) & 3);
        auto fullLen = 1 + len + pad;
        if (ptr + fullLen > end_block) [[unlikely]] {
            auto p = static_cast<unsigned char>(len);
            if (!store_data(&p, 1)) [[unlikely]] {
                return false;
            }
            if (!store_data(value.data(), value.size())) [[unlikely]] {
                return false;
            }
            if (!store_pad(pad)) [[unlikely]] {
                return false;
            }
            return true;
        }
        // fast path for short strings that fully fit in buffer
        uint32_t x = 0;
        std::memcpy(ptr + fullLen - 4, &x, 4); // padding first
        *ptr = static_cast<std::byte>(len);
        std::memcpy(ptr + 1, value.data(), len);
        ptr += fullLen;
        return true;
    }

    void tl_ostream::sync() noexcept {
        provider->advance(ptr - start_block);
        start_block = ptr;
    }

    bool tl_ostream::has_error() const noexcept {
        return error.has_value();
    }

    std::optional<tl_error> &tl_ostream::get_error() noexcept {
        return error;
    }

    bool tl_ostream::set_error(tl_error_type type, const char *what) noexcept {
        if (!error.has_value()) {
            error = tl_stream_error(type, what);
        }
        return false;
    }

    bool tl_ostream::set_error_eof() noexcept { return set_error(tl_error_type::STREAM_EOF, "EOF"); }

    bool tl_ostream::set_error_sequence_length() noexcept {
        return set_error(tl_error_type::INCORRECT_SEQUENCE_LENGTH, "sequence_length");
    }

    bool tl_ostream::set_error_string_padding() noexcept {
        return set_error(tl_error_type::INCORRECT_STRING_PADDING, "string_padding");
    }

    bool tl_ostream::set_error_bool_tag() noexcept { return set_error(tl_error_type::UNEXPECTED_TAG, "bool_tag"); }

    bool tl_ostream::set_error_expected_tag() noexcept {
        return set_error(tl_error_type::UNEXPECTED_TAG, "expected_tag");
    }

    bool tl_ostream::set_error_union_tag() noexcept { return set_error(tl_error_type::UNEXPECTED_TAG, "union_tag"); }

    bool tl_ostream::set_error_unknown_scenario() noexcept {
        return set_error(tl_error_type::UNKNOWN_SCENARIO, "union_tag");
    };

    void tl_ostream::grow_buffer() {
        ptr = end_block;
        provider->advance(ptr - start_block);
        auto new_buffer_request = provider->get_buffer();
        if (new_buffer_request) {
            auto new_buffer = new_buffer_request.value();
            ptr = new_buffer.data();
            start_block = ptr;
            end_block = ptr + new_buffer.size();
        } else {
            error = new_buffer_request.error();
        }
    }

    bool tl_ostream::store_data(const void *vdata, size_t size) {
        if (ptr + size > end_block) [[unlikely]] {
            return store_data2(vdata, size);
        }
        std::memcpy(ptr, reinterpret_cast<const char *>(vdata), size);
        ptr += size;
        return true;
    }

    bool tl_ostream::store_data2(const void *vdata, size_t size) {
        const char *data = reinterpret_cast<const char *>(vdata);
        for (; ptr + size > end_block;) [[unlikely]] {
            std::memcpy(ptr, data, end_block - ptr);
            data += end_block - ptr;
            size -= end_block - ptr;
            grow_buffer();
            if (ptr == end_block) [[unlikely]] {
                return set_error_eof();
            }
        }
        std::memcpy(ptr, data, size);
        ptr += size;
        return true;
    }

    bool tl_ostream::store_pad(size_t size) {
        for (; ptr + size > end_block;) [[unlikely]] {
            // assert(ptr <= end)
            std::memset(ptr, 0, end_block - ptr);
            size -= end_block - ptr;
            grow_buffer();
            // assert(ptr <= end)
            if (ptr == end_block) [[unlikely]] {
                return set_error_eof();
            }
        }
        if (size != 0) {
            ptr[0] = static_cast<std::byte>(0);
            ptr[size - 1] = static_cast<std::byte>(0);
            ptr[size / 2] = static_cast<std::byte>(0);
            ptr += size;
        }
        return true;
    }

    void tl_ostream::pass_data(tl_throwable_ostream &to) {
        to.provider = provider;
        to.ptr = ptr;
        to.start_block = start_block;
        to.end_block = end_block;

        if (has_error()) {
            ::basictl::throw_exception_from_tl_stream(error.value());
        }
    }
} // namespace basictl`
	m["io_streams.h"] = `#ifndef BASICTL_CPP_IO_STREAMS_H
#define BASICTL_CPP_IO_STREAMS_H

/** TLGEN: CPP INCLUDES */
#include "dependencies.h"
#include "constants.h"
#include "io_connectors.h"
/** TLGEN: CPP INCLUDES END */

namespace basictl {
    class tl_throwable_istream;

    class tl_istream {
    public:
        explicit tl_istream(tl_input_connector &provider);

        explicit tl_istream(tl_throwable_istream &from);

        tl_istream(const tl_istream &) = delete;

        tl_istream &operator=(const tl_istream &) = delete;

        tl_istream(tl_istream &&) = delete;

        tl_istream &operator=(tl_istream &&) = delete;

        ~tl_istream() { if (sync_in_destructor) sync(); };

        friend class tl_throwable_istream;

        void pass_data(tl_throwable_istream &to);

        bool nat_read(uint32_t &value) noexcept {
            if (ptr + basictl::TL_UINT32_SIZE > end_block) [[unlikely]] {
                return fetch_data2(&value, basictl::TL_UINT32_SIZE);
            }
            std::memcpy(reinterpret_cast<char *>(&value), ptr, basictl::TL_UINT32_SIZE);
            ptr += basictl::TL_UINT32_SIZE;
            return true;
        }

        bool nat_read_exact_tag(uint32_t tag) noexcept {
            uint32_t actual_tag = 0;
            if (!nat_read(actual_tag)) [[unlikely]] {
                return false;
            }
            if (tag != actual_tag) [[unlikely]] {
                return set_error_expected_tag();
            }
            return true;
        }

        bool int_read(int32_t &value) noexcept {
            if (ptr + basictl::TL_INT32_SIZE > end_block) [[unlikely]] {
                return fetch_data2(&value, basictl::TL_INT32_SIZE);
            }
            std::memcpy(reinterpret_cast<char *>(&value), ptr, basictl::TL_INT32_SIZE);
            ptr += basictl::TL_INT32_SIZE;
            return true;
        };

        bool long_read(int64_t &value) noexcept {
            if (ptr + basictl::TL_INT64_SIZE > end_block) [[unlikely]] {
                return fetch_data2(&value, basictl::TL_INT64_SIZE);
            }
            std::memcpy(reinterpret_cast<char *>(&value), ptr, basictl::TL_INT64_SIZE);
            ptr += basictl::TL_INT64_SIZE;
            return true;
        };

        bool float_read(float &value) noexcept {
            if (ptr + basictl::TL_FLOAT32_SIZE > end_block) [[unlikely]] {
                return fetch_data2(&value, basictl::TL_FLOAT32_SIZE);
            }
            std::memcpy(reinterpret_cast<char *>(&value), ptr, basictl::TL_FLOAT32_SIZE);
            ptr += basictl::TL_FLOAT32_SIZE;
            return true;
        };

        bool double_read(double &value) noexcept {
            if (ptr + basictl::TL_FLOAT64_SIZE > end_block) [[unlikely]] {
                return fetch_data2(&value, basictl::TL_FLOAT64_SIZE);
            }
            std::memcpy(reinterpret_cast<char *>(&value), ptr, basictl::TL_FLOAT64_SIZE);
            ptr += basictl::TL_FLOAT64_SIZE;
            return true;
        }

        bool bool_read(bool &value, uint32_t f, uint32_t t) noexcept {
            uint32_t tag = 0;
            if (!nat_read(tag)) [[unlikely]] {
                return false;
            }
            if (tag == t) {
                value = true;
                return true;
            }
            if (tag != f) [[unlikely]] {
                set_error(tl_error_type::UNEXPECTED_TAG, "unexpected bool tag");
            }
            value = false;
            return true;
        }

        bool string_read(std::string &value) noexcept;

        void sync() noexcept;

        [[nodiscard]] bool has_error() const noexcept;

        [[nodiscard]] std::optional<tl_error> &get_error() noexcept;

        bool set_error(tl_error_type type, const char *what) noexcept;

        bool set_error_eof() noexcept;

        bool set_error_sequence_length() noexcept;

        bool set_error_string_padding() noexcept;

        bool set_error_expected_tag() noexcept;

        bool set_error_union_tag() noexcept;

        bool set_error_unknown_scenario() noexcept;

    private:
        tl_input_connector *provider;
        std::optional<tl_error> error;

        const std::byte *start_block{};
        const std::byte *ptr{};
        const std::byte *end_block{};

        bool sync_in_destructor = true;

        void grow_buffer() noexcept;

        bool ensure_byte() noexcept;

        bool fetch_data(void *vdata, size_t size) noexcept;

        bool fetch_data2(void *vdata, size_t size) noexcept;

        bool fetch_data_append(std::string &value, size_t size) noexcept;

        bool fetch_pad(size_t len) noexcept;
    };

    class tl_throwable_ostream;

    class tl_ostream {
    public:
        explicit tl_ostream(tl_output_connector &provider);

        explicit tl_ostream(tl_throwable_ostream &from);

        tl_ostream(const tl_ostream &) = delete;

        tl_ostream &operator=(const tl_ostream &) = delete;

        tl_ostream(tl_ostream &&) = delete;

        tl_ostream &operator=(tl_ostream &&) = delete;

        ~tl_ostream() { sync(); };

        friend class tl_throwable_ostream;

        void pass_data(tl_throwable_ostream &to);

        bool nat_write(uint32_t value) {
            if (ptr + basictl::TL_UINT32_SIZE > end_block) [[unlikely]] {
                return store_data2(&value, basictl::TL_UINT32_SIZE);
            }
            std::memcpy(ptr, reinterpret_cast<const char *>(&value), basictl::TL_UINT32_SIZE);
            ptr += basictl::TL_UINT32_SIZE;
            return true;
        };

        bool int_write(int32_t value) {
            if (ptr + basictl::TL_INT32_SIZE > end_block) [[unlikely]] {
                return store_data2(&value, basictl::TL_INT32_SIZE);
            }
            std::memcpy(ptr, reinterpret_cast<const char *>(&value), basictl::TL_INT32_SIZE);
            ptr += basictl::TL_INT32_SIZE;
            return true;
        };

        bool long_write(int64_t value) {
            if (ptr + basictl::TL_INT64_SIZE > end_block) [[unlikely]] {
                return store_data2(&value, basictl::TL_INT64_SIZE);
            }
            std::memcpy(ptr, reinterpret_cast<const char *>(&value), basictl::TL_INT64_SIZE);
            ptr += basictl::TL_INT64_SIZE;
            return true;
        };

        bool float_write(float value) {
            if (ptr + basictl::TL_FLOAT32_SIZE > end_block) [[unlikely]] {
                return store_data2(&value, basictl::TL_FLOAT32_SIZE);
            }
            std::memcpy(ptr, reinterpret_cast<const char *>(&value), basictl::TL_FLOAT32_SIZE);
            ptr += basictl::TL_FLOAT32_SIZE;
            return true;
        };

        bool double_write(double value) {
            if (ptr + basictl::TL_FLOAT64_SIZE > end_block) [[unlikely]] {
                return store_data2(&value, basictl::TL_FLOAT64_SIZE);
            }
            std::memcpy(ptr, reinterpret_cast<const char *>(&value), basictl::TL_FLOAT64_SIZE);
            ptr += basictl::TL_FLOAT64_SIZE;
            return true;
        };

        bool string_write(const std::string &value);

        void sync() noexcept;

        [[nodiscard]] bool has_error() const noexcept;

        [[nodiscard]] std::optional<tl_error> &get_error() noexcept;

        bool set_error(tl_error_type type, const char *e) noexcept;

        bool set_error_eof() noexcept;

        bool set_error_sequence_length() noexcept;

        bool set_error_string_padding() noexcept;

        bool set_error_bool_tag() noexcept;

        bool set_error_expected_tag() noexcept;

        bool set_error_union_tag() noexcept;

        bool set_error_unknown_scenario() noexcept;

    private:
        tl_output_connector *provider;
        std::optional<tl_error> error;

        std::byte *start_block{};
        std::byte *ptr{};
        std::byte *end_block{};

        void grow_buffer();

        bool store_data(const void *vdata, size_t size);

        bool store_data2(const void *vdata, size_t size);

        bool store_pad(size_t size);
    };
}

#endif //BASICTL_CPP_IO_STREAMS_H
`
	m["io_throwable_streams.cpp"] = `/** TLGEN: CPP INCLUDES */
#include "io_streams.h"
#include "io_throwable_streams.h"
/** TLGEN: CPP INCLUDES END */

namespace basictl {
    tl_throwable_istream::tl_throwable_istream(tl_input_connector &provider) : provider(&provider) {}

    void tl_throwable_istream::string_read(std::string &value) {
        ensure_byte();
        auto len = size_t(static_cast<unsigned char>(*ptr));
        if (len >= basictl::TL_BIG_STRING_MARKER) [[unlikely]] {
            if (len > basictl::TL_BIG_STRING_MARKER) [[unlikely]] {
                throw tl_stream_error(tl_error_type::INCORRECT_SEQUENCE_LENGTH, "TODO - huge string");
            }
            uint32_t len32 = 0;
            nat_read(len32);
            len = len32 >> 8U;
            value.clear();
            fetch_data_append(value, len);
            fetch_pad((-len) & 3);
            return;
        }
        auto pad = ((-(len + 1)) & 3);
        auto fullLen = 1 + len + pad;
        if (ptr + fullLen > end_block) [[unlikely]] {
            ptr += 1;
            value.clear();
            fetch_data_append(value, len);
            fetch_pad(pad);
            return;
        }
        // fast path for short strings that fully fit in buffer
        uint32_t x = 0;
        std::memcpy(&x, ptr + fullLen - 4, 4);
        if ((x & ~(0xFFFFFFFFU >> (8 * pad))) != 0) [[unlikely]] {
            throw tl_stream_error(tl_error_type::INCORRECT_STRING_PADDING, "incorrect string padding");
        }
        value.assign(reinterpret_cast<const char *>(ptr + 1), len);
        ptr += fullLen;
    }

    void tl_throwable_istream::sync() noexcept {
        provider->advance(ptr - start_block);
        start_block = ptr;
    }

    void tl_throwable_istream::grow_buffer() {
        ptr = end_block;
        provider->advance(ptr - start_block);
        auto new_buffer_request = provider->get_buffer();
        if (new_buffer_request) {
            auto new_buffer = new_buffer_request.value();
            ptr = new_buffer.data();
            start_block = ptr;
            end_block = ptr + new_buffer.size();
        } else {
            throw tl_connector_error(new_buffer_request.error());
        }
    }

    void tl_throwable_istream::ensure_byte() {
        if (ptr >= end_block) [[unlikely]] {
            grow_buffer();
            if (ptr == end_block) [[unlikely]] {
                throw tl_stream_error(tl_error_type::STREAM_EOF, "eof");
            }
        }
    }

    void tl_throwable_istream::fetch_data(void *vdata, size_t size) {
        if (ptr + size > end_block) [[unlikely]] {
            return fetch_data2(vdata, size);
        }
        std::memcpy(reinterpret_cast<char *>(vdata), ptr, size);
        ptr += size;
    }

    void tl_throwable_istream::fetch_data2(void *vdata, size_t size) {
        char *data = reinterpret_cast<char *>(vdata);
        for (; ptr + size > end_block;) [[unlikely]] {
            std::memcpy(data, ptr, end_block - ptr);
            data += end_block - ptr;
            size -= end_block - ptr;
            grow_buffer();
            if (ptr == end_block) [[unlikely]] {
                throw tl_stream_error(tl_error_type::STREAM_EOF, "eof");
            }
        }
        std::memcpy(data, ptr, size);
        ptr += size;
    }

    void tl_throwable_istream::fetch_data_append(std::string &value, size_t size) {
        for (; ptr + size > end_block;) [[unlikely]] {
            // assert(ptr <= end)
            value.append(reinterpret_cast<const char *>(ptr), end_block - ptr);
            size -= end_block - ptr;
            grow_buffer();
            // assert(ptr <= end)
            if (ptr == end_block) [[unlikely]] {
                throw tl_stream_error(tl_error_type::STREAM_EOF, "eof");
            }
        }
        value.append(reinterpret_cast<const char *>(ptr), size);
        ptr += size;
    }

    void tl_throwable_istream::fetch_pad(size_t len) {
        uint32_t x = 0;
        fetch_data(&x, len);
        if (x != 0) [[unlikely]] {
            throw tl_stream_error(tl_error_type::INCORRECT_STRING_PADDING, "incorrect string padding");
        }
    }

    void tl_throwable_istream::pass_data(tl_istream &to) noexcept {
        to.provider = provider;
        to.ptr = ptr;
        to.start_block = start_block;
        to.end_block = end_block;
    }

    tl_throwable_ostream::tl_throwable_ostream(tl_output_connector &provider) {
        this->provider = &provider;
    }

    void tl_throwable_ostream::string_write(const std::string &value) {
        auto len = value.size();
        if (len > basictl::TL_MAX_TINY_STRING_LEN) [[unlikely]] {
            if (len > basictl::TL_BIG_STRING_LEN) [[unlikely]] {
                throw tl_stream_error(tl_error_type::INCORRECT_SEQUENCE_LENGTH, "TODO - huge string");
            }
            uint32_t p = (len << 8U) | basictl::TL_BIG_STRING_MARKER;
            store_data(&p, 4);
            store_data(value.data(), value.size());
            store_pad((-len) & 3);
            return;
        }
        auto pad = ((-(len + 1)) & 3);
        auto fullLen = 1 + len + pad;
        if (ptr + fullLen > end_block) [[unlikely]] {
            auto p = static_cast<unsigned char>(len);
            store_data(&p, 1);
            store_data(value.data(), value.size());
            store_pad(pad);
            return;
        }
        // fast path for short strings that fully fit in buffer
        uint32_t x = 0;
        std::memcpy(ptr + fullLen - 4, &x, 4); // padding first
        *ptr = static_cast<std::byte>(len);
        std::memcpy(ptr + 1, value.data(), len);
        ptr += fullLen;
    }

    void tl_throwable_ostream::sync() noexcept {
        provider->advance(ptr - start_block);
        start_block = ptr;
    }


    void tl_throwable_ostream::grow_buffer() {
        ptr = end_block;
        provider->advance(ptr - start_block);
        auto new_buffer_request = provider->get_buffer();
        if (new_buffer_request) {
            auto new_buffer = new_buffer_request.value();
            ptr = new_buffer.data();
            start_block = ptr;
            end_block = ptr + new_buffer.size();
        } else {
            throw tl_connector_error(new_buffer_request.error());
        }
    }

    void tl_throwable_ostream::store_data(const void *vdata, size_t size) {
        if (ptr + size > end_block) [[unlikely]] {
            return store_data2(vdata, size);
        }
        std::memcpy(ptr, reinterpret_cast<const char *>(vdata), size);
        ptr += size;
    }

    void tl_throwable_ostream::store_data2(const void *vdata, size_t size) {
        const char *data = reinterpret_cast<const char *>(vdata);
        for (; ptr + size > end_block;) [[unlikely]] {
            std::memcpy(ptr, data, end_block - ptr);
            data += end_block - ptr;
            size -= end_block - ptr;
            grow_buffer();
            if (ptr == end_block) [[unlikely]] {
                throw tl_stream_error(tl_error_type::STREAM_EOF, "eof");
            }
        }
        std::memcpy(ptr, data, size);
        ptr += size;
    }

    void tl_throwable_ostream::store_pad(size_t size) {
        for (; ptr + size > end_block;) [[unlikely]] {
            // assert(ptr <= end)
            std::memset(ptr, 0, end_block - ptr);
            size -= end_block - ptr;
            grow_buffer();
            // assert(ptr <= end)
            if (ptr == end_block) [[unlikely]] {
                throw tl_stream_error(tl_error_type::STREAM_EOF, "eof");
            }
        }
        if (size != 0) {
            ptr[0] = static_cast<std::byte>(0);
            ptr[size - 1] = static_cast<std::byte>(0);
            ptr[size / 2] = static_cast<std::byte>(0);
            ptr += size;
        }
    }

    void tl_throwable_ostream::pass_data(tl_ostream &to) noexcept {
        to.provider = provider;
        to.ptr = ptr;
        to.start_block = start_block;
        to.end_block = end_block;
    }
} // namespace basictl`
	m["io_throwable_streams.h"] = `#ifndef BASICTL_CPP_IO_THROWABLE_STREAMS_H
#define BASICTL_CPP_IO_THROWABLE_STREAMS_H

/** TLGEN: CPP INCLUDES */
#include "dependencies.h"
#include "constants.h"
#include "io_connectors.h"
/** TLGEN: CPP INCLUDES END */

namespace basictl {
    class tl_istream;

    class tl_throwable_istream {
    public:
        explicit tl_throwable_istream(tl_input_connector &provider);

        tl_throwable_istream(const tl_throwable_istream &) = delete;

        tl_throwable_istream &operator=(const tl_throwable_istream &) = delete;

        tl_throwable_istream(tl_throwable_istream &&) = delete;

        tl_throwable_istream &operator=(tl_throwable_istream &&) = delete;

        ~tl_throwable_istream() { sync(); };

        friend class tl_istream;

        void pass_data(tl_istream &to) noexcept;

        uint32_t nat_read() {
            uint32_t result;
            nat_read(result);
            return result;
        }

        void nat_read(uint32_t &value) {
            if (ptr + basictl::TL_UINT32_SIZE > end_block) [[unlikely]] {
                return fetch_data2(&value, basictl::TL_UINT32_SIZE);
            }
            std::memcpy(reinterpret_cast<char *>(&value), ptr, basictl::TL_UINT32_SIZE);
            ptr += basictl::TL_UINT32_SIZE;
        }

        void nat_read_exact_tag(uint32_t tag) {
            uint32_t actual_tag = 0;
            nat_read(actual_tag);
            if (tag != actual_tag) [[unlikely]] {
                throw tl_stream_error(tl_error_type::UNEXPECTED_TAG, "unexpected tag");
            }
        }

        int32_t int_read() {
            int32_t result;
            int_read(result);
            return result;
        }

        void int_read(int32_t &value) {
            if (ptr + basictl::TL_INT32_SIZE > end_block) [[unlikely]] {
                return fetch_data2(&value, basictl::TL_INT32_SIZE);
            }
            std::memcpy(reinterpret_cast<char *>(&value), ptr, basictl::TL_INT32_SIZE);
            ptr += basictl::TL_INT32_SIZE;
        };

        int64_t long_read() {
            int64_t result;
            long_read(result);
            return result;
        }

        void long_read(int64_t &value) {
            if (ptr + basictl::TL_INT64_SIZE > end_block) [[unlikely]] {
                return fetch_data2(&value, basictl::TL_INT64_SIZE);
            }
            std::memcpy(reinterpret_cast<char *>(&value), ptr, basictl::TL_INT64_SIZE);
            ptr += basictl::TL_INT64_SIZE;
        };

        float float_read() {
            float result;
            float_read(result);
            return result;
        }

        void float_read(float &value) {
            if (ptr + basictl::TL_FLOAT32_SIZE > end_block) [[unlikely]] {
                return fetch_data2(&value, basictl::TL_FLOAT32_SIZE);
            }
            std::memcpy(reinterpret_cast<char *>(&value), ptr, basictl::TL_FLOAT32_SIZE);
            ptr += basictl::TL_FLOAT32_SIZE;
        };

        double double_read() {
            double result;
            double_read(result);
            return result;
        }

        void double_read(double &value) {
            if (ptr + basictl::TL_FLOAT64_SIZE > end_block) [[unlikely]] {
                return fetch_data2(&value, basictl::TL_FLOAT64_SIZE);
            }
            std::memcpy(reinterpret_cast<char *>(&value), ptr, basictl::TL_FLOAT64_SIZE);
            ptr += basictl::TL_FLOAT64_SIZE;
        }

        bool bool_read(uint32_t f, uint32_t t) {
            bool result;
            bool_read(result, f, t);
            return result;
        }

        void bool_read(bool &value, uint32_t f, uint32_t t) {
            uint32_t tag = 0;
            nat_read(tag);
            if (tag == t) {
                value = true;
                return;
            }
            if (tag != f) [[unlikely]] {
                throw tl_stream_error(tl_error_type::UNEXPECTED_TAG, "unexpected bool tag");
            }
            value = false;
        }

        void string_read(std::string &value);

        void sync() noexcept;

    private:
        tl_input_connector *provider;

        const std::byte *start_block{};
        const std::byte *ptr{};
        const std::byte *end_block{};

        void grow_buffer();

        void ensure_byte();

        void fetch_data(void *vdata, size_t size);

        void fetch_data2(void *vdata, size_t size);

        void fetch_data_append(std::string &value, size_t size);

        void fetch_pad(size_t len);
    };

    class tl_ostream;

    class tl_throwable_ostream { // TODO - prohibit copy/move
    public:
        explicit tl_throwable_ostream(tl_output_connector &provider);

        tl_throwable_ostream(const tl_throwable_ostream &) = delete;

        tl_throwable_ostream &operator=(const tl_throwable_ostream &) = delete;

        tl_throwable_ostream(tl_throwable_ostream &&) = delete;

        tl_throwable_ostream &operator=(tl_throwable_ostream &&) = delete;

        ~tl_throwable_ostream() { sync(); };

        friend class tl_ostream;

        void pass_data(tl_ostream &to) noexcept;

        void nat_write(uint32_t value) {
            if (ptr + basictl::TL_UINT32_SIZE > end_block) [[unlikely]] {
                return store_data2(&value, basictl::TL_UINT32_SIZE);
            }
            std::memcpy(ptr, reinterpret_cast<const char *>(&value), basictl::TL_UINT32_SIZE);
            ptr += basictl::TL_UINT32_SIZE;
        };

        void int_write(int32_t value) {
            if (ptr + basictl::TL_INT32_SIZE > end_block) [[unlikely]] {
                return store_data2(&value, basictl::TL_INT32_SIZE);
            }
            std::memcpy(ptr, reinterpret_cast<const char *>(&value), basictl::TL_INT32_SIZE);
            ptr += basictl::TL_INT32_SIZE;
        };

        void long_write(int64_t value) {
            if (ptr + basictl::TL_INT64_SIZE > end_block) [[unlikely]] {
                return store_data2(&value, basictl::TL_INT64_SIZE);
            }
            std::memcpy(ptr, reinterpret_cast<const char *>(&value), basictl::TL_INT64_SIZE);
            ptr += basictl::TL_INT64_SIZE;
        };

        void float_write(float value) {
            if (ptr + basictl::TL_FLOAT32_SIZE > end_block) [[unlikely]] {
                return store_data2(&value, basictl::TL_FLOAT32_SIZE);
            }
            std::memcpy(ptr, reinterpret_cast<const char *>(&value), basictl::TL_FLOAT32_SIZE);
            ptr += basictl::TL_FLOAT32_SIZE;
        };

        void double_write(double value) {
            if (ptr + basictl::TL_FLOAT64_SIZE > end_block) [[unlikely]] {
                return store_data2(&value, basictl::TL_FLOAT64_SIZE);
            }
            std::memcpy(ptr, reinterpret_cast<const char *>(&value), basictl::TL_FLOAT64_SIZE);
            ptr += basictl::TL_FLOAT64_SIZE;
        };

        void string_write(const std::string &value);

        void sync() noexcept;

    private:
        tl_output_connector *provider;

        std::byte *start_block{};
        std::byte *ptr{};
        std::byte *end_block{};

        void grow_buffer();

        void store_data(const void *vdata, size_t size);

        void store_data2(const void *vdata, size_t size);

        void store_pad(size_t size);
    };
}


#endif //BASICTL_CPP_IO_THROWABLE_STREAMS_H
`
	m["impl/string_io.h"] = `#ifndef BASICTL_CPP_STRING_IO_H
#define BASICTL_CPP_STRING_IO_H

/** TLGEN: CPP INCLUDES */
#include "../io_connectors.h"
/** TLGEN: CPP INCLUDES END */

namespace basictl {
    class tl_istream_string : public tl_input_connector {
    public:
        explicit tl_istream_string(const std::string & buffer) : buffer(buffer) {}

        tl_connector_result<std::span<const std::byte>> get_buffer() noexcept override;
        void advance(size_t size) noexcept override;

        std::span<const std::byte> used_buffer();
    private:
        const std::string & buffer;
        size_t used_size = 0;
    };

    class tl_ostream_string : public tl_output_connector {
    public:
        explicit tl_ostream_string(std::string & buffer) : buffer(buffer) {}

        tl_connector_result<std::span<std::byte>> get_buffer() noexcept override;
        void advance(size_t size) noexcept override;

        std::span<std::byte> used_buffer();
    private:
        std::string & buffer;
        size_t used_size = 0;
    };
};

#endif //BASICTL_CPP_STRING_IO_H
`
	m["impl/string_io.cpp"] = `/** TLGEN: CPP INCLUDES */
#include "string_io.h"
/** TLGEN: CPP INCLUDES END */

namespace basictl {
    tl_connector_result<std::span<const std::byte>> tl_istream_string::get_buffer() noexcept {
        return tl_connector_result(std::span<const std::byte>{reinterpret_cast<const std::byte*>(buffer.data()) + used_size, buffer.size() - used_size});
    }

    void tl_istream_string::advance(size_t size) noexcept {
        used_size += size;
    }

    std::span<const std::byte> tl_istream_string::used_buffer() {
        return {reinterpret_cast<const std::byte*>(buffer.data()), used_size};
    }

    tl_connector_result<std::span<std::byte>> tl_ostream_string::get_buffer() noexcept {
        return tl_connector_result(std::span<std::byte>{reinterpret_cast<std::byte*>(buffer.data()) + used_size, buffer.size() - used_size});
    }

    void tl_ostream_string::advance(size_t size) noexcept {
        used_size += size;
        if (used_size == buffer.size()) {
            buffer.resize(buffer.size() * 3 / 2 + 1024);
        }
    }

    std::span<std::byte> tl_ostream_string::used_buffer() {
        return {reinterpret_cast<std::byte*>(buffer.data()), used_size};
    }
}`
	m["dependencies.h"] = `#ifndef BASICTL_CPP_DEPENDENCIES_H
#define BASICTL_CPP_DEPENDENCIES_H

#include <array>
#include <optional>
#include <ostream>
#include <memory>
#include <variant>
#include <vector>
#include <map>

#endif //BASICTL_CPP_DEPENDENCIES_H
`
	return m
}
